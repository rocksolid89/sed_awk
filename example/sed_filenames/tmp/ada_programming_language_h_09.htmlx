<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<title>Адское программирование.</title>
</head>


<body BGCOLOR="FFFFFF">
<basefont size=3>
<blockquote>

<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>



<!--- header --->



<h2><a name="s9">9. Настраиваемые модули в языке Ада (<i>generics</i>)</a></h2>

<p align="JUSTIFY">
Долгие годы одной из самых больших надежд программистов была надежда в
многократном повторном использовании однажды написанного кода (похоже, ...и осталась).

Хотя библиотеки математических подпрограмм используются достаточно широко,
следует заметить, что математика оказалась весьма удачной предметной областью
в которой функции хорошо описаны и стабильны.

Попытки разработать подобные библиотеки в других предметных областях
имели достаточно ограниченный успех
из-за неминуемого изменения алгоритмов обработки и типов данных в подпрограммах.

Ада пытается помочь в решении этой проблемы предоставляя возможность производства кода,
который в большей степени зависит не от специфики используемого типа данных,
а от общности алгоритма обработки.


<p align="JUSTIFY">
Как описано Найдичем (<i>Naiditch</i>), настраиваемые модули во многом подобны шаблонам
стандартных писем.

Шаблоны стандартных писем,
в основном, являются законченными письмами, но с несколькими пустыми местами
в которых необходимо произвести подстановку (например, дописать имя и адрес).

Таким образом, шаблоны стандартных писем
не могут быть отосланы до тех по пока не будут заполнены
пустые места, которые должны содержать эту недостающую информацию.


<p align="JUSTIFY">
Подобным образом, настраиваемые модули не могут быть непосредственно использованы.

Мы создаем новую подпрограмму или пакет путем конкретизации (<i>instantiating</i>)
настраиваемого модуля, или, другими словами, создаем из настраиваемого модуля
экземпляр настроенного модуля.

При конкретизации настраиваемого модуля мы должны предоставить недостающую информацию,
которая может быть информацией о типе, значении или даже подпрограмме.


<p>
<h3><a name="s9.1">9.1 Общие сведения о настраиваемых модулях</a></h3>

<p align="JUSTIFY">
В языке Ада, любой программный модуль (подпрограмма или пакет) может быть
настраиваемым модулем.

Такой настраиваемый модуль используется для создания экземпляра кода,
который будет работать с фактическим типом данных.

Требуемый тип данных передается как параметр настройки при конкретизации настраиваемого модуля
(создании экземпляра настроенного модуля).

Как правило, описание настраиваемого модуля представлено двумя частями:
спецификацией настраиваемого модуля и телом настраиваемого модуля.

Спецификация описывает интерфейс настраиваемого модуля,
а тело содержит детали его внутренней реализации.


<p align="JUSTIFY">
Однажды скомпилированные настраиваемые модули помещаются в библиотеку Ады
и могут быть указаны в инструкции спецификатора совместности контекста <tt><b>with</b></tt>
в других компилируемых модулях.

При этом, следует заметить, что настраиваемые модули не могут быть указаны
в инструкции спецификатора использования контекста <tt><b>use</b></tt>.


<p align="JUSTIFY">
После указания настраиваемого модуля в спецификаторе контекста <tt><b>with</b></tt>,
программный модуль (подпрограмма, пакет или другой настраиваемый модуль)
осуществляет конкретизацию настраиваемого модуля, то есть,
создает экземпляр настроенного модуля из настраиваемого модуля.

После этого, экземпляр настроенного модуля (конкретизированная подпрограмма или пакет)
может быть сохранен в библиотеке Ады для последующего использования.


<p align="JUSTIFY">
В качестве простого примера использования настраиваемого модуля,
рассмотрим конкретизацию стандартного настраиваемого пакета <i>Integer_IO</i>:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Ada.Text_IO;        <b>use</b> Ada.Text_IO;

<b>package</b> Int_IO <b>is new</b> Integer_IO(Integer);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Получившийся экземпляр настроенного модуля (пакет <i>Int_IO</i>), в последствии,
может быть помещен в инструкции спецификации контекста <tt><b>with</b></tt> и <tt><b>use</b></tt>
любого программного модуля.

<p align="JUSTIFY">
Следует заметить, что стандартный настраиваемый пакет <i>Integer_IO</i> таким же образом
может быть конкретизирован при использовании других типов.

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Ada.Text_IO;    <b>use</b> Ada.Text_IO;
<b>with</b> Accounts;       <b>use</b> Accounts;

<b>package</b> Account_No_IO <b>is new</b> Integer_IO(Account_No);
</pre></dir>
</td></tr></table>


<p>

<p><h4><a name="s9.1.1">9.1.1 Настраиваемые подпрограммы</a></h4>

<p align="JUSTIFY">
Рассмотрим простой пример описания настраиваемой подпрограммы.

Однажды скомпилированная, она в последствии может быть помещена
в инструкцию спецификатора совместности контекста <tt><b>with</b></tt>
в других программных модулях.

Напомним также, что настраиваемый модуль нельзя указывать
в инструкции спецификатора использования контекста <tt><b>use</b></tt>.


<p align="JUSTIFY">
Спецификация модуля настраиваемой подпрограммы содержит ключевое слово <tt><b>generic</b></tt>,
после которого следует список формальных параметров настройки
и далее - спецификация процедуры:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>generic</b>
    <b>type</b> Element <b>is private</b>;  -- <i>Element</i> - это параметр настраиваемой
                              -- подпрограммы

<b>procedure</b> Exchange(A, B : <b>in out</b> Element);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Тело настраиваемой процедуры описывает реализацию алгоритма работы процедуры
и представляется как отдельно компилируемый модуль.
Примечательно, что оно идентично не настраиваемой версии.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Exchange(A, B  : <b>in out</b> Element) <b>is</b>

    Temp : Element;

<b>begin</b>
    T := Temp;
    T := B;
    B := Temp;
<b>end</b> Exchange;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Код, показанный выше, является простым шаблоном для процедуры, которая может быть реально создана.

Следует обратить внимание на то, что этот код не может быть непосредственно вызван.

Это подобно описанию типа, поскольку не производится никакого распределения пространства
памяти или генерации машинного кода.

<p align="JUSTIFY">
Для создания реальной процедуры, то есть, экземпляра процедуры которую можно вызвать,
необходимо выполнить конкретизацию настраиваемой процедуры:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Swap <b>is new</b> Exchange(Integer);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Следует заметить, что в показанном выше примере конкретизация настраиваемой процедуры
осуществлена с использованием простого позиционного сопоставления формального и фактического
параметров настройки. В дополнение к позиционному сопоставлению, Ада позволяет
использовать именное сопоставление формальных и фактических параметров настройки
(при большом количестве параметров настройки, именное сопоставление улучшает читабельность).
Показанную выше конкретизацию настраиваемой процедуры
можно осуществить с помощью использования именного сопоставления следующим образом:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Swap <b>is new</b> Exchange(Element =&gt; Integer);
</pre></dir>
</td></tr></table>




<p align="JUSTIFY">
Теперь мы имеем процедуру <tt>Swap</tt> которая меняет местами переменные целого типа
<tt>Integer</tt>.

Здесь, <tt>Integer</tt> является фактическим параметром настройки, а <tt>Element</tt> - формальным
параметром настройки.

<p align="JUSTIFY">
Процедура <tt>Swap</tt> может быть вызвана (и она будет вести себя) как будто она была описана
следующим образом:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Swap (A, B  : <b>in out</b> Integer) <b>is</b>

    Temp : Integer;

<b>begin</b>

    . . . 

<b>end</b> Swap;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Таких процедур <tt>Swap</tt> можно создать столько, сколько необходимо.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Swap <b>is new</b> Exchange(Character);
<b>procedure</b> Swap <b>is new</b> Exchange(Element =&gt; Account); -- ассоциация по имени
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В этом случае будет нормально использоваться совмещение имен процедур.

Компилятор будет определять к какой конкретно процедуре производится вызов
используя информацию о типе параметра.





<p><h4><a name="s9.1.2">9.1.2 Настраиваемые пакеты</a></h4>

<p align="JUSTIFY">
Пакеты также могут быть настраиваемыми.

Следующая спецификация настраиваемого пакета достаточно традиционна:        


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>generic</b>
    <b>type</b> Element <b>is private</b>; -- примечательно, что это параметр
                             -- настройки
<b>package</b> Stacks <b>is</b>
    <b>procedure</b> Push(E : <b>in</b> Element);
    <b>procedure</b> Pop(E : <b>out</b> Element);
    <b>function</b> Empty <b>return</b> Boolean;
<b>private</b>
    The_Stack : <b>array</b>(1..200) <b>of</b> Element;
    top       : Integer <b>range</b> 0..200 := 0;
<b>end</b> Stacks;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Сопутствующее тело пакета может иметь подобный вид:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package body</b> Stacks <b>is</b>

    <b>procedure</b> Push(E : <b>in</b> Element) <b>is</b>
        . . .

    <b>procedure</b> Pop(E : <b>out</b> Element) <b>is</b>
        . . .

    <b>function</b> Empty <b>return</b> Boolean <b>is</b>
        . . .

<b>end</b> Stacks;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В качестве элемента настройки, необходимо просто указать любой экземпляр типа данных.



<p><h4><a name="s9.1.3">9.1.3 Дочерние настраиваемые модули</a></h4>

<p align="JUSTIFY">
Настраиваемые пакеты, подобно обычным пакетам Ады, могут иметь дочерние модули.

При этом, следует заметить, что такие дочерние модули также должны быть настраиваемыми модулями.

<p align="JUSTIFY">
В качестве примера, предположим, что нам необходимо расширить настраиваемый пакет <i>Stacks</i>,
который был показан в примере выше (см. 9.1.2).

Допустим, что нам необходимо добавить функцию <tt>Top</tt>, которая возвращает
объект находящийся в вершине стека, но при этом не удаляет его из стека.

Чтобы решить эту задачу, мы можем, для настраиваемого пакета <i>Stacks</i>,
описать дочерний настраиваемый пакет <i>Stacks.Additions</i>.

Спецификация <i>Stacks.Additions</i> может выглядеть следующим образом:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>generic</b>
<b>package</b> Stacks.Additions <b>is</b>
    <b>function</b> Top <b>return</b> Element;
<b>end</b> Stacks.Additions;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Примечательно, что дочерний настраиваемый модуль "видит" все компоненты своего родителя,
включая все параметры настройки.

<p align="JUSTIFY">
Тело дочернего настраиваемого модуля <i>Stacks.Additions</i> может иметь следующий вид:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package body</b> Stacks.Additions <b>is</b>

    <b>function</b> Top <b>return</b> Element <b>is</b>
        . . .

<b>end</b> Stacks.Additions;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Ниже демонстрируется пример конкретизации
настраиваемых модулей <i>Stacks</i> и <i>Stacks.Additions</i>.


<p align="JUSTIFY">
Конкретизация модуля <i>Stacks</i> формирует пакет <i>Our_Stacks</i>,
что имеет вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b>  Stacks;

<b>package</b> Our_Stack <b>is new</b> Stack(Integer);
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Конкретизация модуля <i>Stacks.Additions</i> формирует пакет <i>Our_Stack_Additions</i>,
что имеет вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b>  Our_Stack, Stacks.Additions;

<b>package</b> Our_Stack_Additions <b>is new</b> Stacks.Additions;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Примечательно, что настраиваемый дочерний модуль рассматривается как описанный
внутри настраиваемого родителя.



<!---

<p><h4><a name="s9.1.4">9.1.4 Наследование в настраиваемых модулях</a></h4>

<p align="JUSTIFY">

см параграф 14.8 стр. 206 M.A.Smith "Object Oriented Software in Ada-95"

--->




<p>
<h3><a name="s9.2">9.2 Параметры настройки для настраиваемых модулей</a></h3>

<p align="JUSTIFY">
Существует три типа параметров для настраиваемых модулей:
<ul>
<li>параметры-типы
<li>параметры-значения
<li>параметры-подпрограммы
</ul>

<p align="JUSTIFY">
Необходимо заметить, что до настоящего момента в примерах мы рассматривали только параметры-типы.



<p><h4><a name="s9.2.1">9.2.1 Параметры-типы</a></h4>

<p align="JUSTIFY">
Не смотря на привлекательные свойства настраиваемых модулей,
при определении характера задач, решаемых с помощью настраиваемого модуля,
необходимо иметь возможность накладывать некоторые ограничения.

Допустим, что некоторые настраиваемые модули предусматривают возможность
суммирования массива чисел.

Очевидно, что это характерно только для чисел, и мы не можем производить суммирование записей.

Следовательно, для того, чтобы защититься от конкретизации настраиваемых модулей
с указанием не подходящих типов данных, требуется возможность
в установке некоторых ограничений.

Кроме того, желательно чтобы
компилятор также мог осуществлять проверку того, что мы не выполняем какие-нибудь
не допустимые действия с переменной внутри кода настраиваемого модуля, например,
чтобы он не разрешал использовать атрибут <tt><b>'<i>Pred</i></b></tt> для записей.


<p align="JUSTIFY">
Решение таких задач обеспечивается механизмом который основан
на виде спецификации формального параметра-типа.

Таким образом, спецификация формального параметра-типа определяет категорию типов,
которые могут быть использованы при конкретизации настраиваемого модуля,
а также те действия, которые можно осуществлять над формальным параметром
внутри настраиваемого модуля.

Ниже показан общий список вариантов спецификаций формальных параметров-типов и
различные ограничения, накладываемые на выбор фактических параметров-типов
настраиваемых модулей.




<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> T <b>is limited private</b>    -- тип <i>T</i> - любой тип
<b>type</b> T <b>is private</b>            -- тип <i>T</i> - любой не лимитированный тип


<b>type</b> T <b>is</b> (&lt;&gt;)               -- тип <i>T</i> любой дискретный тип
                             --   (целочисленный или перечислимый)
<b>type</b> T <b>is range</b> &lt;&gt;           -- тип <i>T</i> любой целочисленный тип
<b>type</b> T <b>is mod</b> &lt;&gt;             -- тип <i>T</i> любой модульный целочисленный тип


<b>type</b> T <b>is digits</b> &lt;&gt;          -- тип <i>T</i> любой вещественный тип с плавающей точкой
<b>type</b> T <b>is delta</b> &lt;&gt;           -- тип <i>T</i> любой вещественный тип с фиксированной точкой
<b>type</b> T <b>is delta</b> &lt;&gt; <b>digits</b> &lt;&gt; -- тип <i>T</i> любой вещественный децимальный тип


<b>type</b> T <b>is access</b> Y;          -- тип <i>T</i> любой ссылающийся на <i>Y</i> ссылочный тип
<b>type</b> T <b>is access all</b> Y;      -- тип <i>T</i> любой "<i>access all Y</i>" ссылочный тип
<b>type</b> T <b>is access constant</b> Y; -- тип <i>T</i> любой "<i>access constant Y</i>" ссылочный тип
            -- <u>примечание:</u> тип <i>Y</i> может быть предварительно описанным
            --             настраиваемым параметром


<b>type</b> T <b>is array</b>(Y <b>range</b> &lt;&gt) <b>of</b> Z; -- тип <i>T</i> любой неограниченный массив элементов типа <i>Z</i>
                                  --   у которого <i>Y</i> - подтип индекса
<b>type</b> T <b>is array</b>(Y) <b>of</b> Z;          -- тип <i>T</i> любой ограниченный массив элементов типа <i>Z</i>
                                  --   у которого <i>Y</i> - подтип индекса
            -- <u>примечание:</u> тип <i>Z</i> (тип компонента фактического массива)
            --             должен совпадать с типом формального массива.
            --             если они не являются скалярными типами,
            --             то они оба должны иметь тип
            --             ограниченного или неограниченного массива


<b>type</b> T <b>is new</b> Y;                           -- тип <i>T</i> любой производный от <i>Y</i> тип
<b>type</b> T <b>is new</b> Y <b>with private</b>;              -- тип <i>T</i> любой не абстрактный тэговый тип
                                           --   производный от <i>Y</i>
<b>type</b> T <b>is abstract new</b> Y <b>with private</b>;     -- тип <i>T</i> любой тэговый тип производный от <i>Y</i>
<b>type</b> T <b>is tagged private</b>;                  -- тип <i>T</i> любой не абстрактный не лимитированый
                                           --   тэговый тип
<b>type</b> T <b>is tagged limited private</b>;          -- тип <i>T</i> любой не абстрактный тэговый тип
<b>type</b> T <b>is abstract tagged private</b>;         -- тип <i>T</i> любой не лимитированый тэговый тип
<b>type</b> T <b>is abstract tagged limited private</b>; -- тип <i>T</i> любой тэговый тип
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Для того чтобы лучше понять правила управляющие конкретизацией для
параметров типа массив, рассмотрим следующий настраиваемый пакет:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>generic</b>
    <b>type</b> Item   <b>is private</b>;
    <b>type</b> Index  <b>is</b> (&lt;&gt;);
    <b>type</b> Vector <b>is array</b> (Index <b>range</b> &lt;&gt;) <b>of</b> Item;
    <b>type</b> Table  <b>is array</b> (Index) <b>of</b> Item;
<b>package</b> P <b>is</b> . . .      
</pre></dir>
</td></tr></Table>



<p align="JUSTIFY">
и типы:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Color <b>is</b> (red, green, blue);
<b>type</b> Mix <b>is array</b> (Color <b>range</b> &lt;&gt; ) <b>of</b> Boolean;
<b>type</b> Option <b>is array</b> (Color) <b>of</b> Boolean;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
тогда, <tt>Mix</tt> может соответствовать <tt>Vector</tt>,
а <tt>Option</tt> может соответствовать <tt>Table</tt>.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> R <b>is new</b> P( Item   =&gt; Boolean,
                    Index  =&gt; Color,
                    Vector =&gt; Mix,
                    Table  =&gt; Option);
</pre></dir>
</td></tr></table>



<p><h4><a name="s9.2.2">9.2.2 Параметры-значения</a></h4>

<p align="JUSTIFY">
Параметры-значения позволяют указывать значения для переменных
внутри настраиваемого модуля:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>generic</b>

    <b>type</b> Element <b>is private</b>;
    Size: <b>Positive</b> := 200;

<b>package</b> Stacks <b>is</b>

        <b>procedure</b> Push...
        <b>procedure</b> Pop...
        <b>function</b> Empty <b>return</b> Boolean;

<b>end</b> Stacks;
        
<b>package body</b> Stacks <b>is</b>

    Size : Integer;
    theStack : <b>array</b>(1..Size) <b>of</b> Element;

        . . . 
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Тогда, создать экземпляр настраиваемого модуля можно одним из следующих способов:

<p>
<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Fred <b>is new</b> Stacks(Element =&gt; Integer, Size =&gt; 50);

<b>package</b> Fred <b>is new</b> Stacks(Integer, 1000);

<b>package</b> Fred <b>is new</b> Stacks(Integer);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Следует обратить внимание на то, что при конкретизации настраиваемого модуля
фактический параметр-значение должен быть обязательно указан
только в случаях когда для формального параметра-значения не представлено значение по-умолчанию.


<p align="JUSTIFY">
В качестве параметров-значений допускается использование строк.



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>generic</b>

    <b>type</b> Element <b>is private</b>;
    File_Name : String;

<b>package</b> ....
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Примечательно, что параметр <tt>File_Name</tt>, имеющий строковый тип <tt>String</tt>,
- не ограничен (<i>not constrained</i>).

Это идентично строковым параметрам для подпрограмм.




<p><h4><a name="s9.2.3">9.2.3 Параметры-подпрограммы</a></h4>

<p align="JUSTIFY">
В качестве параметра настройки для настраиваемого модуля может быть передана подпрограмма.

Необходимость в параметрах-подпрограммах чаще всего возникает
когда какой-либо формальный параметр-тип настраиваемого модуля
описан как приватный или лимитированный приватный тип.

В таких случаях, Ада накладывает традиционные ограничения на использование
операций над экземплярами данного типа внутри тела настраиваемого модуля.

Однако, при этом может возникнуть необходимость в осуществлении 
сравнения или выполнения проверки на равенство значений данного типа,
внутри тела настраиваемого модуля.

Следовательно, параметры-подпрограммы являются механизмом,
который предоставляет для компилятора информацию о том как осуществлять эти действия.


<p align="JUSTIFY">
В качестве примера рассмотрим типичный случай требующий применение параметров-подпрограмм.

Предположим, что в качестве одного из параметров настраиваемого модуля
используется лимитированый приватный тип.

Тогда, для этого лимитированного приватного типа,
с помощью параметров-подпрограмм, можно осуществить передачу операций:
проверка на равенство и присваивание.



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>generic</b>

    <b>type</b> Element <b>is limited private</b>;
    <b>with function</b> "="(E1, E2 : Element) <b>return</b> Boolean;
    <b>with procedure</b> Assign(E1, E2 : Element);

<b>package</b> Stuff <b>is</b> . . .
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Конкретизация такого настраиваемого модуля может иметь вид:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Things <b>is new</b> Stuff(Person, Text."=", Text.Assign);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Для формального параметра-подпрограммы может быть указана подпрограмма используемая по-умолчанию.
Тогда, при конкретизации настраиваемого модуля, фактический параметр-подпрограмма
может не указываться.

Предположим, что у нас есть подпрограмма, спецификация которой имеет вид:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> My_Assign(E1, E2 : Person);
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Тогда, при описании формального параметра-подпрограммы <tt>Assign</tt>,
мы можем указать процедуру <tt>My_Assign</tt> как подпрограмму которую
необходимо использовать по-умолчанию следующим образом:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>generic</b>

    <b>type</b> Element <b>is limited private</b>;
    <b>with function</b> "="(E1, E2 : Element) <b>return</b> Boolean;
    <b>with procedure</b> Assign(E1, E2 : Element) <b>is</b> My_Assign(E1, E2 : Person);

<b>package</b> Stuff <b>is</b> . . .
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В результате, конкретизация настраиваемого модуля, с использованием
подпрограммы заданной по-умолчанию, может иметь следующий вид:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Things <b>is new</b> Stuff(Person, Text."=");
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
И наконец, при описании спецификации формального параметра-подпрограммы,
можно указать, что выбор процедуры по-умолчанию должен осуществляться
согласно традиционных правил выбора подпрограмм.

Для функции, реализующей действие знака проверки на равенство (<tt>"="</tt>)
мы можем указать это следующим образом:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>generic</b>

    <b>type</b> Element <b>is limited private</b>;
    <b>with function</b> "="(E1, E2 : Element ) <b>return</b> Boolean <b>is</b> &lt;&gt;;
    . . .
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Теперь, если при конкретизации настраиваемого модуля для функции <tt>"="</tt>
не будет представлена соответствующая функция,
то будет использоваться функция проверки на равенство по-умолчанию,
выбранная в соответствии с фактическим типом <tt>Element</tt>.

Например, если фактический тип <tt>Element</tt> - тип <tt>Integer</tt>,
то будет использоваться обычная, для типа <tt>Integer</tt>, функция <tt>"="</tt>.



<p>
<h3><a name="s9.3">9.3 Преимущества и недостатки настраиваемых модулей</a></h3>

<p align="JUSTIFY">
В заключение обсуждения настраиваемых модулей Ады необходимо отметить преимущества
и недостатки использования данной концепции. 

<p align="JUSTIFY">
Основным преимуществом использования настраиваемых модулей является
то, что они оказывают значительное содействие
в многократном повторном использовании ранее разработанных
и отлаженных алгоритмов.

Действительно, настраиваемые модули позволяют разработчику однажды написать
и отладить алгоритмы подпрограмм для обработки объектов
тип которых в последствии будет указываться пользователями этих подпрограмм.

<p align="JUSTIFY">
Однако, применение настраиваемых модулей не лишено недостатков.

Разработка алгоритмов для настраиваемых модулей требует более тщательного внимания,
что в результате является дополнительной нагрузкой для их автора.

Также необходимо заметить, что реализация настраиваемой процедуры, функции или пакета
может оказаться не столь эффективной как непосредственная реализация.

Компилятор может генерировать один и тот же код для всех экземпляров
настроенных процедур, функций или пакетов, не зависимо от фактически
обрабатываемых данных.









<!--- footer --->




<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>




</blockquote>
</body>
</html>

