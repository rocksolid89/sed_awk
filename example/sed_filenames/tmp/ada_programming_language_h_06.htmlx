<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<title>Адское программирование.</title>
</head>


<body BGCOLOR="FFFFFF">
<basefont size=3>
<blockquote>

<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>



<!--- header --->



<h2><a name="s6">6. Подпрограммы</a></h2>

<p align="JUSTIFY">
В Аде, также как и во всех современных языках программирования,
подпрограммы позволяют программисту группировать инструкции в самостоятельные,
логически законченные алгоритмические единицы,
которые, в последствии, могут быть вызваны и выполнены в любом месте программы.

Они являются элементарным базовым средством для повторного использования кода и
разделения одной большой задачи на самостоятельные подзадачи меньшего размера (декомпозиция).

Использование подпрограмм позволяет уменьшить как общий размер исходных текстов программы,
так и общий размер результирующих исполняемых файлов.

Таким образом, применение подпрограмм облегчает общее управление проектом
и упрощает его сопровождение.


<p align="JUSTIFY">
При этом, подпрограммы Ады обладают
некоторыми свойствами, которые будут новыми для программистов
использующих Паскаль и/или Си.

Совмещение (<i>overloading</i>), именованные параметры, значение параметров по-умолчанию,
режимы передачи параметров и возврата значений -
все это значительно отличает подпрограммы языка Ада.



<p>
<h3><a name="s6.1">6.1 Общие сведения о подпрограммах</a></h3>

<p align="JUSTIFY">
Также как и в Паскале, подпрограммами Ады являются процедуры и функции.

<p align="JUSTIFY">
Подпрограммы могут иметь параметры различных типов или не иметь ни одного параметра.
При описании механизмов передачи параметров, как правило, используются следующие понятия:

<p>
<center><table border=0 width="95%">
<tr>
<td valign="TOP"><font size=1><b><i>формальный параметр</i></b></td>
<td valign="TOP"><font size=1>&nbsp;&nbsp;</td>
<td valign="TOP"><font size=1>Параметр который используется при описании подпрограммы
                 (процедуры или функции).</td>
</tr>

<tr>
<td valign="TOP"><font size=1>&nbsp;&nbsp;</td>
</tr>

<tr>
<td valign="TOP"><font size=1><b><i>фактический параметр</i></b></td>
<td valign="TOP"><font size=1>&nbsp;&nbsp;</td>
<td valign="TOP"><font size=1>Объект, который передается в подпрограмму при вызове подпрограммы.
                 В качестве фактического параметра подпрограммы может
                 быть передано целое выражение, при этом режимом передачи параметра
                 не может быть режим "<tt><b>out</b></tt>".</td>
</tr>

</table></center>


<p align="JUSTIFY">
Каждый формальный параметр подпрограммы имеет имя, тип и режим передачи.



<p align="JUSTIFY">
Подпрограммы могут содержать локальные описания типов, подтипов, переменных, констант,
других подпрограмм и пакетов.

<p align="JUSTIFY">
Подпрограмма Ады, как правило, состоит из двух частей: спецификации и тела.
Спецификация описывает интерфейс обращения к подпрограмме, другими словами -
"что" обеспечивает подпрограмма.

Тело подпрограммы описывает детали реализации алгоритма работы подпрограммы,
то есть, "как" подпрограмма устроена.

<p align="JUSTIFY">
Разделение описания подпрограммы на спецификацию и тело не случайно, и имеет большое значение.

Такой подход позволяет предоставить пользователю подпрограммы только ее спецификацию
и оградить, и даже избавить его от деталей реализации подпрограммы.

<p align="JUSTIFY">
Однажды скомпилированная и сохраненная в атрибутивном файле спецификация
может быть проверена на совместимость с другими подпрограммами (и пакетами) когда
они будут компилироваться.

Таким образом, при проектировании,
мы можем представить только спецификацию подпрограммы и передать ее компилятору.

При предоставлении большого количества фиктивных подпрограмм-заглушек (<i>stubs</i>)
мы можем осуществлять предварительное тестирование проекта всей системы и обнаруживать
любые ошибки проектирования до того как будет потрачено много усилий на реализацию
конкретных решений (идеи данного подхода рассматриваются также при обсуждении концепции пакетов).


<p align="JUSTIFY">
Необходимо заметить, что спецификации подпрограмм, как правило, помещаются
в спецификации пакетов, а тела подпрограмм - в тела пакетов.


<p align="JUSTIFY">
Кроме того, подпрограмма может быть самостоятельным независимым программным модулем.
В этом случае, спецификация и тело подпрограммы помещаются в разные файлы
(в файл спецификации и в файл тела, соответственно).

Следует также заметить, что
помещать спецификацию в отдельный файл,
когда подпрограмма не является самостоятельной единицей компиляции не обязательно.

В этом случае, спецификация подпрограммы может отсутствовать.



<p><h4><a name="s6.1.1">6.1.1 Процедуры</a></h4>

<p align="JUSTIFY">
Процедуры Ады подобны процедурам Паскаля и используются для реализации
самых разнообразных алгоритмов.

<p align="JUSTIFY">
Общий вид описания процедуры выглядит следующим образом:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir>

  <table BGCOLOR="E0E0E0" border=0 width="100%">

  <tr>
  <td><font size=1><pre><b>procedure</b> <i>имя_процедуры</i> [ (<i>формальные_параметры</i>) ] ;</pre></td>
  <td><font size=1>&nbsp;&nbsp;</td>
  <td><font size=1>спецификация процедуры, определяющая имя процедуры и профиль ее формальных параметров (если они есть)</td>
  </tr>

</table>
</dir>

</td></tr></table>

<p align="JUSTIFY">
Общий вид тела процедуры:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir>

  <table BGCOLOR="E0E0E0" border=0 width="100%">

  <tr>
  <td><font size=1><pre><b>procedure</b> <i>имя_процедуры</i> [ (<i>формальные_параметры</i>) ] <b>is</b></pre></td>
  <td><font size=1>&nbsp;&nbsp;</td>
  <td><font size=1>спецификация процедуры, определяющая имя процедуры и профиль ее формальных параметров (если они есть)</td>
  </tr>
<tr><td><font size=1>&nbsp;&nbsp;</td><td><font size=1>&nbsp;&nbsp;</td><td><font size=1>&nbsp;&nbsp;</td></tr>

  <tr>
  <td><font size=1><pre>    . . .</pre></td>
  <td><font size=1>&nbsp;</td>
  <td><font size=1>описательная (или декларативная) часть, которая может содержать локальные описания типов,
  переменных, констант, подпрограмм...</td>
  </tr>
<tr><td><font size=1>&nbsp;&nbsp;</td><td><font size=1>&nbsp;&nbsp;</td><td><font size=1>&nbsp;&nbsp;</td></tr>

  <tr>
  <td><font size=1><pre><b>begin</b> </pre></td>
  <td><font size=1>&nbsp;&nbsp;</td>
  <td><font size=1>&nbsp;</td>
  </tr>

  <tr>
  <td><font size=1><pre>    . . .</pre></td>
  <td><font size=1>&nbsp;&nbsp;</td>
  <td><font size=1>исполняемая часть процедуры, которая описывает алгоритм работы процедуры;<br>
                   обязана содержать хотя бы одну инструкцию</td>
  </tr>
<tr><td><font size=1>&nbsp;&nbsp;</td><td><font size=1>&nbsp;&nbsp;</td><td><font size=1>&nbsp;&nbsp;</td></tr>

  <tr>
  <td><font size=1><pre><b>end</b> [ <i>имя_процедуры</i> ];</td>
  <td><font size=1>&nbsp;&nbsp;</td>
  <td><font size=1>здесь, указание имени процедуры опционально</td>
  </tr>

</table>

</dir>
</td></tr></table>


<p align="JUSTIFY">
Таким образом, описание содержит только спецификацию процедуры и
определяет правила ее вызова (иначе - интерфейс),
а тело содержит спецификацию и последовательность инструкций, которые выполняются
при вызове процедуры.

<p align="JUSTIFY">
Примечательно требование Ады, чтобы исполняемая часть процедуры содержала хотя бы одну инструкцию.
Поэтому, как правило на этапе проектирования, при написании процедур-заглушек используется пустая
инструкция, например:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Demo(X: Integer; Y: Float) <b>is</b>
<b>begin</b>
    <b>null</b>; -- пустая инструкция
<b>end</b> Demo;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Вызов процедуры производится также как и в языке Паскаль, например:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Demo(4, 5.0);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Необходимо также заметить,
что Ада предоставляет программисту возможность, при необходимости,
помещать в любых местах внутри исполнительной части процедуры
инструкцию возврата из процедуры - <tt><b>return</b></tt>.




<p><h4><a name="s6.1.2">6.1.2 Функции</a></h4>

<p align="JUSTIFY">
Функции во многом подобны процедурам, за исключением того, что они возвращают
значение в вызвавшую их подпрограмму.
Также можно сказать, что функция - это подпрограмма которая осуществляет преобразование
одного или нескольких входных значений в одно выходное значение.

<p align="JUSTIFY">
Общий вид описания функции выглядит следующим образом:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>

<dir>

  <table BGCOLOR="E0E0E0" border=0 width="100%">

  <tr>
  <td><font size=1><pre><b>function</b> <i>имя_функции</i> [ (<i>формальные_параметры</i>) ]
    <b>return</b> <i>тип_возвращаемого_значения</i> ;</pre></td>
  <td><font size=1>&nbsp;&nbsp;</td>
  <td><font size=1>спецификация функции, определяющая имя функции,
                   профиль ее формальных параметров (если они есть)
                   и тип возвращаемого значения</td>
  </tr>

</table>
</dir>

</td></tr></table>


<p align="JUSTIFY">
Общий вид тела функции:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir>

  <table BGCOLOR="E0E0E0" border=0 width="100%">

  <tr>
  <td><font size=1><pre><b>function</b> <i>имя_функции</i> [ (<i>формальные_параметры</i>) ]
    <b>return</b> <i>тип_возвращаемого_значения</i> <b>is</b></pre></td>
  <td><font size=1>&nbsp;&nbsp;</td>
  <td><font size=1>спецификация функции, определяющая имя функции,
                   профиль ее формальных параметров (если они есть)
                   и тип возвращаемого значения</td>
  </tr>
<tr><td><font size=1>&nbsp;&nbsp;</td><td><font size=1>&nbsp;&nbsp;</td><td><font size=1>&nbsp;&nbsp;</td></tr>

  <tr>
  <td><font size=1><pre>    . . .</pre></td>
  <td><font size=1>&nbsp;</td>
  <td><font size=1>описательная (или декларативная) часть, которая может содержать локальные описания типов,
  переменных, констант, подпрограмм...</td>
  </tr>
<tr><td><font size=1>&nbsp;&nbsp;</td><td><font size=1>&nbsp;&nbsp;</td><td><font size=1>&nbsp;&nbsp;</td></tr>

  <tr>
  <td><font size=1><pre><b>begin</b> </pre></td>
  <td><font size=1>&nbsp;&nbsp;</td>
  <td><font size=1>&nbsp;</td>
  </tr>

  <tr>
  <td><font size=1><pre>    . . .</pre></td>
  <td><font size=1>&nbsp;&nbsp;</td>
  <td><font size=1>исполнительная часть функции, которая описывает алгоритм работы функции;<br>
                   обязана содержать хотя бы одну инструкцию возврата значения -
                   <tt><b>return</b></tt></td>
  </tr>
<tr><td><font size=1>&nbsp;&nbsp;</td><td><font size=1>&nbsp;&nbsp;</td><td><font size=1>&nbsp;&nbsp;</td></tr>

  <tr>
  <td><font size=1><pre><b>end</b> [ <i>имя функции</i> ];</td>
  <td><font size=1>&nbsp;&nbsp;</td>
  <td><font size=1>здесь, указание имени функции опционально</td>
  </tr>

</table>

</dir>
</td></tr></table>


<p align="JUSTIFY">
Использование инструкции возврата значения - <tt><b>return</b></tt>
очень похоже на то, что используется в языке Си,
при этом, функция может иметь сколько угодно инструкций возврата значения.

<p align="JUSTIFY">
Функция может быть вызвана как часть выражения в инструкции присваивания
или как аргумент соответствующего типа при вызове другой функции или процедуры.
Другими словами - функция, возвращающая
значения заданного типа, может быть использована везде, где может быть использована
переменная этого типа.

<p align="JUSTIFY">
Хотя режимы передачи параметров в подпрограммы будут подробно рассмотрены несколько позже,
здесь, необходимо сделать несколько важных замечаний, которые имеют значение для функций Ады.

<p align="JUSTIFY">
Согласно традиций стандарта Ada83,
для передачи параметров в функцию разрешается использовать только режим "<tt><b>in</b></tt>".

Поэтому, функция, через свои параметры, может только импортировать данные
из среды вызвавшей эту функцию.

При этом, параметры функции не могут быть использованы
для изменения значений переменных в среде вызвавшей функцию.

Таким образом, в отличие от традиций языка Си, функции Ады не обладают
побочными эффектами.

<p align="JUSTIFY">
Стандарт Ada95 ввел новый режим для передачи параметров -
<tt><b>access</b></tt>.

Этот режим разрешается использовать для передачи параметров в функции.

Следует заметить, что использование этого режима допускает написание функций
обладающих побочными эффектами.



<p><h4><a name="s6.1.3">6.1.3 Локальные переменные</a></h4>

<p align="JUSTIFY">
Как уже говорилось, подпрограммы (и процедуры, и функции) могут содержать локальные переменные.
Такие переменные доступны только внутри подпрограммы и не видимы извне этой подпрограммы.
Время жизни (время существования) таких переменных определяется
временем жизни (временем выполнения) подпрограммы.

<p align="JUSTIFY">
Во время работы программы, при входе в подпрограмму, имеющую локальные переменные,
в стеке времени выполнения происходит автоматическое распределение пространства
для локальных переменных данной подпрограммы.

При выходе из подпрограммы пространство стека времени выполнения,
распределенное для локальных переменных данной подпрограммы,
автоматически возвращается системе.






<p><h4><a name="s6.1.4">6.1.4 Локальные подпрограммы</a></h4>

<p align="JUSTIFY">
Также как и Паскаль, и в отличие от Си, Ада позволяет встраивать одни подпрограммы
в другие подпрограммы, конструируя один общий компилируемый модуль.

Другими словами, подпрограмма Ады может содержать внутри себя
вложенные подпрограммы, которые не будут видимы извне этой подпрограммы.



К таким локальным подпрограммам можно обращаться только из подпрограммы которая их
содержит.



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Ada.Text_IO;          <b>use</b> Ada.Text_IO;
<b>with</b> Ada.Integer_Text_IO;  <b>use</b> Ada.Integer_Text_IO;

<b>procedure</b> Ive_Got_A_Procedure <b>is</b>

    X : Integer := 6;
    Y : Integer := 5;

    <b>procedure</b> Display_Values (Number : Integer) <b>is</b>
    <b>begin</b>
        Put (Number);
        New_Line;
    <b>end</b> Display_Values;

<b>begin</b>
    Display_Values (X);
    Display_Values (Y);
<b>end</b> Ive_Got_A_Procedure;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В этом примере область видимости процедуры <tt>Display_Values</tt> ограничивается
процедурой <tt>Ive_Got_A_Procedure</tt>. Таким образом, процедура <tt>Display_Values</tt>
"не видна" и не может быть вызвана из любого другого места.




<p><h4><a name="s6.1.5">6.1.5 Раздельная компиляция</a></h3>

<p align="JUSTIFY">
В предыдущем примере, если будет произведено какое-нибудь изменение кода, то
обе процедуры должны быть переданы компилятору (поскольку обе находятся в одном
файле с исходным текстом).

Мы можем разделить эти две компоненты, и поместить их в отдельные файлы,
оставляя без изменения ограничения области видимости для процедуры <tt>Display_Values</tt>.

Это несколько похоже на директиву <tt>#include</tt>, используемую в языке Си,
но, в языке Ада, теперь оба файла становятся независимыми компилируемыми модулями.

<p align="JUSTIFY">
В первом файле:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Ada.Text_IO;         <b>use</b> Ada.Text_IO;
<b>with</b> Ada.Integer_Text_IO; <b>use</b> Ada.Integer_Text_IO;

<b>procedure</b> Ive_Got_A_Procedure <b>is</b> 

    X : Integer := 6;
    Y : Integer := 5;

    <b>procedure</b> Display_Values(Number : Integer) <b>is separate</b>;

<b>begin</b>
    Display_Values(X);
    Display_Values(Y);
<b>end</b> Ive_Got_A_Procedure;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Во втором файле:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>separate</b>(Ive_Got_A_Procedure)  -- <u>примечание!</u> нет завершайщего символа
                               -- точки с запятой

<b>procedure</b> Display_Values(Number : Integer) <b>is</b>
<b>begin</b>
    Put(Number);
    New_Line;
<b>end</b> Display_Values;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Выделенный в самостоятельный файл (и ставший отдельно компилируемым модулем),
код - идентичен тому, что было в предыдущей версии. Однако теперь, если
будет изменена только внутренняя подпрограмма, то только она должна быть подвергнута
перекомпиляции компилятором. Это также позволяет разделить программу на
несколько частей, что может облегчить ее понимание.




<p><h4><a name="s6.1.6">6.1.6 Подпрограммы как библиотечные модули</a></h3>

<p align="JUSTIFY">
Любая подпрограмма Ады, при необходимости, может быть оформлена как абсолютно
самостоятельный независимый библиотечный подпрограммный модуль.

<p align="JUSTIFY">
Рассмотрим как это делается на примере процедур
<tt>Ive_Got_A_Procedure</tt> и <tt>Display_Values</tt>,
из предыдущего примера о раздельной компиляции.

Теперь, процедура <tt>Display_Values</tt> будет оформлена как самостоятельный
библиотечный подпрограммный модуль, а процедура <tt>Ive_Got_A_Procedure</tt>
будет ее использовать.

<p align="JUSTIFY">
В этом случае, полное описание процедуры <tt>Display_Values</tt>
будет состоять из двух файлов: файла спецификации и файла тела процедуры.

<dir>
<p align="JUSTIFY">
<b>Примечание:</b><br>
В системе компилятора <i>GNAT</i> существует соглашение согласно которому
файлы спецификаций имеют расширение <tt>ads</tt> (<i>ADa Specification</i>),
а файлы тел имеют расширение <tt>adb</tt> (<i>ADa Body</i>).

</dir>

<p align="JUSTIFY">
Файл спецификации процедуры <tt>Display_Values</tt> (<tt>display_values.ads</tt>) будет
иметь следующий вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Display_Values(Number : Integer);
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Файл тела процедуры <tt>Display_Values</tt> (<tt>display_values.adb</tt>) будет
иметь следующий вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Ada.Text_IO;         <b>use</b> Ada.Text_IO;
<b>with</b> Ada.Integer_Text_IO; <b>use</b> Ada.Integer_Text_IO;

<b>procedure</b> Display_Values(Number : Integer) <b>is</b>
<b>begin</b>
    Put(Number);
    New_Line;
<b>end</b> Display_Values;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Третий файл - это файл тела процедуры <tt>Ive_Got_A_Procedure</tt> (<tt>ive_got_a_procedure.adb</tt>).
В этом случае он будет иметь следующий вид:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Ada.Text_IO;         <b>use</b> Ada.Text_IO;
<b>with</b> Ada.Integer_Text_IO; <b>use</b> Ada.Integer_Text_IO;
<b>with</b> Display_Values;

<b>procedure</b> Ive_Got_A_Procedure <b>is</b> 

    X : Integer := 6;
    Y : Integer := 5;

<b>begin</b>
    Display_Values(X);
    Display_Values(Y);
<b>end</b> Ive_Got_A_Procedure;
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Примечательно, что теперь, в файле тела процедуры <tt>Ive_Got_A_Procedure</tt>,
процедуру <tt>Display_Values</tt>, которая оформлена как самостоятельный библиотечный модуль,
необходимо указать в спецификаторе совместности контекста <tt><b>with</b></tt>.

<p align="JUSTIFY">
Также, необходимо заметить, что подпрограммы, оформленные как самостоятельные библиотечные модули,
не указываются в спецификаторе использования контекста <tt><b>use</b></tt>.




<p>
<h3><a name="s6.2">6.2 Режимы передачи параметров</a></h3>

<p align="JUSTIFY">
Стандарт Ada83 предусматривал три режима передачи параметров для подпрограмм:
<dir>
  "<tt><b>in</b></tt>"<br>
  "<tt><b>in out</b></tt>"<br>
  "<tt><b>out</b></tt>"<br>
</dir>

<p align="JUSTIFY">
Стандарт Ada95 добавил еще один режим передачи параметров:
<dir>
  <tt><b>access</b></tt><br>
</dir>

<p align="JUSTIFY">
Все эти режимы не имеют непосредственных аналогов в других языках программирования.

Необходимо также отметить следующее:
<dir><p align="JUSTIFY">
  по-умолчанию, для передачи параметров подпрограммы, всегда устанавливается режим - 
  "<tt><b>in</b></tt>" !!!
</dir>

<p align="JUSTIFY">
Для "<tt><b>in</b></tt>" / "<tt><b>out</b></tt>" скалярных значений используется
механизм передачи параметров
по копированию-"<tt><b>in</b></tt>" (<i>copy-in</i>),
по копированию-"<tt><b>out</b></tt>" (<i>copy-out</i>).

Стандарт специфицирует, что любые другие типы могут быть переданы
по <i>copy-in</i>/<i>copy-out</i>, или по ссылке.

<p align="JUSTIFY">
Ada95 указывает, что лимитированные приватные типы (<i>limited private types</i>),
которые рассматриваются позднее, передаются по ссылке, для предотвращения проблем
нарушения приватности.



<p><h4><a name="s6.2.1">6.2.1 Режим "<tt><b>in</b></tt>"</a></h4>

<p align="JUSTIFY">
Параметры передаваемые в этом режиме подобны параметрам передаваемым по значению
в языке Паскаль, и обычным параметрам языка Си, с тем исключением, что им не могут
присваиваться значания внутри подпрограммы.

<p align="JUSTIFY">
Это значит, что при входе в подпрограмму, формальный параметр инициализируется значением
фактического параметра,
при этом, внутри подпрограммы, он является константой и разрешает только чтение значения
ассоциированного фактического параметра.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Ada.Integer_Text_IO; <b>use</b> Ada.Integer_Text_IO;

<b>procedure</b> Demo(X : <b>in</b> Integer; Y : <b>in</b> Integer) <b>is</b>
<b>begin</b>
    X := 5;   -- недопустимо, <i>in</i> параметр доступен только по чтению
    Put(Y);
    Get(Y);   -- также недопустимо
<b>end</b> Demo;
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Режим "<tt><b>in</b></tt>" разрешается использовать и в процедурах, и в функциях.


<p><h4><a name="s6.2.2">6.2.2 Режим "<tt><b>in out</b></tt>"</a></h4>

<p align="JUSTIFY">
Этот режим непосредственно соответствует параметрам передаваемым по ссылке
(подобно <i>var</i>-параметрам языка Паскаль). 

<p align="JUSTIFY">
Таким образом, при входе в подпрограмму, формальный параметр инициализируется значением
фактического параметра.

Внутри подпрограммы, формальный параметр, использующий этот режим, может быть использован
как в левой, так и в правой части инструкций присваивания
(другими словами: формальный параметр доступен как для чтения, так и для записи).

При этом, если формальному параметру внутри подпрограммы
произведено присваивание нового значения,
то после выхода из подпрограммы значение фактического параметра
заменяется на новое значение формального параметра.



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Demo(X : <b>in out</b> Integer;
               Y : <b>in</b>     Integer) <b>is</b>

    Z : <b>constant</b> Integer := X;

<b>begin</b>
    X := Y * Z; -- это допустимо!
<b>end</b> Demo;
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Режим "<tt><b>in out</b></tt>" разрешается использовать только в процедурах.






<p><h4><a name="s6.2.3">6.2.3 Режим "<tt><b>out</b></tt>"</a></h4>

<p align="JUSTIFY">
В этом режиме, при входе в подпрограмму, формальный параметр
<b>не</b> инициализируется (<b>!!!</b>) значением фактического параметра.

Согласно стандарта Ada95, внутри подпрограммы, формальный параметр,
использующий этот режим, может быть использован
как в левой, так и в правой части инструкций присваивания
(другими словами: формальный параметр доступен как для чтения, так и для записи).
<!---
(доступ по <i>read/write</i>).
--->
Согласно стандарта Ada83, внутри подпрограммы, такой формальный параметр
может быть использован только в левой части инструкций присваивания
(другими словами: доступен только для записи).

При этом, после выхода из подпрограммы, значение фактического параметра
заменяется на значение формального параметра.





<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Demo(X : <b>out</b> Integer;
               Y : <b>in</b> Integer) <b>is</b>

    -- при входе в подпрограмму X не инициализирован!!!

<b>begin</b>
    X := Y;
<b>end</b> Demo;
</pre></dir>
</td></tr></table>




<p align="JUSTIFY">
Режим "<tt><b>out</b></tt>" разрешается использовать только в процедурах.



<p><h4><a name="s6.2.4">6.2.4 Режим <tt><b>access</b></tt></a></h4>

<p align="JUSTIFY">
Поскольку значения ссылочного типа (указатели)
часто используются в качестве параметров передаваемых подпрограммам,
Ада предусматривает режим передачи параметров <tt><b>access</b></tt>,
который специально предназначен для передачи параметров ссылочного типа.

Заметим, что подробному обсуждению ссылочных типов Ады далее посвящена самостоятельная глава -
<i>"Ссылочные типы (указатели)"</i>.

Необходимо также обратить внимание на то, что режим передачи параметров <tt><b>access</b></tt>
был введен стандартом Ada95 и он отсутствует в стандарте Ada83.




<p align="JUSTIFY">
При использовании режима <tt><b>access</b></tt>,
фактический параметр, который предоставляется при вызове подпрограммы, - это
любое значение ссылочного типа, которое ссылается (указывает) на объект соответствующего типа.

При входе в подпрограмму, формальный параметр инициализируется значением фактического параметра,
при этом, Ада производит автоматическую проверку того, что значение параметра не равно
<tt><b>null</b></tt>.

В случае когда значение параметра равно <tt><b>null</b></tt>
генерируется исключительная ситуация <i>Constraint_Error</i>
(проще говоря, - ошибка).

Внутри подпрограммы, формальный параметр, использующий режим <tt><b>access</b></tt>,
является константой ссылочного типа и ему нельзя присваивать новое значение,
поэтому такие формальные параметры несколько подобны формальным параметрам,
использующим режим "<tt><b>in</b></tt>".

Однако, поскольку параметр является значением ссылочного типа (указателем),
то подпрограмма может изменить содержимое объекта на который данный
параметр ссылается (указывает).

Кроме того, внутри подпрограммы такой параметр принадлежит анонимному ссылочному типу,
и поскольку у нас нет возможности определить имя этого ссылочного типа,
то мы не можем описать ни одного дополнительного объекта этого типа.

Любая попытка конвертирования значения такого параметра в значение именованого ссылочного типа
будет проверяться на соответствие правилам области действия для ссылочных типов.
При обнаружении нарушения этих правил генерируется исключительная ситуация
<i>Programm_Error</i>.




<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

    . . .

<b>function</b> Demo_Access(A : <b>access</b> Integer) <b>return</b> Integer <b>is</b>
<b>begin</b>
    <b>return</b> A.<b>all</b>;
<b>end</b> Demo_Access;

    . . .

<b>type</b>  Integer_Access  <b>is access</b> Integer;

Integer_Access_Var  : Integer_Access := <b>new</b> Integer<b>'<i>(1)</i></b>;
Aliased_Integer_Var : <b>aliased</b> Integer;

    . . .

X : Integer := Demo_Access(Integer_Access_Var);
Y : Integer := Demo_Access(Aliased_Integer_Var<b>'<i>Access</i></b>);
Z : Integer := Demo_Access(<b>new</b> Integer);

    . . .
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Режим <tt><b>access</b></tt> разрешается использовать и в процедурах, и в функциях.

<p align="JUSTIFY">
При этом необходимо обратить внимание на то, что функции, использующие
этот режим для передачи параметров, способны изменять состояние объектов
на которые такие параметры ссылаются.

То есть, такие функции могут обладать побочными эффектами.



<p>
<h3><a name="s6.3">6.3 Сопоставление формальных и фактических параметров</a></h3>


<p><h4><a name="s6.3.1">6.3.1 Позиционное сопоставление</a></h4>

<p align="JUSTIFY">
Позиционное сопоставление формальных и фактических параметров при вызове подпрограммы
достаточно традиционно, и используется во многих языках программирования.

При таком сопоставлении, ассоциирование между формальными и фактическими параметрами
производится один к одному позиционно, т.е. первый формальный параметр ассоциируется
с первым фактическим параметром и т.д.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Demo(X : Integer; Y : Integer);  -- спецификация процедуры

  . . .

Demo(1, 2);
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
В этом случае,
фактический параметр <tt>1</tt> будет подставлен вместо первого формального параметра <tt>X</tt>, а
фактический параметр <tt>2</tt> будет подставлен вместо второго формального параметра <tt>Y</tt>.




<p><h4><a name="s6.3.2">6.3.2 Именованное сопоставление</a></h4>

<p align="JUSTIFY">
Для улучшения читабельности вызовов подпрограмм (а Ада разрабатывалась с учетом хорошей читабельности)
Ада позволяет использовать именованное сопоставление формальных и фактических параметров.
В этом случае мы можем ассоциировать имя формального параметра с фактическим параметром.
Это свойство делает вызовы подпрограмм более читабельными.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Demo(X : Integer; Y : Integer);  -- спецификация процедуры

  . . .

Demo(X =&gt; 5, Y =&gt; 3 * 45);   -- именованное сопоставление
                             -- формальных и фактических
                             -- параметров при вызове
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Расположение списка параметров вертикально, также способствует улучшению
читабельности.

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Demo(X =&gt; 5,
     Y =&gt; 3 * 45);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Поскольку при именованом сопоставлении производится явное ассоциирование
между формальными и фактическими параметрами
(вместо неявного ассоциирования, используемого в случае позиционного сопоставления),
то нет необходимости строго придерживаться того же самого порядка следования параметров,
который указан в спецификации подпрограммы.

<!---
То есть, при именованом сопоставлении отсутствуют жесткие требования
к порядку следования параметров.
--->


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Demo(Y =&gt; 3 * 45,    -- при именованом сопоставлении
     X =&gt; 5);        -- порядок следования параметров
                     -- не имеет значения
</pre></dir>
</td></tr></table>



<p><h4><a name="s6.3.3">6.3.3 Смешивание позиционного и именованного сопоставления</a></h4>

<p align="JUSTIFY">
Ада позволяет смешивать позиционное и именованное сопоставление параметров.

В этом случае должно соблюдаться следующее условие:
позиционно-ассоциированные параметры должны предшествовать параметрам,
которые ассоциируются по имени.



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Square(Result :    <b>out</b> Integer;
                 Number : <b>in</b>     Integer) <b>is</b>
<b>begin</b>
    Result := Number * Number;
<b>end</b> Square;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В результате, показанная выше процедура <tt>Square</tt> может быть вызвана следующими способами:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Square(X, 4);
Square(X, Number =&gt; 4);
Square(Result =&gt; X, Number =&gt; 4);
Square(Number =&gt; 4, Result =&gt; x);

Square(Number =&gt; 4, X);  -- недопустимо, поскольку позиционно-ассоциируемый
                         -- параметр следует за параметром, ассоциируемым
                         -- по имени
</pre></dir>
</td></tr></table>




<p>
<h3><a name="s6.4">6.4 Указание значения параметра по-умолчанию</a></h3>

<p align="JUSTIFY">
Для любых "<tt><b>in</b></tt>"-параметров ("<tt><b>in</b></tt>" или "<tt><b>in out</b></tt>"),
в спецификации подпрограммы можно указать значение параметра по-умолчанию.

Синтаксис установки значения параметра по-умолчанию подобен синтаксису определения
инициализированных переменных и имеет следующий вид:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Ada.Text_IO;        <b>use</b> Ada.Text_IO;

<b>procedure</b> Print_Lines(No_Of_Lines: Integer := 1) <b>is</b>

<b>begin</b>
    <b>for</b> Count <b>in</b> 1 .. No_Of_Lines <b>loop</b>
        New_Line;
    <b>end loop</b>;
<b>end</b> Print_Lines;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Такое описание устанавливает значение параметра <tt>No_Of_Lines</tt>
для случаев когда процедура <tt>Print_Lines</tt>
вызывается без указания значения этого параметра
(позиционного или именованного).


<p align="JUSTIFY">
Таким образом, вызов этой процедуры может иметь вид:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Print_Lines;        -- это печатает одну строку
Print_Lines(6);     -- переопределяет значение параметра
                    -- установленное по-умолчанию
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Подобно этому, если процедура <tt>Write_Lines</tt> была описана как:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Ada.Text_IO;        <b>use</b> Ada.Text_IO;

<b>procedure</b> Write_Lines(Letter      : <b>in</b> Char := '*';
                      No_Of_Lines : <b>in</b> Integer := 1) <b>is</b>

<b>begin</b>
    <b>for</b> I <b>in</b> 1 .. No_Of_Lines <b>loop</b>
        <b>for</b> I <b>in</b> 1 .. 80 <b>loop</b>
            Put(Letter);
        <b>end loop</b>;
        New_Line;
    <b>end loop</b>;
<b>end</b> Write_Lines;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
то она может быть вызвана следующими способами:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Write_Lines;                     -- для параметров <i>Letter</i> и <i>No_Of_Lines</i>
                                 -- используются значения устанавливаемые
                                 -- по-умолчанию
Write_Lines('-');                -- значение по-умолчанию - для <i>No_Of_Lines</i>
Write_Lines(no_of_lines =&gt; 5);   -- значение по-умолчанию - для <i>Letter</i>
Write_Lines('-', 5)              -- оба параметра определены
</pre></dir>
</td></tr></table>


<p>
<h3><a name="s6.5">6.5 Совмещение (<i>overloading</i>)</a></h3>

<p align="JUSTIFY">
Поиск новых имен для подпрограмм, которые выполняют одинаковые действия, но с переменными
разных типов, всегда является большой проблемой при разработке программного обеспечения.

Хорошим примером для иллюстрации такой проблемы является процедура <tt>Insert</tt>.

<p align="JUSTIFY">
В подобных случаях, для облегчения жизни программистам,
Ада позволяет разным подпрограммам иметь одинаковые имена,
предоставляя механизм который называется совмещением (<i>overloading</i>).

<!---
При этом, Ада выдвигает единственное требование: такие подпрограммы должны быть распознаваемы.

<p align="JUSTIFY">
Механизм который позволяет разным подпрограммам выполнять одинаковые действия
над переменными разных типов и при этом иметь одинаковые имена
называется совмещением (<i>overloading</i>).
--->



<p>
<h4><a name="s6.5.1">6.5.1 Совмещение подпрограмм (<i>subprogram overloading</i>)</a></h4>

<p align="JUSTIFY">
Предоставляя механизм совмещения имен подпрограмм, Ада выдвигает единственное требование:
подпрограммы должны быть распознаваемы (или различимы).

Две подпрограммы, имеющие одинаковые имена, будут распознаваемы если они имеют
разный "профиль".

Профиль подпрограммы характеризуется количеством параметров и их типами,
а также, если подпрограмма является функцией, - типом возвращаемого значения.


<p align="JUSTIFY">
Таким образом, пока компилятор может однозначно определить к какой подпрограмме
осуществляется вызов, анализируя совпадение профиля вызываемой подпрограммы
со спецификациями представленных подпрограмм, - все будет в порядке.

В противном случае, вы получите сообщение об ошибке, указывающее на двусмысленность обращения.

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Insert(Item : Integer);  -- две процедуры с одинаковыми именами,
<b>procedure</b> Insert(Item : Float);    -- но имеющие разный "профиль"
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Примерами совмещенных подпрограмм могут служить процедуры <tt>Put</tt> и <tt>Get</tt> из
стандартного пакета <i>Ada.Text_IO</i>.




<p>
<h4><a name="s6.5.2">6.5.2 Совмещение знаков операций (<i>operator overloading</i>)</a></h4>

<p align="JUSTIFY">
В языках подобных Паскалю знак операции "+" - совмещен.

Действительно, он может использоваться для сложения целых и вещественных чисел, и даже строк.

Таким образом, очевидно что этот знак операции используется для представления кода
который выполняет абсолютно разные действия.

<p align="JUSTIFY">
Ада разрешает программистам выполнять совмещение предопределенных знаков операций
с их собственным кодом.

Следует заметить, в Аде, действие выполняемое знаком операции, реализуется
путем вызова функции именем которой является знак операции заключенный
в двойные кавычки.

При этом, для обеспечения корректной работы механизма совмещения знаков операций,
функция, которая реализует действие знака операции,
должна соответствовать обычному требованию механизма совмещения подпрограмм Ады:
она должна быть различима, то есть, ее профиль должен быть уникальным.

В некоторых случаях, проблему двусмысленности знака операции можно
преодолеть непосредственно специфицируя имя пакета (рассматривается далее).

<p align="JUSTIFY">
Кроме того, к функциям которые реализуют действия знаков операций предъявляется
дополнительное требование: они не могут быть выделены в самостоятельно компилируемые модули,
а должны содержаться в другом модуле, таком как процедура, функция или пакет.

<p align="JUSTIFY">
Рассмотрим простой пример в котором мы хотим предусмотреть возможность сложения двух векторов:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Add_Demo <b>is</b>

    <b>type</b> Vector <b>is array</b> (Positive <b>range</b> &lt;&gt;) <b>of</b> Integer;
    A : Vector(1..5);
    B : Vector(1..5);
    C : Vector(1..5);

    <b>function</b> "+"(Left, Right : Vector) <b>return</b> Vector <b>is</b>

        Result   : Vector(Left<b>'<i>First</i></b>..Left<b>'<i>Last</i></b>);
        Offset   : constant Natural := Right<b>'<i>First</i></b> - 1;

    <b>begin</b>
        <b>if</b> Left<b>'<i>Length</i></b> /= Right<b>'<i>Length</i></b> <b>then</b>
            <b>raise</b> Program_Error;        -- исключение,
                                        -- рассматриваются позже
        <b>end if</b>;

        <b>for</b> I <b>in</b> Left<b>'<i>Range</i></b> <b>loop</b>
            Result(I) := Left(I) + Right(I - Offset);
        <b>end loop</b>;
        <b>return</b> Result;
    <b>end</b> "+";

<b>begin</b>
    A := (1, 2, 3, 4, 5);
    B := (1, 2, 3, 4, 5);
    C := A + B;
<b>end</b> Add_Demo;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В этом примере хорошо продемонстрированы многие ранее рассмотренные средства
которые характерны для языка программирования Ада.


<!---
В этом примере хорошо продемонстрированы многие характерные свойства и особенности Ады
которые уже обсуждались.
--->




<p>
<h4><a name="s6.5.3">6.5.3 Спецификатор "<tt><b>use type</b></tt>"</a></h4>


<p align="JUSTIFY">
В случае когда какой-либо пакет содержит описания знаков операций,
может быть использована несколько модифицированная форма
спецификатора использования <tt><b>use</b></tt>,
которая позволяет использовать описанные в этом пакете знаки операций
без необходимости указания имени пакета в качестве префикса.

При этом, в случае использования других компонентов, описанных в этом пакете,
необходимость указания имени пакета в качестве префикса сохраняется.

<!---
<p align="JUSTIFY">
--->

Эта модифицированная форма спецификатора использования имеет следующий вид:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>use type</b>  <i>имя_типа</i>
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Здесь, <tt><i>имя_типа</i></tt> указывает тип данных для которого знаки операций
будут использоваться без указания имени пакета в качестве префикса.


<!---
          добавить какой-нить примерчик
--->









<!--- footer --->




<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>




</blockquote>
</body>
</html>

