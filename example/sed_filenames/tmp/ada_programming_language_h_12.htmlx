<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<title>Адское программирование.</title>
</head>


<body BGCOLOR="FFFFFF">
<basefont size=3>
<blockquote>

<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>



<!--- header --->



<h2><a name="s12">12. Ссылочные типы (указатели)</a></h2>

<p align="JUSTIFY">
До настоящего момента мы предполагали, что структуры данных и их размещение в пространстве памяти
строго фиксировано и не изменно, то есть статично.

Поэтому, такие данные, как правило, называют статическими.

При этом, следует заметить, что доступ к статическим данным
всегда осуществляется непосредственно к месту их физического размещения в памяти,
то есть, используется механизм непосредственного доступа к данным.


<p align="JUSTIFY">
Для повышения эффективности в современных системах сбора и обработки информации
часто требуется использование данных структура которых может изменяться
в процессе работы программы (списки, деревья, графы...).

Такие данные, как правило, называют динамическими данными или данными с динамической структурой.

Для того, чтобы обеспечить эффективную работу с динамическими данными
механизм непосредственного доступа как правило не приемлем.

Для этого необходим механизм при котором
доступ к реальным данным осуществляется через адресные значения,
определяющие расположение реальных данных в пространстве памяти,
и предоставляется возможность манипулирования
такими адресными значениями.

Такой механизм доступа к данным называют механизмом косвенного доступа.


<p align="JUSTIFY">
Многие современные языки программирования, в качестве механизма косвенного доступа к данным,
используют указатели, которые позволяют манипулировать адресами
размещаемых в пространстве памяти объектов.

Не смотря на то, что указатели являются достаточно эффективным средством работы
с динамическими данными, непосредственная работа с адресами и адресной арифметикой
часто является источником ошибок которые трудно обнаружить.

Известным обладателем подобной проблемы является семейство языков C/C++.


<p align="JUSTIFY">
В качестве механизма косвенного доступа к данным, Ада предлагает концепцию ссылочных типов,
использование которых во многом подобно традиционному использованию указателей.

При этом ссылочные типы Ады обладают следующими характерными особенностями:


<ul>
<li><p align="JUSTIFY">
Ссылочные типы не могут быть использованы для доступа к произвольному адресу памяти.

<li><p align="JUSTIFY">
Значения ссылочного типа не рассматриваются как целочисленные зачения,
а значит, они не поддерживают адресную арифметику.

<li><p align="JUSTIFY">
Значения ссылочного типа могут ссылаться только на значения того типа,
который был указан при описании ссылочного типа.
</ul>


<p align="JUSTIFY">
Из этого следует, что использование ссылочных типов Ады более безопасно
и повышает общую надежность создаваемого программного обеспечения.

<p align="JUSTIFY">
Примечательно, что в литературе не редко встречаются случаи
когда официальная терминология нарушается
и ссылочные типы Ады называют указателями.

Как правило, это делается с целью обеспечить более традиционное изложение материала.


<p align="JUSTIFY">
Все описания ссылочных типов Ады можно условно разделить на три вида:

<ul>
<li>ссылочные типы для динамической памяти
<li>обобщенные ссылочные типы
<li>ссылочные типы для подпрограмм
</ul>

<p align="JUSTIFY">
При этом, следует заметить, что последние два вида введены стандартом Ada-95.




<h3><a name="s12.1">12.1 Ссылочные типы для динамической памяти</a></h3>



<p align="JUSTIFY">
Ссылочные типы для динамической памяти известны со времен стандарта Ada-83
и благополучно поддерживаются в стандарте Ada-95.

Они могут быть использованы для ссылок на объекты размещаемые
в области динамической памяти, которую также часто называют
пулом динамической памяти или кучей.



<p><h4><a name="s12.1.1">12.1.1 Элементарные сведения: описание, создание, инициализация</a></h4>



<p align="JUSTIFY">
Предположим, что у нас есть следующие описания:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Person_Name <b>is new</b> String (1 .. 4);
<b>type</b> Person_Age <b>is</b> Integer <b>range</b> 1 .. 150;

<b>type</b> Person <b>is</b>
    <b>record</b>
        Name : Person_Name;
        Age  : Person_Age;
    <b>end record</b>;
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Предположим также, что нам необходимо разместить экземпляр объекта типа <tt>Person</tt>
в области динамической памяти.

Для этого нам надо описать ссылочный тип, значения которого будут ссылаться на
значения (объекты) типа <tt>Person</tt> и переменную этого ссылочного типа
(заметим, что все ссылочные типы Ады описываются с помощью использования зарезервированного
слова <tt><b>access</b></tt>):

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Person_Ptr <b>is access</b> Person; -- описание ссылочного типа
Someone : Person_Ptr;             -- переменная (объект) ссылочного типа
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Для индикации того, что переменная ссылочного типа (указатель) не указывает ни на один объект,
Ада использует специальное значение <tt><b>null</b></tt>
(это подобно тому, что используется в языке Паскаль).

По умолчанию, объект ссылочного типа всегда инициализируется в <tt><b>null</b></tt>.

Таким образом, после приведенных выше описаний, переменная <tt>Someone</tt>
имеет значение <tt><b>null</b></tt>.

<p align="JUSTIFY">
Теперь, чтобы создать объект типа <tt>Person</tt> в области динамической памяти
и присвоить соответствующее ссылочное значение переменной <tt>Someone</tt>
необходимо выполнить следующее:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Someone := <b>new</b> Person;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Примечательно, что созданный таким образом в области динамической памяти
объект типа <tt>Person</tt> - никак не инициализирован.

Таким образом производится простое распределение пространства,
которое необходимо для размещения объекта типа <tt>Person</tt>,
в области динамической памяти.

<p align="JUSTIFY">
После создания объекта в области динамической памяти,
мы можем проинициализировать индивидуальные поля записи типа <tt>Person</tt>,
на которую ссылается переменная <tt>Someone</tt>, следующим образом:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Someone.Name := "Fred";
Someone.Age  := 33;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Следует заметить, что при таком обращении к объекту в динамической области памяти
производится неявная расшифровка ссылки, а внешний вид кода подобен тому, что
используется при обращении к статическому объекту.

<p align="JUSTIFY">
Для того, чтобы обратиться ко всему содержимому объекта,
на который указывает значение ссылочного объекта (указателя),
Ада использует зарезервированное слово <tt><b>all</b></tt>.

Кроме того, в подобных случаях,
используются квалифицированные (указывающие имя типа) агрегаты:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Someone.<b>all</b> := Person'("Fred", 33);        -- вариант с позиционным агрегатом

Someone.<b>all</b> := Person'( Name =&gt; "Fred";    -- вариант с именованным агрегатом
                        Age  =&gt; 33      );
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Оба варианта, показанные в примере, выполняют абсолютно одинаковые действия,
и их результат ничем не отличается от показанного ранее примера инициализации
путем обращения к индивидуальным полям записи типа <tt>Person</tt>.

Однако, стоит обратить внимание на то, что
использование агрегатов для инициализации всего объекта сразу - более удобно,
а вариант с именованным агрегатом имеет лучшую читабельность
(по сравнению с позиционным агрегатом),
а это важно при работе со сложными структурами данных.



<p align="JUSTIFY">
Ада позволяет одновременно создавать объект в динамической области памяти
и выполнять его инициализацию требуемыми значениями.

Например, вместо выполненных ранее раздельно создания и инициализации,
мы можем использовать следующее:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Someone := <b>new</b> Person'("Fred", 33);        -- вариант с позиционным агрегатом

Someone := <b>new</b> Person'( Name =&gt; "Fred";    -- вариант с именованным агрегатом
                        Age  =&gt; 33      );
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Чтобы облегчить понимание синтаксиса,
который используется в языке Ада при работе со ссылочными типами,
для тех кто знаком с такими языками программирования как Си и Паскаль,
предлагается следующая сравнительная таблица:

<p>
<center><table border=0 width="75%"><tr><th><font size=1>
Таблица сравнения синтаксиса указателей/ссылочных типов<br>
в языках Паскаль, Си и Ада:
<br>

<table border=1 width="100%">
<tr>
<th><font size=1>&nbsp;</th>
<th align=center><font size=1>Паскаль</th>
<th align=center><font size=1>C</th>
<th align=center><font size=1>Ада</th>
</tr>
<tr>
<td align=center><font size=1>Доступ к полям указываемого<br>объекта</td>
<td align=center><font size=1><tt>a^.fieldname</tt></td>
<td align=center><font size=1><tt>*a.fieldname</tt><br><tt>a-&gt;fieldname</tt></td>
<td align=center><font size=1><tt>a.fieldname</tt></td>
</tr>
<tr>
<td align=center><font size=1>Копирование указателя</td>
<td align=center><font size=1><tt>b := a;</tt></td>
<td align=center><font size=1><tt>b = a;</tt></td>
<td align=center><font size=1><tt>b := a;</tt></td>
</tr>
<tr>
<td align=center><font size=1>Копирование указываемого<br>обекта</td>
<td align=center><font size=1><tt>b^ := a^;</tt></td>
<td align=center><font size=1><tt>*b = *a;</tt></td>
<td align=center><font size=1><tt>b.<b>all</b> := a.<b>all</b></tt></td>
</tr>
</table>

</th></tr></table></center>



<p><h4><a name="s12.1.2">12.1.2 Структуры данных со ссылками на себя</a></h4>


<p align="JUSTIFY">
В предыдущих примерах мы рассмотрели то как размещать обычные типы данных
в динамической области памяти и выполнять их инициализацию.

Однако, для того чтобы строить сложные динамические структуры данных
(списки, деревья, графы...) необходима возможность описания структур
данных которые могут ссылаться сами на себя, то есть
требуется создание ссылки на структуру данных, которая еще не существует (не описана).



<p align="JUSTIFY">
Ада позволяет решить подобную проблему осуществляя неполное описание типа.

При неполном описании просто указывается имя типа, который еще не описан.

После этого компилятор ожидает, что полное
описание типа будет дано до завершения файла с исходным текстом:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Element;                 -- неполное описание типа

<b>type</b> Element_Ptr <b>is access</b> Element;

<b>type</b> Element <b>is</b>               -- полное описание типа
    <b>record</b>
        Value : Integer;
        Next  : Element_Ptr;
    <b>end record</b>;

Head_Element : Element_Ptr;   -- переменная которая будет началом списка
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Теперь мы можем построить простой связанный список,
началом которого будет переменная <tt>Head_Element</tt>, следующим образом:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Head_Element := <b>new</b> Element'(
                      Value =&gt; 1, 
                      Next  =&gt; (<b>new</b> Element'(
                                      Value =&gt; 2, 
                                      Next  =&gt; (<b>new</b> Element'(
                                                      Value =&gt; 3, 
                                                      Next  =&gt; <b>null</b>)))));
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Данный список содержит всего три элемента (узла). 

Следует обратить внимание на то, что в последнем элементе списка ссылка <tt>Next</tt>
имеет значение <tt><b>null</b></tt>.



<p><h4><a name="s12.1.3">12.1.3 Освобождение пространства динамической памяти</a></h4>


<p align="JUSTIFY">
После того как мы рассмотрели как распределять пространство динамической памяти
и выполнять инициализацию объектов, осталось рассмотреть как осуществляется
освобождение более не используемого пространства динамической памяти.

<p align="JUSTIFY">
Существует два способа освобождения пространства,
которое было распределено в области динамической памяти,
для его последующего повторного использования:

<ul>
<li><p align="JUSTIFY">
библиотека времени выполнения выполняет неявное освобождение распределеного пространства
когда использованый для распределения пространства динамической памяти тип
выходит из области видимости
<p align="JUSTIFY">
<i>Для этого случая примечательно то, что если тип описан на уровне библиотеки,
то освобождение памяти не произойдет вплоть до завершения работы программы.</i>
<p align="JUSTIFY">
<li><p align="JUSTIFY">
выполнение явного освобождения пространства динамической памяти
в программе
</ul>


<p align="JUSTIFY">
Следует заметить, что стандарт языка Ада не определяет более четких требований и правил
для алгоритмов библиотеки времени выполнения.

Поэтому, реальные алгоритмы будут определяться
реализацией конкретного компилятора и его библиотек поддержки.

Следовательно, для уточнения этих сведений необходимо обратиться
к документации на используемый компилятор, и здесь этот способ
рассматриваться не будет.



<p align="JUSTIFY">
Если вам необходимо освободить память
(подобно тому как это делает системный вызов <tt>free</tt> в UNIX),
то вы можете конкретизировать настраиваемую процедуру <tt>Ada.Unchecked_Deallocation</tt>.

Эта процедура называется непроверяемой (<i>unchecked</i>)
поскольку компилятор не осуществляет проверку отсутствия ссылок на освобождаемый объект.

Таким образом, выполнение этой процедуры может привести к появлению "висячих" ссылок.





<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>generic</b>
    <b>type</b> Object(&lt;&gt;) <b>is limited private</b>;
    <b>type</b> Name <b>is access</b> Object;

<b>procedure</b> Ada.Unchecked_Deallocation(X : <b>in out</b> Name);
<b>pragma</b> Convention(Intrinsic, Ada.Unchecked_Deallocatoin);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Для показанного ранее ссылочного типа <tt>Element_Ptr</tt>,
значения которого ссылаются на объекты типа <tt>Element</tt>
это может быть конкретизировано следующим образом:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Free <b>is new</b> Ada.Unchecked_Deallocation(Object =&gt; Element,
                                                 Name   =&gt; Element_Ptr);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Теперь, можно написать рекурсивную процедуру <tt>Free_List</tt>,
которая будет удалять список, состоящий из объектов типа <tt>Element</tt>.

Начало списка будет указываться параметром процедуры <tt>Free_List</tt>,
а для непосредственного удаления объекта типа <tt>Element</tt>
процедура <tt>Free_List</tt> будет использовать процедуру <tt>Free</tt>:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b>  Free;

<b>procedure</b> Free_List (List_Head: <b>in out</b> Element) <b>is</b>
<b>begin</b>
    <b>if</b>  List_Head.Next /= <b>null</b>
        Free_List(List_Head.Next);  -- рекурсивный вызов
    <b>end if</b>;
    
    Free(List_Head);
<b>end</b> Free_List;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В результате, для удаления показанного ранее списка объектов типа <tt>Element</tt>
начало которого указывается переменной <tt>Head_Element</tt>
можно выполнить следующее:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

    . . .
Free_List(Head_Element);
    . . .
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Следует напомнить, что в рассмотренном нами списке для последнего элемента (узла)
значение ссылки <tt>Next</tt> было равно <tt><b>null</b></tt>.

<p align="JUSTIFY">
При описании ссылочного типа <tt>Element_Ptr</tt>, может быть использована
директива компилятора <tt>Controlled</tt>:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

    . . .
<b>type</b> Element_Ptr <b>is access</b> Element;
<b>pragma</b> Controlled(Element_Ptr);
    . . .
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
В этом случае, компилятор будет проинформирован о том, что задачу освобождения
распределенного в пуле динамической памяти пространства,
для объектов на которые ссылаются значения ссылочного типа <tt>Element_Ptr</tt>,
взял на себя программист.



<p><h4><a name="s12.1.4">12.1.4 Пулы динамической памяти</a></h4>



<p align="JUSTIFY">
Обычно, все объекты ссылочного типа определенные пользователем, используют один, общий для
всей программы, пул динамической памяти.

Однако, согласно стандарта Ada95, допускается определение пользовательского пула динамической памяти
из которого будет производиться распределение памяти для динамически создаваемых объектов.

Такой пул могут использовать различные объекты ссылочного типа.

<p align="JUSTIFY">
Пользователь может описать свой собственный тип пула динамической памяти, используя
абстрактный тип <tt>Root_Storage_Pool</tt> описанный в пакете <i>System.Storage_Pools</i>,
и после этого ассоциировать его с объектом ссылочного типа используя атрибут
<tt><b>'<i>Storage_Pool</i></b></tt>.

Например:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Pool_Object : Some_Storage_Pool_Type;

<b>type</b> T <b>is access</b> <i>&lt;какой-нибудь_тип&gt;</i>;
<b>for</b> T<b>'<i>Storage_Pool</i></b> <b>use</b> Pool_Object;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Применение пулов динамической памяти определяемых пользователем
обусловлено, как правило, достаточно специфическими требованиями решаемой задачи.

<p align="JUSTIFY">
Например, достаточно распространенными являются случаи,
когда, при использовании единого пула,
интенсивное распределение/удаление динамических объектов с различными размерами
приводит к чрезмерной фрагментации единого пула динамической памяти.

В результате этого, может возникнуть ситуация
когда невозможно распределить непрерывный блок динамической памяти требуемого размера,
для размещения какого-либо динамического объекта,
при фактическом наличии достаточного общего объема свободной динамической памяти.

Чтобы предотвратить возникновение подобной ситуации,
можно использовать различные пулы динамической памяти
для объектов с различными размерами,
исключая, таким образом, возможность фрагментации пулов динамической памяти.

<p align="JUSTIFY">
Другими примерами случаев
использования пулов динамической памяти определяемых пользователем
могут служить:
необходимость распределения динамической памяти для объектов
размер которых значительно меньше чем минимальный размер памяти,
который распределяется для размещения объекта в общем пуле динамической памяти программы
(иначе - в пуле по-умолчанию);
требование приложения реального времени
обеспечить фиксированное время выполнения операций
распределения/освобождения пространства динамической памяти.


<p><h4><a name="s12.1.5">12.1.5 Проблемы обусловленные применением ссылочных типов</a></h4>



<p align="JUSTIFY">
Несмотря на то, что в сравнении с традиционными указателями
ссылочные типы Ады обладают свойствами которые
помогают обеспечить надежность разрабатываемого программного обеспечения,
нельзя не упомянуть о проблемах которые возникают при использовании как указателей,
так и ссылочных типов.

<p align="JUSTIFY">
Рассмотрим следующий пример:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>declare</b>

    <b>type</b> Person_Name <b>is new</b> String (1 .. 4);
    <b>type</b> Person_Age <b>is</b> Integer <b>range</b> 1 .. 150;

    <b>type</b> Person <b>is</b>
        <b>record</b>
            Name : Person_Name;
            Age  : Person_Age;
        <b>end record</b>;

    X : Person_Ptr := <b>new</b> Person'("Fred", 27);
    Y : Person_Ptr := <b>new</b> Person'("Anna", 20);

<b>begin</b>

    X := Y;                        -- <b>*****</b>
    Y.<b>all</b> := Person'("Sue ", 34);
    Put(X.Name);

<b>end</b>;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В этом примере, основной интерес для нас представляет строка помеченная звездочками.

В ней ссылочному объекту <tt>X</tt> присваивается значение ссылочного объекта <tt>Y</tt>,
а не значение объекта, на который ссылается <tt>Y</tt>.

После этого оба ссылочных объекта, - и <tt>X</tt>, и <tt>Y</tt>, - ссылаются на один и тот же объект,
размещенный в области динамической памяти.


<p align="JUSTIFY">
Первым интересным моментом является то, что теперь изменение объекта на который ссылается
переменная <tt>Y</tt> будет неявно изменять объект на который ссылается переменная <tt>X</tt>
(такое неявное изменение часто называют "побочным эффектом").

Поэтому в результате выполнения кода этого примера будет выводиться строка "<tt>Sue </tt>".

Следует заметить, что при разработке реальных программ, работающих со ссылочными типами,
необходимо уделять должное внимание эффектам подобного вида, поскольку они
могут быть первопричиной странного поведения программы, а в некоторых
случаях могут вызвать аварийное завершение работы программы.


<p align="JUSTIFY">
Вторым интересным моментом является то, что после выполнения присваивания
ссылочному объекту <tt>X</tt> значения ссылочного объекта <tt>Y</tt>,
теряется ссылка на объект, на который до присваивания ссылался ссылочный объект <tt>X</tt>.

При этом, сам объект продожает благополучно располагаться в области динамической памяти
(такой эффект называют "утечкой памяти").

Следует заметить, что при интенсивном использовании ссылочных типов,
утечка памяти может привести к тому,
что все доступное пространство области динамической памяти будет исчерпано.

После этого, любая попытка разместить какой-либо объект в области
динамической памяти приведет к ошибке <i>Storage_Error</i>.




<p>
<h3><a name="s12.2">12.2 Обобщенные ссылочные типы</a></h3>


<p align="JUSTIFY">
Рассмотренные нами ссылочные типы могут быть использованы только
как средство косвенного доступа к объектам которые размещаются в области динамической памяти.

Однако, бывают случаи когда необходимо использование механизма косвенного доступа
для статического объекта, то есть,
необходимо иметь возможность обратиться к содержимому статического объекта
используя значение ссылочного типа.

<p align="JUSTIFY">
Ада (согласно стандарта Ada95) предоставляет возможность описывать
статические объекты (переменные или константы) так, чтобы они являлись косвенно доступными,
а также предоставляет возможность описывать ссылочные типы, так, чтобы они могли
ссылаться не только на объекты размещенные в пуле динамической памяти, но и на статические объекты
(которые были описаны как косвенно доступные).

<p align="JUSTIFY">
В этом случае, статические объекты (переменные или константы) описываются
с использованием зарезервированного слова <tt><b>aliased</b></tt>,
которое указывает, что данный статический объект является косвенно доступным.

Например:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Int_Var   : <b>aliased</b> Integer;
Int_Const : <b>aliased constant</b> Integer := 0;
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Чтобы получить ссылочные значения для статических объектов которые допускают
использование косвенного доступа необходимо использовать атрибут
<tt><b>'<i>Access</i></b></tt>.


<p align="JUSTIFY">
Чтобы предоставить возможность ссылочному типу ссылаться на косвенно доступные статические объекты,
ссылочный тип описывается с использованием зарезервированного слова <tt><b>all</b></tt>
или зарезервированного слова <tt><b>constant</b></tt>.

Заметим, что такие ссылочные типы называют обобщенными ссылочными типами (<i>general access types</i>),
и они также могут быть использованы для доступа к объектам которые размещены
в пуле динамической памяти.

Например:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Int_Var_Ptr    <b>is  access all</b> Integer;
<b>type</b> Int_Const_Ptr  <b>is  access constant</b> Integer;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
При этом, если при описании ссылочного типа использовано зарезервированное слово <tt><b>all</b></tt>,
то такой ссылочный тип предоставляет доступ который позволяет осуществлять как чтение, так и запись
содержимого объекта на который ссылается значение этого ссылочного типа.

Следовательно, такое описание используется для получения ссылок на статические переменные.

<p align="JUSTIFY">
Если при описании ссылочного типа использовано зарезервированное слово <tt><b>constant</b></tt>,
то такой ссылочный тип предоставляет доступ который позволяет осуществлять только чтение
содержимого объекта на который ссылается значение этого ссылочного типа.

Следовательно, такое описание чаще всего используется для получения ссылок на константы
и в более редких случаях для получения ссылок на переменные.


<p align="JUSTIFY">
Рассмотрим следующий пример:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> General_Access_Demo <b>is</b>

    <b>type</b> Int_Var_Ptr_Type <b>is access all</b> Integer;
    A : <b>aliased</b> Integer;
    X, Y : Int_Var_Ptr_Type;

<b>begin</b>
    X := A<b>'<i>Access</i></b>;
    Y := <b>new</b> Integer;
<b>end</b> General_Access_Demo;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Здесь, переменная <tt>A</tt> имеет тип <tt>Integer</tt> и является косвенно доступной.

Переменные <tt>X</tt> и <tt>Y</tt> имеют тип <tt>Int_Var_Ptr_Type</tt> который является
обобщенным ссылочным типом.

В результате, внутри процедуры, переменная <tt>X</tt> ссылается на статическую переменную <tt>A</tt>,
ссылка на которую получена с помощью атрибута <tt><b>'<i>Access</i></b></tt>.

Переменная <tt>Y</tt> ссылается на объект типа <tt>Integer</tt> который размещен
в области динамической памяти.


<p align="JUSTIFY">
Ада позволяет использовать обобщенные ссылочные типы для формирования ссылок
на отдельные элементы внутри составных типов данных (таких как массив и/или запись),
например:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b>  Array_Type  <b>is array</b> (Positive <b>range</b> &lt; &gt;) <b>of aliased</b> Integer;

<b>type</b>  Record_Type <b>is</b>
    <b>record</b>
        A_Int_Var : <b>aliased</b> Integer;
        Int_Var   : Integer;
    <b>end record</b>;

<b>type</b> Int_Var_Ptr_Type <b>is access all</b> Integer;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В данном случае тип <tt>Array_Type</tt> - это массив, состоящий из косвенно доступных
элементов типа <tt>Integer</tt>, а тип <tt>Record_Type</tt> - это запись, у которой
поля <tt>A_Int_Var</tt> и <tt>Int_Var</tt> имеют тип <tt>Integer</tt>, причем поле
<tt>A_Int_Var</tt> косвенно доступно, а поле <tt>Int_Var</tt> - нет.

Таким образом, значения типа <tt>Int_Var_Ptr_Type</tt> могут ссылаться
на индивидуальные элементы массивов, принадлежащих к типу <tt>Array_Type</tt>,
и поле <tt>A_Int_Var</tt> записей, принадлежащих к типу <tt>Record_Type</tt>.


<p align="JUSTIFY">
Интересным примером использования обобщенных ссылочных типов может служить следующее
схематическое описание пакета:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Message_Services <b>is</b>
    <b>type</b> Message_Code_Type <b>is range</b> 0..100;

    <b>subtype</b> Message <b>is</b> String;

    <b>function</b> Get_Message(Message_Code: Message_Code_Type) <b>return</b> Message;

    <b>pragma</b> Inline(Get_Message);
<b>end</b> Message_Services;



<b>package body</b> Message_Services <b>is</b>
    <b>type</b> Message_Handle <b>is access constant</b> Message;

    Message_0: <b>aliased constant</b> Message := "OK";
    Message_1: <b>aliased constant</b> Message := "Up";
    Message_2: <b>aliased constant</b> Message := "Shutdown";
    Message_3: <b>aliased constant</b> Message := "Shutup";
        . . .

    Message_Table: <b>array</b> (Message_Code_Type) <b>of</b>
        Message_Handle :=
            (0 =&gt; Message_0<b>'<i>Access</i></b>,
             1 =&gt; Message_1<b>'<i>Access</i></b>,
             2 =&gt; Message_2<b>'<i>Access</i></b>,
             3 =&gt; Message_3<b>'<i>Access</i></b>,
                . . .
            );

    <b>function</b> Get_Message(Message_Code: Message_Code_Type)
        <b>return</b> Message <b>is</b>
    <b>begin</b>
        <b>return</b> Message_Table(Message_Code).<b>all</b>;
    <b>end</b> Get_Message;
<b>end</b> Message_Services;</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В данном случае, достаточно элегантным приемом является использование массива <tt>Message_Table</tt>,
который представляет таблицу ссылок на строковые константы переменной длины.
Следует также заметить, что при этом не производится никакого распределения пространства
в области динамической памяти.



<p><h4><a name="s12.2.1">12.2.1 Правила области видимости для обобщенных ссылочных типов</a></h4>


<p align="JUSTIFY">
В целях обеспечения надежности, на использование обобщенных ссылочных типов
накладываются некоторые дополнительные ограничения.

Так, область видимости косвенно доступного объекта,
на который будет ссылаться значение переменной обобщенного ссылочного типа <tt>T</tt>,
не должна быть глубже чем область видимости переменной обобщенного ссылочного типа <tt>T</tt>.

Это подразумевает, что следующий пример - не корректен, и, следовательно,
будет отвергнут компилятором:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Illegal <b>is</b>            -- внешняя область видимости описаний

    <b>type</b> Integer_Access <b>is access all</b> Integer;
    Integer_Ptr : Integer_Access;

<b>begin</b>
        . . .
    <b>declare</b>                     -- внутренняя область видимости описаний
        Integer_Variable : <b>aliased</b> Integer;
    <b>begin</b>
        Integer_Ptr := Integer_Variable<b>'<i>Access</i></b>;         -- это не корректно!!!
    <b>end</b>;                        -- завершение области видимости
                                -- переменной <i>Integer_Variable</i>

    Integer_Ptr.<b>all</b> := Integer_Ptr.<b>all</b> + 1;             -- сюрприз!
                                -- переменная <i>Integer_Variable</i>
                                --   больше не существует!

<b>end</b> Illegal;                    -- завершение области видимости
                                --   для <i>Integer_Access</i>
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Смысл примера заключается в следующем. 

Во внутреннем блоке, переменной <tt>IA</tt> ссылочного типа <tt>Integer_Access</tt>
присваивается значение которое ссылается на переменную <tt>IVar</tt>.

При завершении внутреннего блока, переменная <tt>IVar</tt> прекращает свое существование.

Следовательно, в следующей инструкции присваивания, переменная <tt>IA</tt>
ссылается на не существующую переменную.

Такая ситуация известна как "проблема висячих указателей".

<p align="JUSTIFY">
Такое ограничение выглядит достаточно строго, но оно гарантирует, что любой объект
на который могут ссылаться значения типа <tt>Integer_Access</tt>
будет существовать на протяжении всего времени существования переменных типа
<tt>Integer_Access</tt>.

В частности, если тип <tt>Integer_Access</tt> описан на уровне библиотеки, то
область видимости <tt>Integer_Access</tt> определяется всей программой, а это значит,
что с типом <tt>Integer_Access</tt> могут быть использованы только те переменные,
которые описаны на уровне библиотеки.

<p align="JUSTIFY">
Бывают случаи когда необходимо нарушить строгость данного ограничения.

Тогда, для получения ссылочного значения, вместо атрибута <tt><b>'<i>Access</i></b></tt>
можно использовать атрибут <tt><b>'<i>Unchecked_Access</i></b></tt>,
который позволяет получить ссылочное значение без осуществления
проверки правил доступа:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Legal_But_Stupid <b>is</b>

    <b>type</b> Integer_Access <b>is access all</b> Integer;
    IA : Integer_Access;

<b>begin</b>
        . . .
    <b>declare</b>
        IVar : <b>aliased</b> Integer;
    <b>begin</b>
        IA := IVar<b>'<i>Unchecked_Access</i></b>;  -- это не надежно!!!
    <b>end</b>;
    IA.<b>all</b> := IA.<b>all</b> + 1;             -- теперь это будет только ВАША ошибка!!!
<b>end</b> Legal_But_Stupid;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Следует заметить, что применение атрибута <tt><b>'<i>Unchecked_Access</i></b></tt> -
не рекомендуется.

Это подразумевает, что при его использовании вы должны быть полностью уверены в своих действиях.


<p align="JUSTIFY">
Еще одним способом, который позволяет обходить эти ограничения,
является описание обобщенных ссылочных типов внутри настраиваемых модулей.

Идея такого подхода основана на том, что
область видимости для типа который описан внутри настраиваемого модуля
будет ограничена областью видимости места конкретизации этого настраиваемого модуля.




<p>
<h3><a name="s12.3">12.3 Ссылочные типы для подпрограмм</a></h3>

<p align="JUSTIFY">
Также как и обобщенные ссылочные типы, ссылочные типы для подпрограмм не доступны в стандарте Ada83.

Они являются нововведением, которое определил выход стандарта Ada95.


<p align="JUSTIFY">
Ссылочные типы для подпрограмм позволяют использовать подпрограммы как параметры
передаваемые другим подпрограммам (например, так как это делается в математических библиотеках
Фортрана), а также осуществлять позднее связывание.


<p align="JUSTIFY">
При описании ссылочных типов для подпрограмм следует придерживаться следующих соглашений:

<ul>
<li><p align="JUSTIFY">описание типа должно определять такой список параметров,
который соответствует списку параметров подпрограммы на которую будут ссылаться
значения этого типа
<li><p align="JUSTIFY">при описании ссылочного типа для функции,
тип возвращаемого значения должен соответствовать типу возвращаемого значения функции
на которую будут ссылаться значения этого типа
<li><p align="JUSTIFY">переменные ссылочного типа для подпрограмм могут быть использованы
для доступа к любой подпрограмме профиль  которой соответствует профилю
определеному при описании этого ссылочного типа
</ul>
<!---
NOTE!!! :  from J.English:

    The number and types of the parameters and the result type of functions
    must match those given in the access type declaration
    (but the parameter names don't need to).
--->


<p align="JUSTIFY">
Простейшим примером использования функционального ссылочного типа как параметра подпрограммы
может служить следующий фрагмент кода:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b>  Access_Function <b>is access   function</b>(Item: <b>in</b>     Float) <b>return</b> Float;

<b>type</b>  Vector  <b>is array</b> (Integer <b>range</b> &lt; &gt;) <b>of</b> Float;

<b>procedure</b> For_Each( F : <b>in</b>     Access_Function;
                    To: <b>in out</b> Vector           ) <b>is</b>
<b>begin</b>
    <b>for</b> I <b>in</b> To<b>'<i>Range</i></b>  <b>loop</b>
        To(I) := F( To(I) );
    <b>end loop</b>;
<b>end</b> For_Each;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Здесь, процедура <tt>For_Each</tt> принимает в качестве параметра <tt>F</tt>
значение ссылочного типа <tt>Access_Function</tt> указывющее на функцию,
которую необходимо вызывать при обработке каждого элемента массива типа <tt>Vector</tt>,
передаваемого ей как параметр <tt>To</tt>.
<!---
передаваемого в процедуру <tt>For_Each</tt> как параметр <tt>To</tt>.
--->

<p align="JUSTIFY">
Примечательно, что при вызове функции <tt>F</tt> расшифровка ссылки производится
автоматически. Следует также заметить, что вместо "<tt>F( To(I) )</tt>"
можно было бы написать "<tt>F.<b>all</b>( To(I) )</tt>", что в подобных случаях -
не обязательно.

Использование <tt>.<b>all</b></tt> требуется когда вызываемая подпрограмма
(процедура или функция) не имеет параметров.

<p align="JUSTIFY">
Описание переменной массива чисел,
передаваемой как параметр <tt>To</tt> для процедуры <tt>For_Each</tt>,
и описание функции,
ссылка на которую могла бы быть использовна как параметр <tt>F</tt> процедуры <tt>For_Each</tt>,
могут иметь следующий вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Data_Vector : Vector (1..3) := (1.0, 2.0, 3.0);

<b>function</b> Square(Val: <b>in</b>     Float) <b>return</b> Float <b>is</b>
<b>begin</b>
    <b>return</b> Val * Val;
<b>end</b> Square;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Таким образом, вызов процедуры <tt>For_Each</tt> (с учетом приведенных ранее описаний)
будет иметь вид:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

For_Each( F  =&gt; Square<b>'<i>Access</i></b>,
          To =&gt; Data_Vector   );
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Примечательно, что для получения ссылочного значения которое указывает на
функцию <tt>Square</tt> используется атрибут <tt><b>'<i>Access</i></b></tt>.


<p align="JUSTIFY">
Ссылочные типы для подпрограмм могут быть использованы для построения
таблиц вызова подпрограмм. Рассмотрим следующий схематический пример:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Action_Operation <b>is access procedure</b>;

<b>procedure</b> Add;
<b>procedure</b> List;
<b>procedure</b> Delete;

Action : <b>constant array</b> (1..3) <b>of</b> Action_Operation := (
                              Add<b>'<i>Access</i></b>,
                              List<b>'<i>Access</i></b>,
                              Delete<b>'<i>Access</i></b>
);



<b>type</b> Math_Function <b>is access function</b> (I : <b>in</b>     Float) <b>return</b> Float;

<b>function</b> Sin (F : <b>in</b>     Float) <b>return</b> Float;
<b>function</b> Cos (F : <b>in</b>     Float) <b>return</b> Float;
<b>function</b> Tan (F : <b>in</b>     Float) <b>return</b> Float;

Math_Operation : <b>constant array</b> (1..3) <b>of</b> Math_Function := (
                              Sin<b>'<i>Access</i></b>,
                              Cos<b>'<i>Access</i></b>,
                              Tan<b>'<i>Access</i></b>
);
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Здесь формируются две таблицы вызовов подпрограмм:
первая таблица вызовов представлена массивом <tt>Action</tt>,
который содержит значения ссылочного типа <tt>Action_Operation</tt>,
а вторая таблица вызовов представлена массивом <tt>Math_Operation</tt>,
который содержит значения ссылочного типа <tt>Math_Function</tt>
(заметим, что таблицами вызовов, как правило, являются массивы).

<p align="JUSTIFY">
Примером вызова <tt>I</tt>-той подпрограммы в таблице (где <tt>I</tt> - это индекс
в таблице) может служить следующее:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

F:  Float;
  . . .
  
Action(I).<b>all</b>;              -- вызов I-той процедуры из таблицы
                            --   Action
F := Math_Operation(I)(F);  -- вызов I-той функции из таблицы
                            --   Math_Operation с параметром F
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Напомним, что для ссылочных значений, которые указывают на подпрограммы без
параметров, при вызове подпрограммы требуется использование <tt>.<b>all</b></tt>.




<p><h4><a name="s12.3.1">12.3.1 Правила области видимости ссылочных типов для подпрограмм</a></h4>



<p align="JUSTIFY">
Ссылочные типы для подпрограмм используют те же самые правила области видимости, что
и обобщенные ссылочные типы.

Таким образом, ссылочные типы для подпрограмм, которые описаны на уровне библиотеки,
могут быть использованы только для ссылки на библиотечные подпрограммы.

Дополнительным ограничением является то, что со ссылочными типами для подпрограмм
нельзя использовать атрибут <tt><b>'<i>Unchecked_Access</i></b></tt>.

<p align="JUSTIFY">
Единственный способ, который позволяет обходить такие строгие ограничения,
является описание ссылочных типов для подпрограмм внутри настраиваемых модулей.

<!---
Идея такого подхода заключена в том, что
область видимости для типа который описан внутри настраиваемого модуля
будет ограничена областью видимости места конкретизации этого настраиваемого модуля.
--->



<p>
<h3><a name="s12.4">12.4 Низкоуровневая средства работы со ссылочными типами<br>
                         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                         и физическими адресами памяти</a></h3>


<p align="JUSTIFY">
Для организации работы с динамическими данными и динамической памятью
в большинстве приложений достаточно тех механизмов, которые
предоставляют ссылочные типы Ады.

Однако, при решении специфических системных задач, может возникнуть
необходимость непосредственного взаимодействия с физическими адресами
памяти используемой аппаратной платформы.

<p align="JUSTIFY">
Для таких случаев Ада предусматривает стандартный набор низкоуровневых средств.

Так, в стандартном пакете <i>System</i> представлены:

<ul>
<li><p align="JUSTIFY">
приватный тип <tt>Address</tt>, внутреннее представление которого
соответствует внутреннему представлению физического адреса памяти используемой системы.
<li><p align="JUSTIFY">
константа <tt>Storage_Unit</tt> - предоставляет битовый размер минимального
адресуемого элемента памяти системы
<!---
<li><p align="JUSTIFY">
константа <tt>Word_Size</tt> - предоставляет битовый размер машинного слова
--->
<li><p align="JUSTIFY">
константа <tt>Memory_Size</tt> - максимально возможный размер памяти системы
</ul>


<p align="JUSTIFY">
При решении таких задач, важно учитывать тот факт, что
реализация внутреннего представления значений ссылочных типов
не обязана соответствовать представлению физических адресов
системы.

Стандарт Ады этого не требует.

Для выполнения преобразований значений ссылочных типов в значение физического адреса и наоборот,
следует использовать настраиваемый пакет <i>System.Address_To_Access_Conversions</i>,
спецификация которого имеет следующий вид:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>generic</b>
   <b>type</b> Object (<>) <b>is limited private</b>;

<b>package</b> System.Address_To_Access_Conversions <b>is</b>
<!---
<b>pragma</b> Preelaborate (Address_To_Access_Conversions);
--->

   <b>type</b> Object_Pointer <b>is access all</b> Object;
   <b>for</b> Object_Pointer<b>'<i>Size</i></b> <b>use</b> Standard<b>'<i>Address_Size</i></b>;

   <b>function</b> To_Pointer (Value : Address)        <b>return</b> Object_Pointer;
   <b>function</b> To_Address (Value : Object_Pointer) <b>return</b> Address;
<!---

   <b>pragma</b> Convention (Intrinsic, To_Pointer);
   <b>pragma</b> Convention (Intrinsic, To_Address);
--->

<b>end</b> System.Address_To_Access_Conversions;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
И в заключение, в стандартном пакете <i>System.Storage_Elements</i> предоставлены
операции адресной арифметики и некоторые дополнительные описания
(за более подробными сведениями следует обратиться к файлу спецификации этого пакета).









<!--- footer --->




<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>




</blockquote>
</body>
</html>

