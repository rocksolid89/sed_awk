<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<title>Адское программирование.</title>
</head>


<body BGCOLOR="FFFFFF">
<basefont size=3>
<blockquote>

<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>



<!--- header --->



<h2><a name="s15">15. Многозадачность</a></h2>


<p align="JUSTIFY">
Встроенная поддержка многозадачности является уникальной
и широко известной особенностью языка программирования Ада,
которая выгодно отличает его от большинства современных языков программирования.

Следует особо подчеркнуть, что поддержка многозадачности
обеспечивается не с помощью каких-либо расширений или внешних библиотек,
а с помощью строго стандартизированных средств,
которые встроены непосредственно в язык программирования.


<p align="JUSTIFY">
Обеспечение поддержки многозадачности на уровне языка программирования
имеет важное значение.

Благодаря этому достигается стабильность семантики,
которая избавляет разработчика программного обеспечения
как от необходимости использования разнородных внешних библиотек,
так и от необходимости разработки своих собственных
решений для обеспечения поддержки многозадачности.

В результате, облегчается общее понимание исходных текстов многозадачных программ
и обеспечивается лучшая переносимость программного обеспечения.


<p align="JUSTIFY">
В качестве стандартных средств поддержки многозадачности Ады используются
задачи (<i>tasks</i>), которые хорошо известны со времен стандарта Ada83
и описывают последовательности действий, которые способны выполняться одновременно,
а также объекты защищенных типов (<i>protected types</i>),
которые являются нововведением стандарта Ada95.


<p align="JUSTIFY">
Программа на языке Ада состоит как минимум из одной, а возможно и множества задач,
выполняющихся одновременно.

Каждая задача выполняется независимо от остальных задач.

Механизмы межзадачного обмена данными и синхронизации основаны на
высокоуровневых концепцях рандеву и использовании защищенных объектов.

Следует заметить, что рандеву и защищенные объекты обладают более высоким уровнем абстракции
по сравнению с семафорами.

Они предоставляют средства защитной блокировки и таймаутов,
а также средства для выполнения выборочного перестроения очередей клиентов
и аварийного завершения.
<!---
(в Ada95)
--->


<p align="JUSTIFY">
"Гибель" одной задачи не обязательно оказывает влияние на выполнение других задач,
за исключением случаев, когда они пытаются с ней взаимодействовать.

Специализированные задачи отсутствуют.

Возможны ситуации, когда основная процедура Ада-программы может завершиться,
а остальные задачи продолжат свое выполнение.



<p>
<h3><a name="s15.1">15.1 Задачи</a></h3>


<p><h4><a name="s15.1.1">15.1.1 Типы и объекты задач</a></h4>


<p align="JUSTIFY">
Конструкция задачи обладает свойствами, которые характерны для пакетов, процедур и структур данных:


<ul>
<li>
Подобно пакетам, задача имеет спецификацию и тело, однако она не может
быть самостоятельно компилируемой единицей, помещенной в свой собственный
файл с исходным текстом.

Вместо этого, задача должна быть помещена в другую структуру (например, пакет или процедуру)

<li>
Подобно процедуре, задача содержит раздел описаний и исполнительную часть,
однако она не вызывается как процедура.

Вместо этого, она начинает выполняться автоматически, как часть структуры,
в которой она описана.
<li>
Подобно структуре данных, задача имеет тип и может существовать как переменная
этого типа. Кроме того, подобно записи, задача может иметь дискриминанты.
</ul>


<p align="JUSTIFY">
Спецификация задачи, начинающаяся зарезервированными словами <tt><b>task type</b></tt>,
определяет тип задачи (или задачный тип). Значение объекта (переменная) типа задачи
представляет собой задачу.

Спецификация задачи, не содержащаяя зарезервированного слова <tt><b>type</b></tt>,
определяет одиночную задачу,
а описание задачи с такой спецификацией равносильно описанию анонимного типа задачи
с одновременным описанием объекта этого типа.


<p align="JUSTIFY">
Простым примером многозадачной программы может служить следующая программа:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b>  Ada.Text_IO;

<b>procedure</b> Multitasking_Demo <b>is</b>

    -- спецификация анонимной задачи
    <b>task</b> Anonimous_Task;

    -- тело анонимной задачи
    <b>task body</b> Anonimous_Task <b>is</b>
    <b>begin</b> -- для Anonimous_Task

        <b>for</b> Count <b>in</b> 1..5 <b>loop</b>
            Ada.Text_IO.Put_Line("Hello from Anonimous_Task");
        <b>end loop</b>;

    <b>end</b> Anonimous_Task;



    -- спецификация типа задачи
    <b>task type</b> Simple_Task (Message: Character);

    -- тип задачи имеет тело
    <b>task body</b> Simple_Task <b>is</b>
    <b>begin</b> -- для Simple_Task

        <b>for</b> Count <b>in</b> 1..5 <b>loop</b>
            Ada.Text_IO.Put_Line("Hello from Simple_Task " &amp; Message);
        <b>end loop</b>;

    <b>end</b> Simple_Task;

    -- переменная задачного типа
    Simple_Task_Variable: Simple_Task(Message =&gt; 'A');

<b>begin</b> -- для Multitasking_Demo

    -- в отличие от процедур, задачи не вызываются,
    -- а активируются автоматически

    -- выполнение обоих задач начинается как только
    -- управление достигнет этой точки, то есть, сразу
    -- после "begin", но перед выполнением первой инструкции
    -- головной процедуры Multitasking_Demo

    <b>null</b>;

<b>end</b> Multitasking_Demo;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В данном примере описана одиночная задача анонимного типа <tt>Anonimous_Task</tt>,
тип задачи <tt>Simple_Task</tt> и переменная задачи <tt>Simple_Task_Variable</tt>,
имеющая тип <tt>Simple_Task</tt>.

Примечательно, что описание типа задачи <tt>Simple_Task</tt> содержит дискриминант,
значение которого используется как параметр задачи
и указывается при описании переменной задачи <tt>Simple_Task_Variable</tt>.

Следует также обратить внимание на то, что
любой тип задачи является лимитированным и, таким образом,
для него не существует предопределенных операций присваивания или сравнения.

Алгоритмы работы обоих задач просты и подобны - каждая задача выводит пять приветственных
сообщений и завершает свою работу.


<p align="JUSTIFY">
Рассмотрим еще один простой пример,
который демонстрирует использование задачного типа
для описания более одного экземпляра объекта задачи.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b>  Ada.Text_IO;

<b>procedure</b> Multitasking_Demo_2 <b>is</b>

    -- спецификация типа задачи
    <b>task type</b> Simple_Task (Message: Character; How_Many: Positive);

    -- тело типа задачи
    <b>task body</b> Simple_Task <b>is</b>
    <b>begin</b> -- для Simple_Task

        <b>for</b> Count <b>in</b> 1..How_Many <b>loop</b>
            Ada.Text_IO.Put_Line("Hello from Simple_Task " &amp; Message);
            <b>delay</b> 0.1;
        <b>end loop</b>;

    <b>end</b> Simple_Task;

    -- переменные задачного типа
    Simple_Task_A: Simple_Task(Message =&gt; 'A', How_Many =&gt; 5);
    Simple_Task_B: Simple_Task(Message =&gt; 'B', How_Many =&gt; 10);

<b>begin</b> -- для Multitasking_Demo_2

    <b>null</b>;

<b>end</b> Multitasking_Demo_2;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В этом примере, тип задачи <tt>Simple_Task</tt> содержит два дискриминанта:
дискриминант <tt>Message</tt> типа <tt>Character</tt> используется
при выдаче приветственного сообщения, как и ранее, а
дискриминант <tt>How_Many</tt> используется для указания количества выдаваемых сообщений.

Таким образом, переменная задачи <tt>Simple_Task_A</tt>
выдаст пять приветствий, а переменная <tt>Simple_Task_B</tt> - десять.



<p><h4><a name="s15.1.2">15.1.2 Инструкции задержки выполнения (<i>delay statements</i>)</a></h4>



<p align="JUSTIFY">
При внимательном рассмотрении исходного текста последнего примера
можно обнаружить, что после инструкции вывода сообщения приветствия
располагается инструкция "<tt><b>delay</b> 0.1;</tt>",
с помощью которой в данном случае осуществляется задержка выполнения задачи на 0.1 секунды.


<p align="JUSTIFY">
Инструкции задержки выполнения могут быть использованы
для приостановки выполнения тела задачи (или программы) на некоторое время.

Рзличают два вида инструкций задержки выполнения: относительная задержка выполнения
и абсолютная задержка выполнения.


<p align="JUSTIFY">
Общий вид инструкции относительной задержки выполнения следующий:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>delay</b> <i>время_задержки</i>;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Здесь результат выражения <tt><i>время_задержки</i></tt>, имеющего предопределенный
вещественный тип с фиксированной точкой <tt>Duration</tt> (описан в пакете <i>Standard</i>),
указывает длительность задержки выполнения в секундах,
на которую необходимо задержать выполнения задачи (или программы).

При этом отсчет времени задержки выполняется относительно текущего момента времени.

Наглядным примером использования инструкции относительной задержки,
для задержки выполнения задачи на одну секунду,
может служить следующее:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>delay</b> 1.0;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Общий вид инструкции абсолютной задержки выполнения следующий:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>delay until</b> <i>время_задержки</i>;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В этом случае результат выражения <tt><i>время_задержки</i></tt>, любого неограниченного типа,
указывает момент времени, до наступления которого необходимо задержать выполнение
задачи (или программы).

Следующий пример демонстрирует использование инструкции абсолютной задержки выполнения задачи:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>delay until</b> Time_Of(2010, 1, 1, 0.0);  -- задержка выполнения до 1 января 2010 года
</pre></dir>
</td></tr></table>




<p align="JUSTIFY">
Следует также заметить, что описание предопределенного типа времени <tt>Time</tt>
и ассоциируемых с ним операций предусматривается в стандартном пакете <i>Ada.Calendar</i>.

Кроме того, пакет <i>Ada.Calendar</i> предоставляет функцию <tt>Clock</tt>,
которая возвращает значение текущего момента времени
(для получения более полной информации следует обратиться к спецификации
этого пакета).


<p align="JUSTIFY">
Отметим также, что при построении систем, которые должны работать в реальном масштабе времени,
вместо типа времени <tt>Time</tt>, описанного в стандартном пакете <i>Ada.Calendar</i>,
следует использовать тип времени <tt>Time</tt>, который описывается в пакете <i>Ada.Real_Time</i>
(для получения более полной информации следует обратиться к спецификации
пакета <i>Ada.Real_Time</i>).



<p><h4><a name="s15.1.3">15.1.3 Динамическое создание объектов задач</a></h4>



<p align="JUSTIFY">
Ада предоставляет возможность динамически порождать объекты задач с помощью <tt><b>new</b></tt>,
что может оказаться полезным, когда необходимо множество объектов задач одного типа.

Предположим, что у нас есть следующая спецификация типа задачи:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>task type</b> Counting_Task <b>is</b>
    <b>entry</b> Add           (Amount : <b>in</b>     Integer);
    <b>entry</b> Current_Total (Total  :    <b>out</b> Integer);
<b>end</b> Counting_Task;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Мы можем описать ссылочный тип <tt>Counting_Task_Ptr</tt>,
который позволяет ссылаться на объекты задач типа <tt>Counting_Task</tt>.

Затем мы можем описывать переменные ссылочного типа <tt>Counting_Task_Ptr</tt>
и с помощью <tt><b>new</b></tt> создавать динамические объекты задач,
как показано в следующем примере:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>declare</b>
    . . .
    <b>type</b> Counting_Task_Ptr <b>is access</b> Counting_Task;

    Task_Ptr :  Counting_Task_Ptr;        -- переменная ссылающаяся на объект задачи
    . . .
<b>begin</b>
    . . .
    Task_Ptr := <b>new</b> Counting_Task;   -- динамическое создание объекта задачи
    . . .
<b>end</b>;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Подобным образом можно динамически создать любое необходимое количество объектов задач.

Поскольку реализация Ада-системы не обязана освобождать память, занятую
при динамическом создании объекта задачи, то это необходимо
выполнять самостоятельно, используя предопределенную настраиваемую
процедуру <tt>Ada.Unchecked_Deallocation</tt>.




<p><h4><a name="s15.1.4">15.1.4 Принудительное завершение <tt><b>abort</b></tt></a></h4>



<p align="JUSTIFY">
Ада позволяет принудительно завершать выполнения объекта задачи.

Это может быть выполнено с помощью инструкции прекращения,
которая может иметь следующий вид:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>abort</b> Some_Task_Name;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Здесь <tt>Some_Task_Name</tt> - это имя какого-либо объекта задачи.

Считается, что принудительно прекращенная
задача находится в "ненормальном" (<i>abnormal</i>)
состоянии и не может взаимодействовать с другими задачами.

После того, как состояние задачи отмечено как "ненормальное",
выполнение ее тела прекращается.

Это подразумевает, что прекращается выполнение любых инструкций,
расположенных в теле задачи, за исключением тех,
которые вызывают операции, отложенные до принудительного прекращения
(<i>abort-deffered operations</i>).


<p align="JUSTIFY">
Следует заметить, что использование принудительного прекращения
выполнения задачи является "аварийным" действием,
и должно применяться только в тех случаях,
когда принудительное прекращение выполнения задачи действительно необходимо
(например, когда задача "зависла").


<p align="JUSTIFY">
Следует понимать, что
использование такого "сильнодействующего" средства остановки для задач,
которые выполняют сохранение каких-либо дисковых данных,
может повлечь за собой не только потерю самих данных,
но и повреждение логической структуры дискового накопителя.




<p><h4><a name="s15.1.5">15.1.5 Приоритеты задач</a></h4>



<p align="JUSTIFY">
Каждая задача Ады может обладать своим собственным приоритетом выполнения,
который задается с помощью директивы компилятора <tt>Priority</tt>:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>pragma</b> Priority ( <i>expression</i> );
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Непосредственное использование этой директивы компилятора допускается:
<ul>
<li>внутри спецификации задачи,
<li>внутри спецификации защищенного типа или объекта,
<li>в описательной части тела подпрограммы
</ul>


<p align="JUSTIFY">
Значение результата выражения <tt><i>expression</i></tt>,
используемого для непосредственного указания приоритета,
должно принадлежать целочисленному типу <tt>Integer</tt>,
причем при указании директивы <tt>Priority</tt> в описательной части тела подпрограммы
выражение <tt><i>expression</i></tt> должно быть статическим,
а его значение должно принадлежать диапазону значений подтипа <tt>Priority</tt>,
который описан в пакете <i>System</i>.

Например:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>task</b>  Some_Task <b>is</b>
    <b>pragma</b> Priority (5);
    . . .
<b>end</b> Some_Task;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Приоритет выполнения задачи определяет ее привилегии на обладание системными
ресурсами (например, процессором).

В простейшем случае, если две задачи с разными приоритетами готовы к выполнению,
то к выполнению будет допущена та задача, приоритет которой выше.

При равенстве приоритетов порядок выполнения задач не определен.


<p align="JUSTIFY">
В Ada83 приоритет задачи строго фиксировался при ее описании.

Согласно стандарту Ada95, приоритет задачи может быть изменен в процессе
существования задачи (кроме приоритета, указанного для подпрограммы),
то есть задачи могут иметь динамически изменяемые приоритеты.


<p align="JUSTIFY">
Средства динамического определения и изменения текущего приоритета задачи
предоставляются предопределенным стандартным пакетом <i>Ada.Dynamic_Priorities</i>.

Спецификация этого пакета проста и имеет следующий вид:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> System;
<b>with</b> Ada.Task_Identification; -- спецификация этого пакета обсуждается в 15.2.7,
                              -- при рассмотрении вопроса идентификации задач
<b>package</b> Ada.Dynamic_Priorities <b>is</b>

    <b>procedure</b> Set_Priority
        (Priority : <b>in</b> System.Any_Priority;
         T        : <b>in</b> Ada.Task_Identification.Task_ID :=
            Ada.Task_Identification.Current_Task);

    <b>function</b> Get_Priority
        (T : Ada.Task_Identification.Task_ID :=
            Ada.Task_Identification.Current_Task)
        <b>return</b> System.Any_Priority;

<b>end</b> Ada.Dynamic_Priorities;
</pre></dir>
</td></tr></table>


<!---
<p align="JUSTIFY">
--->



<p align="JUSTIFY">
Следует заметить, что правила планирования выполнения задач
на основе статических и динамических приоритетов
рассматриваются в приложении <i>D</i> (<i>Annex D</i>) стандарта Ada95,
в котором указываются требования для систем реального времени.



<p>
<h3><a name="s15.2">15.2 Взаимодействие задач</a></h3>



<p align="JUSTIFY">
Показанные ранее примеры многозадачных программ демонстрировали только
способность задач выполняться одновременно.

При этом организация взаимодействия различных задач между собой не рассматривалась.

В реальности обеспечение такого взаимодействия между одновременно выполняющимися задачами
с целью обмена данными или взаимной синхронизации работы имеет важное значение.




<p><h4><a name="s15.2.1">15.2.1 Концепция рандеву</a></h4>



<p align="JUSTIFY">
Как один из механизмов обеспечения надежного межзадачного обмена данными
и взаимной синхронизации работы задач, Ада предоставляет механизм рандеву.

Основополагающая идея механизма рандеву достаточно проста.

В спецификации задачи публикуются различные входы (<i>entry</i>) в задачу,
в которых она готова ожидать обращения к ней от других задач.

Далее, в теле задачи указываются инструкции принятия обращений
к соответствующим входам, указанным в спецификации этой задачи.


<p align="JUSTIFY">
Необходимо обратить внимание на несимметричность такого механизма взаимодействия.

Это означает, что в процессе взаимодействия
одна из задач рассматривается как сервер, а вторая - как клиент,
причем задача-сервер не может быть инициатором начала взаимодействия.


<p align="JUSTIFY">
В простейшем случае, когда рассматривается взаимодействие только двух задач,
задача-клиент, желающая обратиться к другой задаче (задаче-серверу),
инициирует обращение к входу задачи-сервера.

После этого задача-сервер откликается на обращение задачи-клиента,
принимая обращение к этому входу.

Таким образом, взаимодействие двух задач осуществляется в ситуации,
когда задача-клиент обратилась к входу, а задача-сервер готова принять это обращение.

Этот способ взаимодействия двух задач называется рандеву.


<p align="JUSTIFY">
Поскольку задача-клиент и задача-сервер выполняются независимо друг от друга, то
нет никакой гарантии, что обе задачи окажутся в точке осуществления рандеву одновременно.

Поэтому, если задача-сервер оказалась в точке рандеву,
но при этом нет ни одного обращения к входу (запроса на взаимодействие),
то она должна ждать появления такого обращения.

Аналогично, если задача-клиент обращается к входу, а задача-сервер
не готова обслужить такое обращение,
то задача-клиент должна ждать, пока задача-сервер обслужит это обращение.

В процессе ожидания как задача-клиент, так и задача-сервер не занимают ресурсы процессора,
находясь в состоянии, которое называют приостановленным или состоянием блокировки.


<p align="JUSTIFY">
В случаях, когда вызовы к входу задачи-сервера осуществляют сразу несколько задач-клиентов,
эти вызовы ставятся в очередь.

Порядок обслуживания такой очереди зависит от соответствия
конкретной реализации Ада-системы
требованиям приложения <i>D</i> (<i>Annex D</i>) стандарта Ada95,
в котором указываются требования для систем реального времени.

Если реализация Ада-системы не обеспечивает соответствия этим требованиям,
то очередь обслуживается в порядке поступления вызовов
(<i>FIFO - First-In-First-Out</i>).



<p><h4><a name="s15.2.2">15.2.2 Описание входов</a></h4>



<p align="JUSTIFY">
Чтобы некоторая
<!---
Для того, чтобы какая-либо
--->
задача-клиент могла инициировать рандеву с задачей-сервером,
описание спецификации задачи-сервера должно содержать описание соответствующего входа.

Следует заметить, что описания входов могут быть помещены
только в описание спецификации задачи,
кроме того, задача может иметь приватные входы.

Таким образом, описание входа в спецификации задачи-сервера
может рассматриваться как декларация сервиса,
предоставляемого задачей-сервером для задач-клиентов.


<p align="JUSTIFY">
Для описания входов задачи-сервера используется зарезервированное слово <tt><b>entry</b></tt>, а
семантика входов задач очень похожа на семантику процедур:

<ul>
<li>
Так же, как и процедуры, входы задач имеют имена и могут иметь различные параметры.
Для имен входов допускается совмещение имен, что подразумевает
наличие у одной задачи нескольких входов с одинаковыми именами,
но различными параметрами.

<li>
Параметры входов задачи, так же, как и параметры процедур, могут использоваться в режимах
"<tt><b>in</b></tt>", "<tt><b>in out</b></tt>" и "<tt><b>out</b></tt>",
и могут иметь значения по умолчанию.
</ul>


<p align="JUSTIFY">
При описании параметров входа задачи-сервера следует учитывать,
что, в отличие от процедур,
для входов задач не допускаются ссылочные параметры,
хотя допускаются параметры ссылочного типа.

Кроме того, при описании входа может быть опционально указан дискретный тип,
который будет использоваться для целого семейства входов в качестве типа индекса,
значения которого применяются для определения индивидуальных входов в семействе.

Рассмотрим примеры следующих описаний:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>task</b>  Anonimous_Task  <b>is</b>
    <b>entry</b> Start;
<b>end</b> Anonimous_Task;


<b>type</b> Level <b>is</b> (Low, Middle, Hight);

<b>task type</b> Simple_Task <b>is</b>
    <b>entry</b> Read (Value: <b>out</b> Integer);
    <b>entry</b> Request (Level) (Item: <b>in out</b> Integer);
<b>end</b>  Simple_Task;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Здесь описание спецификации объекта задачи <tt>Anonimous_Task</tt> содержит
описание единственного входа <tt>Start</tt>, который не имеет ни одного параметра.


<!---
<p align="JUSTIFY">
Далее следует описание перечислимого типа <tt>Level</tt>,
который используется при описании входа <tt>Request</tt>,
в спецификации типа задачи <tt>Simple_Task</tt>.
--->


<p align="JUSTIFY">
Спецификация типа задачи <tt>Simple_Task</tt> содержит описания двух входов.

Вход <tt>Read</tt> имеет один "<tt><b>out</b></tt>"-параметр <tt>Value</tt>
типа <tt>Integer</tt>.

Описание входа <tt>Request</tt> имеет один "<tt><b>in out</b></tt>"-параметр <tt>Item</tt>
типа <tt>Integer</tt> и использует указание дискретного типа индекса
(перечислимый тип <tt>Level</tt>)
представляя, таким образом, целое семейство входов.




<p><h4><a name="s15.2.3">15.2.3 Простое принятие обращений к входам</a></h4>



<p align="JUSTIFY">
Для организации взаимодействия задач,
кроме описаний входов, в спецификации задачи-сервера,
тело задачи-сервера должно содержать инструкции принятия рандеву,
которые описывают действия, выполняемые задачей-сервером
в случае вызова рандеву соответствующими входами задачи-сервера.


<p align="JUSTIFY">
Для описания инструкций принятия рандеву используется зарезервированное слово <tt><b>accept</b></tt>,
при этом следует учесть, что инструкции принятия рандеву не могут располагаться
в подпрограммах, вызываемых в теле задачи,
и не могут быть вложены в другие инструкции принятия рандеву
этого же тела задачи.

Таким образом, тело задачи может содержать инструкции принятия рандеву
только для тех входов, которые указываются в спецификации задачи.


<p align="JUSTIFY">
Рассмотрим схематические тела задач,
демонстрирующие примеры описания инструкций принятия рандеву
(тела задач соответствуют спецификациям задач,
которые были показаны при обсуждении описания входов):


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>task body</b>  Anonimous_Task  <b>is</b>
<b>begin</b>
    <b>accept</b> Start;
    . . .
<b>end</b> Anonimous_Task;


<b>task body</b> Simple_Task <b>is</b>
<b>begin</b>
    . . .
    <b>accept</b> Read (Value: <b>out</b> Integer) <b>do</b>
        Value := Some_Value;
    <b>end</b> Read;
    . . .
    <b>accept</b> Request (Low) (Item: <b>in out</b> Integer) <b>do</b>
        Some_Low_Item := Item;
        . . .
        Item := Some_Low_Item;
    <b>end</b> Request;

    <b>accept</b> Request (Middle) (Item: <b>in out</b> Integer) <b>do</b>
        Some_Middle_Item := Item;
        . . .
        Item := Some_Middle_Item;
    <b>end</b> Request;

    <b>accept</b> Request (Hight) (Item: <b>in out</b> Integer) <b>do</b>
        Some_Hight_Item := Item;
        . . .
        Item := Some_Hight_Item;
    <b>end</b> Request;
    . . .
<b>end</b>  Simple_Task;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Тело задачи <tt>Anonimous_Task</tt> содержит единственную инструкцию принятия рандеву,
которая соответствует входу <tt>Start</tt>, у которого нет параметров.

Данная инструкция принятия очень проста и не содержит никакой последовательности
инструкций, выполняемой в процессе принятия рандеву.


<p align="JUSTIFY">
Следует заметить, что инструкция принятия <tt><b>accept</b></tt>
может не содержать в себе последовательность инструкций,
даже когда соответствующий вход имеет параметры,
и наоборот, она может содержать последовательность каких-либо инструкций,
если параметры у соответствующего входа отсутствуют.

Кроме того, следует заметить, что последовательность инструкций,
вложенная в инструкцию принятия рандеву,
может содержать инструкцию выхода <tt><b>return</b></tt>
(это подобно использованию <tt><b>return</b></tt> в теле процедуры).

Также следует учесть, что формальные параметры,
указанные в инструкции принятия рандеву для соответствующего входа,
будут локальными для этой инструкции принятия.




<p align="JUSTIFY">
Тело задачи <tt>Simple_Task</tt> более интересно.

Первая инструкция принятия рандеву соответствует входу
<tt>Read</tt> с "<tt><b>out</b></tt>"-параметром <tt>Value</tt>.

Внутри этой инструкции принятия рандеву
параметру <tt>Value</tt> присваивается значение переменной <tt>Some_Value</tt>
(предполагается, что эта и другие переменные были где-либо описаны).


<p align="JUSTIFY">
Далее следуют три инструкции принятия рандеву, образующие "семейство".

Все они соответствуют описанию входа <tt>Request</tt>,
в спецификации задачи <tt>Simple_Task</tt>,
которая описывалась с указанием типа <tt>Level</tt>, значения которого
(<tt>Low</tt>, <tt>Middle</tt> и <tt>Hight</tt>)
используются в качестве индекса.



<p><h4><a name="s15.2.4">15.2.4 Простой вызов входа</a></h4>



<p align="JUSTIFY">
Задача-клиент осуществляет вызов входа задачи-сервера,
идентифицируя как объект задачи-сервера, так и необходимый вход задачи-сервера.

Для демонстрации описаний простых вызовов входов задачи-сервера, заданных в
задаче-клиенте, рассмотрим следующий пример: 




<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>declare</b>
    . . .
    Simple_Task_Variable : Simple_Task;
    . . .
    Read_Value    : Integer;
    Request_Item  : Integer;
    . . .
<b>begin</b>
    . . .
    Anonimous_Task.Start;
    . . .
    Simple_Task_Variable.Read (Read_Value);
    Simple_Task_Variable.Request (Middle) (Request_Item);
    . . .
<b>end</b>;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Как видно из этого примера, простые вызовы входов очень похожи на вызовы процедур.

Вызов входа может иметь параметры,
значения которых могут передаваться в обоих направлениях
между задачей-клиентом и задачей-сервером.


<p align="JUSTIFY">
При непосредственной обработке рандеву
происходит передача любых параметров "<tt><b>in</b></tt>" и "<tt><b>in out</b></tt>" в задачу-сервер.

Затем задача-сервер выполняет последовательность инструкций,
которая расположена внутри инструкции принятия
(если такая последовательность существует),
а задача-клиент остается в приостановленном состоянии.

Далее, после завершения этой последовательности инструкций,
происходит передача любых параметров "<tt><b>out</b></tt>" и "<tt><b>in out</b></tt>"
к задаче-клиенту, и обработка рандеву завершается.

После этого обе задачи продолжают свое выполнение независимо друг от друга.


<p align="JUSTIFY">
Рассмотрим простой пример программы,
которая использует свойства рандеву для своеобразного управления
последовательностью запуска задач.

Следует заметить, что стандарт Ады никак не определяет последовательность
запуска множества задач одной и той же программы,
и язык не предоставляет стандартных средств
для непосредственного управления процессом активации множества задач.

Следовательно, разные реализации Ада-систем могут
использовать различные правила для определения последовательности
активации множества задач, а это означает, что последовательность
активации множества задач одной и той же программы может отличаться
в различных реализациях Ада-системы.

Однако, используя свойства рандеву, можно программно осуществлять взамную синхронизацию
выполнения задач.

Таким образом, выполнение тела задачи может быть приостановлено в самом начале задачи,
то есть до того, как задача начнет выполнять свою непосредственную работу.

Такой способ использования рандеву демонстрируется в следующем примере программы:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b>  Ada.Text_IO;

<b>procedure</b> Multitasking_Demo_3 <b>is</b>

    -- спецификация типа задачи
    <b>task type</b> Simple_Task (Message: Character; How_Many: Positive) <b>is</b>
    
        <b>entry</b> Start; -- этот вход будет использоваться для реального
                     -- запуска задачи на выполнение
    
    <b>end</b> Simple_Task;


    -- тело задачи
    <b>task body</b> Simple_Task <b>is</b>
    <b>begin</b> -- для Simple_Task

        <b>accept</b> Start;  -- в этом месте, выполнение задачи будет заблокировано
                       -- до поступления вызова входа

        <b>for</b> Count <b>in</b> 1..How_Many <b>loop</b>
            Ada.Text_IO.Put_Line("Hello from Simple_Task " &amp; Message);
            <b>delay</b> 0.1;
        <b>end loop</b>;

    <b>end</b> Simple_Task;


    -- переменные задачного типа
    Simple_Task_A: Simple_Task(Message =&gt; 'A', How_Many =&gt; 5);
    Simple_Task_B: Simple_Task(Message =&gt; 'B', How_Many =&gt; 3);

<b>begin</b> -- для Multitasking_Demo_3

    -- в момент, когда управление достигнет этой точки,
    -- все задачи начнут свое выполнение,
    -- но будут приостановлены в инструкциях принятия рандеву

    Simple_Task_B.Start;
    Simple_Task_A.Start;

<b>end</b> Multitasking_Demo_3;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Как видно из исходного текста этого примера,
здесь описаны два объекта задач: <tt>Simple_Task_A</tt> и <tt>Simple_Task_B</tt>.

Каждая задача имеет вход <tt>Start</tt>,
который используется для управления очередностью запуска задач.

В результате сначала запускается задача <tt>Simple_Task_B</tt>, а затем <tt>Simple_Task_A</tt>.


<p align="JUSTIFY">
Рассмотрим еще один простой пример программы,
в котором демонстрируется использование входов с параметрами.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Demo <b>is</b>

    X : Duration := Duration(Random(100));
    Y : Duration;

    <b>task</b> Single_Entry <b>is</b>
        <b>entry</b> Handshake(Me_Wait : <b>in</b> Duration; You_Wait : <b>out</b> Duration);
    <b>end task</b>;

    <b>task body</b> Single_Entry <b>is</b>
        A : Duration := Duration(Random(100));
        B : Duration;
    <b>begin</b>
        <b>Delay</b> A;

        <b>accept</b> Handshake(Me_Wait : <b>in</b> Duration; You_Wait : <b>out</b> Duration) <b>do</b>
            B := Me_Wait;
            You_Wait := A;
        <b>end</b> Handshake;

        <b>Delay</b> B;
    <b>end</b>;

<b>begin</b>
    <b>Delay</b>(X);
    Handshake(X, Y);
    <b>Delay</b>(Y);
<b>end</b> Demo;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В этом примере, две задачи обмениваются значением длительности задержки выполнения,
используя для этого рандеву на входе <tt>Handshake</tt> задачи <tt>Single_Entry</tt>.


<p align="JUSTIFY">
Следует заметить, что возможна ситуация, когда задача ожидает рандеву,
но при этом нет ни одной задачи, с которой она может его осуществить.

В этом случае задача будет аварийно завершена с исключением <i>Tasking_Error</i>.





<p><h4><a name="s15.2.5">15.2.5 Селекция принятия рандеву</a></h4>


<p align="JUSTIFY">
Предположим, что нам необходима задача-сервер, которая будет обслуживать множество
задач-клиентов.

Предположим также, что задача-сервер должна иметь не один, а целое множество
входов для предоставления различных сервисов задачам-клиентам,
а один из входов будет указывать на необходимость завершения работы задачи-сервера,
то есть задача-сервер должна выполняться до тех пор,
пока не получит явной команды на завершение своей работы.


<p align="JUSTIFY">
Вполне резонно на основе полученных ранее сведений,
попытаться реализовать что-нибудь подобное следующему:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>task</b> Server_Task <b>is</b>
    <b>entry</b> Service_1 <i>[ параметры для Service_1 ]</i> ;
    <b>entry</b> Service_2 <i>[ параметры для Service_2 ]</i> ;
    . . .
    <b>entry</b> Service_N <i>[ параметры для Service_N ]</i> ;

    <b>entry</b> Stop;
<b>end task</b>;

<b>task body</b> Server_Task <b>is</b>
    . . .
<b>begin</b>
    <b>loop</b>
        <b>accept</b> Service_1 <i>[ параметры для Service_1 ]</i> <b>do</b>
            . . .
        <b>end</b> Service_1;

        <b>accept</b> Service_2 <i>[ параметры для Service_2 ]</i> <b>do</b>
            . . .
        <b>end</b> Service_2;

        . . .

        <b>accept</b> Service_N <i>[ параметры для Service_N ]</i> <b>do</b>
            . . .
        <b>end</b> Service_N;

        <b>accept</b> Stop <b>do</b>
            <b>exit</b> ;     -- выход из цикла, и, следовательно,
                       -- завершение задачи
        <b>end</b> Stop;
    <b>end loop</b>;
<b>end</b> Server_Task;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Однако при внимательном рассмотрении логики работы данного примера оказывается,
что задача-сервер будет блокироваться (приостанавливаться) в каждой инструкции принятия рандеву,
ожидая поступления вызова на соответствующем входе от какой-либо задачи-клиента.

Причем, находясь в состоянии ожидания,
задача-сервер никак не будет реагировать
на наличие и поступление вызовов от задач-клиентов на других входах.

Следовательно, для ситуаций, которые подобны показанной в этом примере, необходима возможность
селекции (или выбора) принятия рандеву на входах задачи-сервера.


<p align="JUSTIFY">
Для обеспечения селекции принятия рандеву,
Ада предоставляет различные варианты инструкции отбора с ожиданием,
которая задается с помощью зарезервированного слова <tt><b>select</b></tt>.

Использование инструкции отбора в теле задачи-сервера позволяет:

<ul>
<li>
одновременно ожидать более одного рандеву
<li>
выполнять таймаут, если за указанный период времени
не поступило ни одного вызова рандеву
<li>
осуществлять рандеву только в случае наличия вызова рандеву
<li>
завершать выполнение задачи при отсутствии задач-клиентов,
которые потенциально могут вызвать рандеву
</ul>


<p align="JUSTIFY">
Рассмотрим следующий пример использования инструкции отбора в теле задачи-сервера:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>task</b> Server_Task <b>is</b>
    <b>entry</b> Service_1 <i>[ параметры для Service_1 ]</i> ;
    <b>entry</b> Service_2 <i>[ параметры для Service_2 ]</i> ;
    . . .
    <b>entry</b> Service_N <i>[ параметры для Service_N ]</i> ;

    <b>entry</b> Stop;
<b>end task</b>;

<b>task body</b> Server_Task <b>is</b>
    . . .
<b>begin</b>
    <b>loop</b>
        <b>select</b>
            <b>accept</b> Service_1 <i>[ параметры для Service_1 ]</i> <b>do</b>
                . . .
            <b>end</b> Service_1;
            . . .     -- дополнительная последовательность инструкций,
                      -- которая выполняется после принятия рандеву
                      -- на входе Service_1
        <b>or</b>
            <b>accept</b> Service_2 <i>[ параметры для Service_2 ]</i> <b>do</b>
                . . .
            <b>end</b> Service_2;
        <b>or</b>
            . . .
        <b>or</b>
            <b>accept</b> Service_N <i>[ параметры для Service_N ]</i> <b>do</b>
                . . .
            <b>end</b> Service_N;
        <b>or</b>
            <b>accept</b> Stop;
            <b>exit</b> ;     -- выход из цикла, и, следовательно,
                       -- завершение задачи
        <b>end select</b>
    <b>end loop</b>;
<b>end</b> Server_Task;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Как видно из исходного текста примера,
инструкции принятия рандеву указываются как альтернативы выбора инструкции отбора
(это несколько подобно инструкции <tt><b>case</b></tt>).


<p align="JUSTIFY">
В данном случае при выполнении инструкции отбора
задача-сервер циклически "опрашивает" свои входы на наличие вызова рандеву от задач-клиентов
(без блокировки в состоянии ожидания вызова рандеву на каком-либо входе).

Опрос продолжается до тех пор, пока не будет обнаружен вызов рандеву на каком-либо входе,
который соответствует одной из перечисленных инструкций принятия рандеву.

После обнаружения вызова выполняется соответствующая альтернатива
(примечание: завершение обработки альтернативы приводит к завершению инструкции отбора).


<p align="JUSTIFY">
Следует обратить внимание, что если в процессе опроса, выполняемого инструкцией отбора,
одновременно появятся два и более вызова рандеву,
то инструкция отбора выберет для обработки только один из поступивших вызовов,
причем правила выбора альтернативы для такого случая не определяются стандартом.

Другими словами, когда инструкция отбора помещена в тело цикла,
при одновременном появлении двух и более вызовов рандеву,
инструкция отбора будет осуществлять обработку только одного вызова рандеву
в течение одного "витка" цикла,
а одновременно поступившие вызовы рандеву будут поставлены в очередь
порядок которой не определяется стандартом.


<p align="JUSTIFY">
В данном примере
интересную ситуацию представляет альтернатива принятия рандеву на входе <tt>Stop</tt>.

В этом случае происходит выход из бесконечного цикла выполнения инструкции отбора,
что, в свою очередь, приводит к завершению работы задачи-сервера.

Если в процессе завершения работы задачи-сервера поступит вызов рандеву на какой-либо из
входов <tt>Service_1</tt> - <tt>Service_N</tt>,
то задача-клиент, вызывающая рандеву, скорее всего получит исключение <i>Tasking_Error</i>.


Недостаток такого подхода состоит в том, что 
завершение работы задачи-сервера требует явного указания вызова рандеву
на входе <tt>Stop</tt>.


<p align="JUSTIFY">
Чтобы избавиться от необходимости явного указания вызова рандеву
на входе <tt>Stop</tt>, можно использовать инструкцию отбора,
в которой указывается альтернатива завершения задачи:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>task</b> Server_Task <b>is</b>
    <b>entry</b> Service_1 <i>[ параметры для Service_1 ]</i> ;
    . . .
    <b>entry</b> Service_N <i>[ параметры для Service_N ]</i> ;
<b>end task</b>;

<b>task body</b> Server_Task <b>is</b>
    . . .
<b>begin</b>
    <b>loop</b>
        <b>select</b>
            <b>accept</b> Service_1 <i>[ параметры для Service_1 ]</i> <b>do</b>
                . . .
            <b>end</b> Service_1;
        <b>or</b>
            . . .
        <b>or</b>
            <b>accept</b> Service_N <i>[ параметры для Service_N ]</i> <b>do</b>
                . . .
            <b>end</b> Service_N;
        <b>or</b>
            <b>terminate</b>;   -- завершение работы задачи
        <b>end select</b>
    <b>end loop</b>;
<b>end</b> Server_Task;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В таком случае альтернатива завершения задачи будет завершать работу задачи-сервера,
когда отсутствуют вызовы рандеву
и отсутствуют задачи-клиенты, которые потенциально способны вызвать рандеву с задачей-сервером.

Таким образом, для
завершения работы задачи-сервера не требуется явного выполнения никаких специальных действий.

Следует также учитывать, что альтернатива завершения работы задачи должна указываться последней
в списке альтернатив инструкции отбора.




<p align="JUSTIFY">
Может возникнуть ситуация, когда необходимо,
чтобы в процессе ожидания вызова рандеву от задач-клиентов
задача-сервер выполняла какие-либо дополнительные действия.

Для этого можно использовать инструкцию отбора,
в которой вместо альтернативы завершения работы
используется раздел <tt><b>else</b></tt>.

Использование такого варианта инструкции отбора может иметь следующий вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>loop</b>
    <b>select</b>
        <b>accept</b> Service_1 <i>[ параметры для Service_1 ]</i> <b>do</b>
            . . .
        <b>end</b> Service_1;
    <b>or</b>
        . . .
    <b>or</b>
        <b>accept</b> Service_N <i>[ параметры для Service_N ]</i> <b>do</b>
            . . .
        <b>end</b> Service_N;
    <b>else</b>
        . . .       -- последовательность инструкций, которая выполняется
                    -- если нет ни одного вызова рандеву
    <b>end select</b>
<b>end loop</b>;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Подобным образом последовательность инструкций, указанная в разделе <tt><b>else</b></tt>,
может быть использована для организации "фоновой" работы задачи-сервера.


<p align="JUSTIFY">
Еще одной разновидностью инструкции отбора служит инструкция отбора,
использующая альтернативу таймаута (или задержки).

Такая инструкция отбора может иметь следующий вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>loop</b>
    <b>select</b>
        <b>accept</b> Service_1 <i>[ параметры для Service_1 ]</i> <b>do</b>
            . . .
        <b>end</b> Service_1;
    <b>or</b>
        . . .
    <b>or</b>
        <b>accept</b> Service_N <i>[ параметры для Service_N ]</i> <b>do</b>
            . . .
        <b>end</b> Service_N;
    <b>or</b>
        <b>delay</b> 1.0;
        . . .       -- последовательность инструкций таймаута,
                    -- которая выполняется в случае
                    -- когда нет ни одного вызова рандеву
                    -- в течение одной секунды
    <b>end select</b>
<b>end loop</b>;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Подход, демонстрируемый этим примером,
удобно использовать для организации "сторожевого таймера",
сигнализирующего о некорректной работе программного обеспечения.


<p align="JUSTIFY">
Альтернатива таймаута, указанная в инструкций отбора,
позволяет задаче-серверу выполнять определенную последовательность действий,
если в течение указанного интервала времени не поступило ни одного вызова рандеву.

Интервал времени указывается в альтернативах таймаута
аналогично интервалу времени в инструкциях задержки выполнения
(необходимо однако заметить, что несмотря на внешнее подобие,
не следует путать альтернативы таймаута инструкций отбора с инструкциями задержки выполнения).

Таким образом, может быть указан относительный (как в примере выше) или абсолютный интервал времени.

Если выражение, указывающее относительный интервал времени, имеет отрицательное или нулевое значение
или значение абсолютного интервала времени оценивается как прошедшее,
то альтернатива таймаута инструкции отбора может быть расценена как эквивалент
раздела <tt><b>else</b></tt>.


<p align="JUSTIFY">
В одной инструкции отбора, допускается наличие более одной альтернативы таймаута.

При этом, будет обрабатываться та альтернатива таймаута,
которая имеет наименьший интервал времени.

Отметим также, что в пределах одной инструкции отбора
не допускается совместное использование различных альтернатив таймаута
для которых одновременно заданы относительные и абсолютные интервалы времени.


<p align="JUSTIFY">
При применении инструкций отбора следует учитывать,
что использование альтернативы завершения работы задачи (<tt><b>terminate</b></tt>),
альтернативы таймаута (<tt><b>delay</b></tt>) и раздела <tt><b>else</b></tt>
в пределах одной инструкции отбора
является взаимно исключающим.

Кроме того, любой вариант инструкции отбора обязан содержать хотя бы одну альтернативу выбора,
в которой указана инструкция принятия рандеву <tt><b>accept</b></tt>.


<p align="JUSTIFY">
Еще одной особенностью инструкций отбора
является опциональная возможность указания дополнительной проверки какого-либо условия
для альтернатив принятия рандеву, завершения работы задачи и таймаута.

Для указания такой проверки используется конструкция вида:
"<tt><b>when</b> <i>условие</i> =&gt;</tt>", -
где проверяемое <tt><i>условие</i></tt> описывается с помощью логического выражения,
результат вычисления которого должен иметь значение
предопределенного логического типа <tt>Standard.Boolean</tt>.

Как правило, такую проверку назвают защитной или охранной (<i>guard</i>),
а ее использование может иметь следующий вид:




<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>declare</b>
    . . .
    Service_1_Counter : Integer;
    . . .
    Service_N_Counter : Integer;
    . . .
<b>begin</b>
    . . .
    <b>loop</b>
        . . .
        <b>select</b>
            <b>when</b> (Service_1_Counter &gt; 0) =&gt;
                <b>accept</b> Service_1 <i>[ параметры для Service_1 ]</i> <b>do</b>
                    . . .
                <b>end</b> Service_1;
        <b>or</b>
            . . .
        <b>or</b>
            <b>when</b> (Service_N_Counter &gt; 100) =&gt;
                <b>accept</b> Service_N <i>[ параметры для Service_N ]</i> <b>do</b>
                    . . .
                <b>end</b> Service_N;
        <b>end select</b>
    <b>end loop</b>;
    . . .
<b>end</b>;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Вычисление значения логического выражения осуществляется
в начале выполнения инструкции отбора.

Если результат вычисления выражения <tt>True</tt>,
то соответствующая альтернатива имеет право быть выбранной
инструкцией отбора, если результат <tt>False</tt>, альтернатива выбрана не будет,
причем даже в том случае, когда какая-либо задача-клиент
осуществила вызов соответствующего входа и ждет обслуживания.

Следует также учесть, что в случае, когда проверки условий используются
для всех альтернатив инструкции отбора,
и результаты проверок всех условий имеют значение <tt>False</tt>,
это приведет к возбуждению исключения <i>Program_Error</i>.


<p align="JUSTIFY">
Альтернативу отбора можно назвать открытой,
когда для нее не указана дополнительная проверка условия
или когда значение результата проверки условия есть <tt>True</tt>.

В противном случае альтернативу отбора можно назвать закрытой.



<p><h4><a name="s15.2.6">15.2.6 Селекция вызова рандеву</a></h4>


<p align="JUSTIFY">
Инструкции отбора <tt><b>select</b></tt>
могут использоваться не только для селекции принятия рандеву в задаче-сервере,
но и для селекции вызова рандеву в задаче-клиенте.

В подобных случаях
различные формы инструкций отбора позволяют задаче-клиенту выполнять
условный вызов рандеву, временный вызов рандеву или асинхронную передачу управления.


<p align="JUSTIFY">
Рассмотрим простой пример инструкции отбора
для выполнения условного вызова рандеву на входе <tt>Service_1</tt>
задачи-сервера <tt>Server_Task</tt>:
 


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>select</b>
    Server_Task.Service_1 <i>[ параметры для Service_1 ]</i> ;
<b>else</b>
    Put_Line ("Server_Task is busy!");
<b>end select</b>;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В этом случае, если задача-сервер <tt>Server_Task</tt> не готова к немедленному приему
рандеву на входе <tt>Service_1</tt>, то вызов рандеву будет отменен
и выполнится последовательность инструкций в разделе  <tt><b>else</b></tt>,
которая выводит сообщение "<tt>Server_Task is busy!</tt>".


<p align="JUSTIFY">
Инструкция отбора, предназначенная для условного вызова рандеву на входе задачи-сервера,
как правило, используется для многократного обращения к задаче-серверу.

Таким образом, общий вид ее применения может быть следующм:
 


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>loop</b>

    <b>select</b>
        Server_Task.Service_1 <i>[ параметры для Service_1 ]</i> ;
        . . .   -- опциональная последовательность инструкций,
        <b>exit</b>;   -- выполняемая после рандеву
    <b>else</b>
        . . .   -- последовательность инструкций,
                -- выполняемая в случае невозможности
                -- осуществления рандеву
    <b>end select</b>;

<b>end loop</b>;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Инструкция отбора для временного вызова рандеву позволяет
задавать ожидание принятия рандеву на входе
задачи-сервера в течение заданного интервала времени.

Пример такой инструкции
для выполнения временного вызова рандеву на входе <tt>Service_1</tt>
задачи-сервера <tt>Server_Task</tt>
может иметь следующий вид:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>select</b>
    Server_Task.Service_1 <i>[ параметры для Service_1 ]</i> ;
<b>or</b>
    <b>delay</b> 5.0;
    Put_Line ("Server_Task has been busy for 5 seconds!");
<b>end select</b>;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В данном случае, если в течение указанного интервала времени
(здесь задан относительный интервал времени длительностью 5 секунд)
задача-сервер <tt>Server_Task</tt> не приняла рандеву на входе <tt>Service_1</tt>,
то вызов рандеву отменяется
и выполняется последовательность инструкций,
заданная альтернативой задержки,
которая в этом примере выдаст сообщение "<tt>Server_Task has been busy for 5 seconds!</tt>".


<p align="JUSTIFY">
Вместо относительного интервала
может быть указано абсолютное значение времени:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>select</b>
    Server_Task.Service_1 <i>[ параметры для Service_1 ]</i> ;
<b>or</b>
    <b>delay until</b> Christmas;
    Put_Line ("Server_Task has been busy for ages!");
<b>end select</b>;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Следует заметить, что когда, в случае относительного интервала времени,
указанная задержка будет иметь нулевое или отрицательное значение,
или  заданное абсолютное значение времени расценивается как прошедшее,
выполнение инструкции будет осуществляться подобно выполнению инструкции отбора
для условного вызова рандеву.


<p align="JUSTIFY">
Инструкция отбора для временного вызова рандеву удобно использовать в качестве сторожевого таймера.

Таким образом, ее общий вид может быть следующм:
 


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>loop</b>

    <b>select</b>
        Server_Task.Service_1 <i>[ параметры для Service_1 ]</i> ;
        . . .   -- опциональная последовательность инструкций,
        <b>exit</b>;   -- выполняемая после рандеву
    <b>or</b>
        <b>delay</b> <i>интервал_времени</i>

        . . .   -- последовательность инструкций,
                -- выполняемая в случае невозможности
                -- осуществления рандеву
    <b>end select</b>;

<b>end loop</b>;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Заметим, что вместо конструкции "<tt><b>delay</b> <i>интервал_времени</i></tt>",
задающей относительный интервал,
может быть использована конструкция "<tt><b>delay until</b> <i>интервал_времени</i></tt>",
которая указывает абсолютное значение времени.


<p align="JUSTIFY">
Инструкция отбора для асинхронной передачи управления
(введена стандартом Ada95)
позволяет задаче-клиенту продолжить выполнение какого-либо кода
в то время, когда вызов рандеву ожидает обслуживания.

Пример использования такой инструкции может иметь следующий вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>select</b>
    <b>delay</b> 5.0;
    Put_Line ("Server_Task is not serviced the Service_1 yet");
<b>then abort</b>
    Server_Task.Service_1 <i>[ параметры для Service_1 ]</i> ;
<b>end select</b>;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В данном случае начинается выполнение инструкций,
расположенных между "<tt><b>then abort</b></tt>" и "<tt><b>end select</b></tt>",
то есть вызов рандеву с задачей-сервером <tt>Server_Task</tt> на входе <tt>Service_1</tt>.


При этом, если истечение интервала времени
из инструкции <tt><b>delay</b></tt> (или <tt><b>delay until</b></tt>), 
расположенной после <tt><b>select</b></tt>,
произойдет раньше завершения выполнения <tt>Server_Task.Service_1</tt>,
то выполнение <tt>Server_Task.Service_1</tt> принудительно прерывается
и выполняется вывод сообщения "<tt>Server_Task is not serviced the Service_1 yet</tt>".


<p align="JUSTIFY">
Примечательно, что использование асинхронной передачи управления
не ограничено многозадачностью, например:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>select</b>
    <b>delay</b> 5.0;
    Put_Line ("So_Big_Calculation abandoned!");
<b>then abort</b>
    So_Big_Calculation;
<b>end select</b>;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В данном случае использование асинхронной передачи
позволяет прервать неопределенно долго выполняющуюся
или "зависшую" в бесконечном цикле процедуру <tt>So_Big_Calculation</tt>.


<p align="JUSTIFY">
При селекции вызова рандеву с помощью инструкций отбора
(для осуществления условного вызова рандеву,
временного вызова рандеву или асинхронной передачи управления)
следует помнить, что если вызванная задача уже завершена,
то выполнение инструкции отбора приведет к возбуждению исключению <i>Tasking_Error</i>.



<p><h4><a name="s15.2.7">15.2.7 Идентификация задач и атрибуты</a></h4>


<p align="JUSTIFY">
Каждая задача (объект) Ады имеет свой собственный уникальный идентификатор,
с помощью которого она может быть идентифицирована в других задачах.

Механизм, с помощью которого задача может получить свой уникальный идентификатор,
обеспечивается средствами стандартного пакета <i>Ada.Task_Identification</i>,
описанного в приложении <i>C</i> (<i>Annex C</i>) стандарта Ada95,
в котором указываются требования для системного программирования.


<p align="JUSTIFY">
Спецификация пакета <i>Ada.Task_Identification</i> имеет следующий вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Ada.Task_Identification <b>is</b>

    <b>type</b> Task_ID <b>is private</b>;
    Null_Task_ID : <b>constant</b> Task_ID;

    <b>function</b>  "=" (Left, Right : Task_ID) <b>return</b> Boolean;

    <b>function</b>  Image        (T : Task_ID) <b>return</b> String;
    <b>function</b>  Current_Task               <b>return</b> Task_ID;

    <b>procedure</b> Abort_Task   (T : <b>in out</b> Task_ID);

    <b>function</b>  Is_Terminated(T : Task_ID) <b>return</b> Boolean;
    <b>function</b>  Is_Callable  (T : Task_ID) <b>return</b> Boolean;

<b>private</b>

    . . .   -- Стандартом языка не определено

<b>end</b> Ada.Task_Identification;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Кроме этого пакета, в приложении <i>C</i> стандарта описываются атрибуты,
которые могут быть использованы для идентификации задач:


<p>
<dir><table width="80%">
<tr>
<td valign=TOP"><font size=1><tt>T<b>'<i>Identity</i></b></tt></font></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign=TOP"><font size=1>
где <tt>T</tt>: любая задача.<br>
Возвращает значение типа <tt>Task_ID</tt> которое уникально идентифицирует <tt>T</tt>.
</font></td>
</tr>

<tr>
<td valign=TOP"><font size=1><tt>E<b>'<i>Caller</i></b></tt></font></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign=TOP"><font size=1>
где <tt>E</tt>: имя любого входа задачи.<br>
Возвращает значение типа <tt>Task_ID</tt>, которое идентифицирует
обрабатываемую в текущий момент задачу, обратившуюся к входу задачи <tt>E</tt>.
Использование этого атрибута допустимо только внутри инструкции принятия (для задачи-сервера).
</font></td>
</tr>
</table></dir>


<p align="JUSTIFY">
При использовании этих средств следует учитывать,
что по истечении некоторого времени ничто не гарантирует
активность задачи или ее присутствие в области видимости.


<p align="JUSTIFY">
Кроме перечисленных средств идентификации,
при работе с задачами могут быть также использованы следующие атрибуты:


<p>
<dir><table width="80%">
<tr>
<td valign=TOP"><font size=1><tt>T<b>'<i>Callable</i></b></tt></font></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign=TOP"><font size=1>
Возвращает значение <tt>True</tt>, если задача <tt>T</tt> может быть вызвана.
</font></td>
</tr>

<tr>
<td valign=TOP"><font size=1><tt>T<b>'<i>Terminated</i></b></tt></font></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign=TOP"><font size=1>
Возвращает <tt>True</tt> если выполнение задачи <tt>T</tt> прекращено.
</font></td>
</tr>
</table></dir>


<p align="JUSTIFY">
Следует учесть, что <tt>T</tt> - это любая задача
а результат, возвращаемый этими атрибутами, имеет
предопределенный логический тип <tt>Standard.Boolean</tt>.


<p align="JUSTIFY">
Для входов (и семейств входов) задач определен атрибут <tt><b>'<i>Count</i></b></tt>.

Если <tt>E</tt> - имя любого входа задачи,
то <tt>E<b>'<i>Count</i></b></tt>
возвращает значение типа <tt>Universal_Integer</tt>,
показывающее число обращений к входу <tt>E</tt>,
которые находятся в очереди.

Исползование этого атрибута допустимо только внутри тела задачи
или внутри программного модуля, который расположен внутри тела задачи.


<p align="JUSTIFY">
Следует заметить, что не рекомендуется, чтобы алгоритм обработки
имел жесткую зависимость от значений атрибутов задач
<tt><b>'<i>Callable</i></b></tt> и <tt><b>'<i>Terminated</i></b></tt>,
а также атрибута <tt><b>'<i>Count</i></b></tt> для входов (и семейств входов).



<p><h4><a name="s15.2.8">15.2.8 Разделяемые (общие) переменные</a></h4>


<p align="JUSTIFY">
Ада позволяет задачам совместно использовать разделяемые (общие) переменные (объекты, ресурсы),
которые располагаются в общей памяти и могут быть необходимы
как для организации взаимодействия задач, так и для хранения каких-либо общих данных.

Следовательно, необходимо, чтобы такие переменные допускали возможность чтения/записи
из различных задач программы.


<p align="JUSTIFY">
Поскольку при выполнении программы возможны ситуации,
когда несколько задач пытаются получить доступ к одной и той же разделяемой переменной,
во избежание конфликтных ситуаций и поддержки общей корректности работы программы
необходима синхронизация доступа к разделяемым переменным.


Обеспечение синхронизации доступа к разделяемым переменным
представляет собой основополагающую проблему многозадачного (параллельного)
программирования, и называется взаимным исключением.


Решение этой проблемы основывается на том,
что в какой-либо момент времени
право на доступ к разделяемой переменной предоставляется только одной задаче.

Для обеспечения синхронизации доступа используются специальные программные (или аппаратные) средства:
семафоры, критические секции, мониторы и т.д.


<!---
<p align="JUSTIFY">
Управляемый доступ к разделяемым переменным, в Ada83, обеспечивался
за счет директивы компилятора <tt>Shared</tt>,
которая гарантировала непрерывность операций чтения/записи разделяемой переменной.

Однако, область применения этой директивы была достаточно ограничена
и она обладала целым рядом недостатков, например, она была не применима для
компонентов массива.


<p align="JUSTIFY">
В стандарте Ada95 директива <tt>Shared</tt> была заменена на две директивы:
<tt>Atomic</tt> и <tt>Volatile</tt>.
--->


<p align="JUSTIFY">
В стандарте Ada95 для указания разделяемых переменных
используются следующие директивы компилятора:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>pragma</b> Atomic            ( <i>Local_Name</i> );
<b>pragma</b> Atomic_Components ( <i>Local_Array_Name</i> );

<b>pragma</b> Volatile            ( <i>Local_Name</i> );
<b>pragma</b> Volatile_Components ( <i>Local_Array_Name</i> );
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Здесь <tt><i>Local_Name</i></tt> указывает локальное имя объекта или описание типа, а
<tt><i>Local_Array_Name</i></tt> указывает локальное имя объекта-массива или описание типа-массива.


<p align="JUSTIFY">
Директивы компилятора <tt>Atomic</tt> и <tt>Atomic_Components</tt> обеспечивают
непрерывность операций чтения/записи для всех указанных в них объектах.

Такие объекты называют атомарными (<i>atomic</i>),
а операции над ними выполняются только последовательно.


<p align="JUSTIFY">
Директивы компилятора <tt>Volatile</tt> и <tt>Volatile_Components</tt> обеспечивают
выполнение операций чтения/записи для всех указанных в них объектах непосредственно в памяти.
<!---
Директивы компилятора <tt>Volatile</tt> и <tt>Volatile_Components</tt> обеспечивают,
что выполнение операций чтения/записи для всех указанных в них объектах
будет выполняться непосредственно в памяти.
--->


<p align="JUSTIFY">
Примеры применения этих директив компилятора могут иметь следующий вид:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Array_Size  : Positive;
<b>pragma</b> Atomic   (Array_Size);
<b>pragma</b> Volatile (Array_Size);

Store_Array <b>is array</b> (1..Array_Size)  <b>of</b> Integer;
<b>pragma</b> Atomic_Components   (Store_Array);
<b>pragma</b> Volatile_Components (Store_Array);
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Разделяемые переменные и перечисленные для них директивы компилятора
могут быть использованы для организации:

<ul>
<li>взаимодействия задач
<li>взаимодействия Ада-программы с другими процессами
<li>управления устройствами из Ада-программ
</ul>


<p align="JUSTIFY">
Следует заметить, что описанные подобным образом разделяемые переменные
не должны использоваться для синхронизации взаимодействия задач,
для этого следует использовать средства механизма рандеву и/или защищенные объекты.




<p>
<h3><a name="s15.3">15.3 Защищенные модули (<i>protected units</i>)</a></h3>



<p><h4><a name="s15.3.1">15.3.1 Проблемы механизма рандеву</a></h4>


<p align="JUSTIFY">
Несмотря на обилие возможностей, предоставляемых моделью механизма рандеву Ada83,
который предусматривает развитый высокоуровневый подход для синхронизации задач,
позволяющий избежать многочисленные методологические сложности,
вызванные применением низкоуровневых примитивов, подобных семафорам и сигналам,
этот механизм обладает некоторыми недостатками.


<p align="JUSTIFY">
Представим себе классический пример,
когда необходимо обеспечить взаимодействие двух задач,
одна из которых выполняет чтение данных из какого-либо устройства,
а вторая - осуществляет обработку этих данных.

В литературе подобное взаимоотношение задач, как правило, называют "поставщик-потребитель".

Как мы уже знаем, механизм рандеву является одновременно как механизмом синхронизации,
так и механизмом межзадачного обмена данными.

Необходимость передачи данных между двумя задачами,
которые обычно выполняются асинхронно,
требует приостановки выполнения задач для осуществления "переговоров".

Следовательно, для эффективной организации
подобного взаимодействия необходима буферизация данных,
передаваемых от одной задачи к другой.

Обычным решением в этой ситуации является создание промежуточной задачи,
которая служит буфером и управляет потоком данных, а значит,
всегда доступна для рандеву с обоими задачами,
нуждающимися в обмене данными.

При этом следует учесть, что рандеву является относительно длительной операцией,
и необходимость наличия дополнительной задачи-буфера
приводит к неоправданному снижению производительности.


<p align="JUSTIFY">
Исходя из таких рассуждений, гораздо предпочтительнее выглядит возможность,
чтобы задача-производитель
(та задача, которая читает данные из устройства)
могла просто оставлять данные в какой-либо переменной для задачи-приемника
(та задача, которая обрабатывает принятые данные),
после чего задача-приемник могла бы так же просто эти данные прочитать.

Однако, обычная переменная для этой цели не подходит, поскольку необходимо
предотвратить модификацию содержимого переменной двумя одновременно выполняющимися задачами.


<p align="JUSTIFY">
Еще одним недостатком рандеву является то, что в некоторых ситуациях
может возникнуть инверсия абстракции, приводящая к замкнутой взаимной блокировке задач.

Кроме того, с методологической точки зрения,
идеология механизма рандеву строго ориентирована на управление
и находится вне новейших объектно-ориентированных подходов.


<p align="JUSTIFY">
Средством, которое позволяет организовать взаимно исключающий доступ к данным
из разных, одновременно выполняющихся задач,
являются защищенные модули,
которые были введены стандартом Ada95.

Характерной особенностью защищенных модулей является
обеспечение ими синхронизированного доступа к приватным данным,
однако в противоположность задачам,
которые являются активными сущностями, защищенные модули - пассивны.



<p><h4><a name="s15.3.2">15.3.2 Защищенные типы и объекты<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                                Защищенные подпрограммы</a></h4>


<p align="JUSTIFY">
Защищенные модули (типы и объекты) Ады инкапсулируют данные
и позволяют осуществлять доступ к ним с помощью защищенных подпрограмм
или защищенных входов.

Стандарт языка гарантирует,
что в результате выполнения кода таких подпрограмм и входов
изменение содержимого данных будет производиться в режиме взаимного исключения
без необходимости создания дополнительной задачи.


<p align="JUSTIFY">
Защищенный модуль может быть описан как защищенный тип
или как одиночный защищенный объект, что аналогично одиночной задаче.

В последнем случае предполагается, что защищенный объект имеет соответствующий анонимный тип.

Следует учитывать, что защищенный тип является лимитированным и, тем самым,
не обладает предопределенными операциями присваивания или сравнения.


<p align="JUSTIFY">
Подобно задаче или пакету, защищенный модуль имеет спецификацию и тело.

Спецификация описывает протокол доступа к защищенному модулю (интерфейс), и может содержать
спецификации процедур, функций и входов защищенного модуля.

Тело описывает детали реализации протокола доступа к данным защищенного модуля и, как правило,
содержит тела защищенных подпрограмм и входов.

Подобно задачам и записям, защищенный модуль может иметь дискриминанты
дискретного или ссылочного типа.



<p align="JUSTIFY">
В качестве простой иллюстрации рассмотрим пример следующго одиночного защищенного объекта:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

-- спецификация защищенного объекта
<b>protected</b> Variable <b>is</b>

    <b>function</b> Read <b>return</b> Item;
    <b>procedure</b> Write(New_Value : Item);

<b>private</b>
    Data : Item;

<b>end</b> Variable;

-- тело защищенного объекта
<b>protected body</b> Variable <b>is</b>

    <b>function</b> Read <b>return</b> Item <b>is</b>
    <b>begin</b>
        <b>return</b> Data;
    <b>end</b>;

    <b>procedure</b> Write (New_Value : Item) <b>is</b>
    <b>begin</b>
        Data := New_Value;
    <b>end</b>;

<b>end</b> Variable;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Защищенный объект <tt>Variable</tt> предоставляет управляемый доступ к
приватной переменной <tt>Data</tt> типа <tt>Item</tt>.

Функция <tt>Read</tt> позволяет читать,
а процедура <tt>Write</tt>  - обновлять текущее значение переменной <tt>Data</tt>.


<p align="JUSTIFY">
Защищаемые данные и данные о состоянии объекта
должны быть помещены в приватную часть спецификации.

Смысл этого заключается в том, что приватная часть не доступна клиенту непосредственно, а
наличие всей информации в интерфейсе защищенного объекта
необходимо компилятору для эффективного распределения памяти.


<p align="JUSTIFY">
Защищенные процедуры предусматривают взаимно исключающий доступ к данным
защищенного модуля по чтению и/или записи.

Защищенные функции предоставляют одновременный доступ к данным
защищенного модуля только по чтению,
что подразумевает одновременное выполнение множества вызовов функций.

Однако вызовы защищенных процедур и защищенных функций
остаются взаимно исключающими.

Порядок, в котором разные задачи ожидают выполнения защищенных процедур и защищенных функций,
стандартом не определяется.

Однако поддержка требований приложения <i>D</i> (<i>Annex D</i>) стандарта Ada95,
в котором указаны требования для систем реального времени,
позволяет сделать некоторые предположения о возможном порядке выполнения подпрограмм.


<p align="JUSTIFY">
Для обращения к защищенным подпрограммам используется традиционная точечная нотация:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

X := Variable.Read;
. . .
Variable.Write (New_Value =&gt; Y);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Внутри тела защищенного объекта допускается несколько подпрограмм, при этом
реализация Ада-системы будет гарантированно осуществлять вызовы подпрограмм
по принципу взаимного исключения (подобно монитору).




<p><h4><a name="s15.3.3">15.3.3 Защищенные входы и барьеры</a></h4>



<p align="JUSTIFY">
По аналогии со входами задач, защищенный модуль может иметь защищенные входы.

Действия, выполняемые при вызове защищенного входа, предусматриваются в его теле.

Защищенные входы подобны защищенным процедурам в том, что
они гарантируют взаимно исключающий доступ к данным защищенного модуля по чтению и/или записи.

Однако внутри тела защищенного модуля
защищенные входы предохраняются логическим выражением, которое называют барьером,
а результат вычисления этого логического выражения должен иметь предопределенный
логический тип <tt>Standard.Boolean</tt>.


<p align="JUSTIFY">
Если при вызове защищенного входа значение барьера есть <tt>False</tt>,
то выполнение вызывающей задачи приостанавливается до тех пор,
пока значение барьера не станет равным <tt>True</tt>
и внутри защищенного модуля будут отсутствовать активные задачи
(задачи, которые выполняют тело какого-либо защищенного входа или какой-либо защищенной подпрограммы).

Следовательно, вызов защищенного входа может быть использован для реализации
условной синхронизации.


<p align="JUSTIFY">
Можно заметить, что
существует строгая параллель между инструкцией принятия с охранным условием из тела задачи
и телом защищенного входа с барьерным условием для защищенного модуля.

При этом затраты времени на проверку барьерного условия для защищенного входа
значительно меньше, чем затраты времени на проверку охранного условия инструкции принятия.


<p align="JUSTIFY">
Хорошим примером решения упоминавшейся ранее проблемы "поставщик-потребитель"
служит реализации циклического буфера с помощью защищенного типа:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

-- спецификация защищенного типа
<b>protected type</b> Bounded_Buffer <b>is</b>

    <b>entry</b> Put(X: <b>in</b>     Item);
    <b>entry</b> Get(X:    <b>out</b> Item);

<b>private</b>
    A: Item_Array(1 .. Max);
    I, J: Integer <b>range</b> 1 .. Max := 1;
    Count: Integer <b>range</b> 0 .. Max := 0;

<b>end</b> Bounded_Buffer;

-- тело защищенного типа
<b>protected body</b> Bounded_Buffer <b>is</b>

    <b>entry</b> Put(X: <b>in</b> Item) <b>when</b> Count &lt; Max <b>is</b>
    <b>begin</b>
        A(I) := X;
        I := I <b>mod</b> Max + 1; Count := Count + 1;
    <b>end</b> Put;

    <b>entry</b> Get(X: <b>out</b> Item) <b>when</b> Count &gt; 0 <b>is</b>
    <b>begin</b>
        X := A(J);
        J := J <b>mod</b> Max + 1; Count := Count - 1;
    <b>end</b> Get;

<b>end</b> Bounded_Buffer;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Здесь предусмотрен циклический буфер, который позволяет сохранить до <tt>Max</tt>
значений типа <tt>Item</tt>.

Доступ обеспечивается с помощью входов <tt>Put</tt> и <tt>Get</tt>.

Описание объекта (переменной) защищенного типа осуществляется традиционным образом,
а для обращения к защищенным входам, как и для обращения к защищенным подпрограммам,
используется точечная нотация:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>declare</b>
    . . .
    My_Buffer: Bounded_Buffer;
    . . .
<b>begin</b>
    . . .
    My_Buffer.Put(X);
    . . .
<b>end</b>;
</pre></dir>
</td></tr></table>




<p align="JUSTIFY">
Заметим, что так же как и в случае вызова входа задачи,
вызывающая задача может использовать инструкции отбора
для временного или условного вызова защищенного входа.
Например:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>
. . .
<b>select</b>
    My_Buffer.Get(X);
    . . .               -- список инструкций
<b>else</b>
    . . .               -- список инструкций
<b>end select</b>;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Поведение защищенного типа контролируется барьерами.

При вызове входа защищенного объекта
выполняется проверка соответствующего барьера.

Если значение барьера <tt>False</tt>,
то вызов помещается в очередь,
подобно тому, как это происходит при вызове входа задачи.

При описании переменной <tt>My_Buffer</tt>
буфер - пуст, и, таким образом, барьер для входа <tt>Put</tt> имеет значение <tt>True</tt>,
а для входа <tt>Get</tt> - <tt>False</tt>.

Следовательно, будет выполняться только вызов <tt>Put</tt>, а вызов <tt>Get</tt>
будет отправлен в очередь.


<p align="JUSTIFY">
В конце выполнения тела входа (или тела процедуры) защищенного объекта
производится вычисление значений всех барьеров, у которых есть задачи, ожидающие в очереди,
разрешая, таким образом, обработку обращений к входам,
которые ранее были помещены в очередь в результате того, что
значение барьера было вычислено как <tt>False</tt>.

Таким образом, после завершения обработки первого же вызова <tt>Put</tt>,
если вызов <tt>Get</tt> уже находится в очереди,
то значение барьера для <tt>Get</tt> будет вычислено заново,
и это позволит обслужить ожидающий в очереди вызов <tt>Get</tt>.


<p align="JUSTIFY">
Важно понять, что здесь нет задачи, которая непосредственно ассоциирована с самим буфером.

Вычисление барьеров эффективно выполняется системой времени выполнения.

Барьеры вычисляются когда вход вызывается впервые
и когда происходит что-либо, что может повлиять на состояние барьера
ожидающей задачи.


<p align="JUSTIFY">
Таким образом, барьеры вычисляются заново только в конце выполнения
тела защищенного входа или тела защищенной процедуры,
но не в конце выполнения тела защищенной функции,
поскольку вызов функции не может повлиять на внутреннее состояние защищенного объекта
и, как следствие, не может изменить значения барьеров.

Такие правила гарантируют эффективность реализации защищенного объекта.


<p align="JUSTIFY">
Следует обратить особое внимание на то,
что барьер может ссылаться на значение глобальной переменной.

Значение такой переменной может быть изменено независимо
от вызова защищенной процедуры или защищенного входа объекта
(например, она может быть изменена какой-либо другой задачей или
даже в результате вызова защищенной функции),
и такие изменения не могут быть обработаны достаточно точно.

Поскольку подобные случаи требуют дополнительной внимательности,
то рекомендуется воздерживаться от использования глобальных переменных в барьерах.


<p align="JUSTIFY">
Необходимо понимать, что защитный механизм барьеров
налагается на обычное взаимное исключение защищенной конструкции,
предоставляя, таким образом, два различных уровня защиты.

В конце защищенного вызова
уже находящиеся в очереди обращения к входам
(чей барьер теперь имеет значение <tt>True</tt>)
более приоритетны по сравнению с другими защищенными вызовами.

С другой стороны,
пока защищенный объект занят обработкой текущего вызова
(а также любых уже готовых к обработке, но находящихся в очереди вызовов),
проверка значения барьера, для вновь поступившего вызова входа,
не может быть даже произведена.


<p align="JUSTIFY">
Это имеет одно важное следствие:
если состояние защищенного объекта изменяется, и существует задача,
которая ожидает новое состояние защищенного объекта,
то такая задача получает доступ к ресурсу.

При этом гарантируется, что состояние ресурса,
когда такая задача получает к нему доступ,
будет таким же самым,
как и в момент принятия решения о предоставлении этой задаче доступа к ресурсу.

Таким образом, полностью предотвращаются
неудовлетворенные опросы и состязание задач за ресурс.


<p align="JUSTIFY">
Основопологающая концепция защищенных объектов подобна мониторам.

Они являются пассивными конструкциями с синхронизацией,
предусматриваемой системой времени выполнения языка.

Однако защищенные объекты,
по сравнению с мониторами,
обладают большим преимуществом:
протокол взаимодействия с защищенными объектами описывается барьерными условиями
(в правильности которых достаточно легко убедиться),
а не низкоуровневыми и неструктурируемыми сигналами, используемыми в мониторах
(как в языке Modula).


<p align="JUSTIFY">
Другими словами, защищенные объекты обладают существенными преимуществами
высокоуровневых охранных условий модели рандеву,
но без дополнительных издержек по производительности,
обусловленных наличием дополнительной задачи.


<p align="JUSTIFY">
Защищенные модули позволяют осуществлять очень эффективную реализацию
различных сигнальных объектов, семафоров и подобных им парадигм:




<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

-- спецификация защищенного типа
<b>protected type</b> Counting_Semaphore (Start_Count : Integer := 1) <b>is</b>

    <b>entry</b> Secure;
    <b>procedure</b> Release;
    <b>function</b> Count <b>return</b> Integer;

<b>private</b>
    Current_Count : Integer := Start_Count;

<b>end</b>;


-- тело защищенного типа
<b>protected body</b> Counting_Semaphore <b>is</b>

    <b>entry</b> Secure <b>when</b> Current_Count &gt; 0 <b>is</b>
    <b>begin</b>
        Current_Count := Current_Count - 1;
    <b>end</b>;

    <b>procedure</b> Release <b>is</b>
    <b>begin</b>
        Current_Count := Current_Count + 1;
    <b>end</b>;

    <b>function</b> Count <b>return</b> Integer <b>is</b>
    <b>begin</b>
        <b>return</b> Current_Count;
    <b>end</b>;

<b>end</b> Counting_Semaphore;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Особенностью этого примера является то, что <tt>Start_Count</tt> является дискриминантом.

При вызове входа <tt>Secure</tt> опрашивается барьер этого входа.

Если результат опроса барьера есть <tt>False</tt>, то задача ставится в очередь,
а ожидание обслуживания становится <tt>True</tt>.


<p align="JUSTIFY">
Следует заметить, что этот пример демонстрирует реализацию общего семафора Дейкстры
(<i>Dijkstra</i>), где вход <tt>Secure</tt> и процедура <tt>Release</tt>
соответствуют операциям <tt>P</tt> и <tt>V</tt> (<i>Dutch Passeren</i> и <i>Vrijmaken</i>),
а функция <tt>Count</tt> возвращает текущее значение семафора.


<p align="JUSTIFY">
Очевидно, что в очереди обращения к защищенному входу
может одновременно находиться несколько задач.

Так же как и в случае с очередями к входам задач,
очереди к входам защищенных объектов обслуживаются в порядке поступления вызовов
(<i>FIFO - First-In-First-Out</i>).

Однако в случае поддержки требований приложения <i>D</i> (<i>Annex D</i>) стандарта Ada95,
в котором указываются требования для систем реального времени,
допускается использование другой дисциплины обслуживания очереди.


<p align="JUSTIFY">
Для защищенного типа можно описать семейство защищенных входов;
это делается заданием дискретного типа в спецификации входа,
подобно описанию семейств входов для задач.

Однако, в отличие от задач,
нет необходимости предусматривать самостоятельно выделенное тело для входа,
принадлежащего такому семейству.

Индекс семейства может использовать барьер,
ассоциируемый с таким входом
(обычно такой индекс используется в качестве индекса массива значений логического типа
<tt>Standard.Boolean</tt>).




<p><h4><a name="s15.3.4">15.3.4 Особенности программирования защищенных входов и подпрограмм</a></h4>



<p align="JUSTIFY">
При программировании действий, выполняемых в телах защищенных входов и подпрограмм,
следует учитывать, что время выполнения кода внутри защищенного объекта
должно быть настолько кратким, насколько это возможно.

Это вызвано тем, что пока выполняется этот код,
выполнение других задач, которые пытаются получить доступ к данным защищенного объекта,
будет задержано.

Ада не позволяет принудительно ограничивать максимальную продолжительность
выполнения кода во время защищенных действий,
хотя и пытается убедиться в том, что задача не будет заблокирована
в состоянии бесконечного ожидания доступа к защищенной процедуре или функции.

Потенциальными причинами возникновения подобных ситуаций
могут быть попытки выполнения (внутри защищенных действий):

<ul>
<li>инструкции отбора (<tt><b>select</b></tt>)
<li>инструкции принятия (<tt><b>accept</b></tt>)
<li>инструкции вызова входа
<li>инструкции задержки выполнения
<li>создание или активация задачи
</ul>


<p align="JUSTIFY">
Перечисленные действия называют потенциально блокирующими.

Кроме того, обращение к любому потенциально блокирующему действию
является также потенциально блокирующим.


<p align="JUSTIFY">
Напомним, что при выполнении вызова защищенного входа
в процессе обработки вызова защищенной процедуры или защищенного входа
осуществляется проверка барьера.

Если барьер закрыт (условие барьера имеет значение <tt>False</tt>),
то вызов ставится в очередь.

После завершения выполнения тела защищенной процедуры или защищенного входа
значения всех барьеров вычисляются заново
и, возможно, происходит выполнение тела входа.

Вычисление значения барьера для входа и постановка вызова входа в очередь
являются защищенными операциями ассоциированного с ними защищенного объекта,
и они могут быть названы защищенными действиями.


<p align="JUSTIFY">
Любое исключение, возбужденное в процессе вычисления значения барьера для входа,
приводит к возбуждению исключения <i>Program_Error</i> во всех задачах,
которые в текущий момент находятся в очереди ожидания
обслуживания вызова входа защищенного объекта.




<p><h4><a name="s15.3.5">15.3.5 Атрибуты входов защищенных объектов</a></h4>


<p align="JUSTIFY">
Входы защищенных объектов имеют атрибуты,
назначение которых подобно назначению атрибутов для входов задач:


<p>
<dir><table width="80%">
<tr>
<td valign=TOP"><font size=1><tt>E<b>'<i>Caller</i></b></tt></font></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign=TOP"><font size=1>
Возвращает значение типа <tt>Task_ID</tt>, которое идентифицирует
обрабатываемую в текущий момент задачу, обратившуюся на вход защищенного объекта <tt>E</tt>.
Использование этого атрибута допустимо только внутри тела входа (для защищенного объекта).
</font></td>
</tr>

<tr>
<td valign=TOP"><font size=1><tt>E<b>'<i>Count</i></b></tt></font></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign=TOP"><font size=1>
Возвращает значение типа <tt>Universal_Integer</tt>,
показывающее число обращений на входе <tt>E</tt>,
которые находятся в очереди.
</font></td>
</tr>
</table></dir>


<p align="JUSTIFY">
Здесь, подразумевается, что <tt>E</tt> - это имя любого входа защищенного объекта.

Так же как и в случае задач, при использовании этих средств следует учитывать,
что по истечении некоторого времени
ничто не гарантирует активность задачи или ее присутствие в области видимости.





<p>
<h3><a name="s15.4">15.4 Перенаправление <tt><b>requeue</b></tt></a></h3>


<p><h4><a name="s15.4.1">15.4.1 Проблема предпочтительного управления</a></h4>


<p align="JUSTIFY">
В процессе создания некоторого сложного сервера или планировщика
для определения правил очередности предоставления сервиса,
предусмотренного телом защищенного входа или телом инструкции принятия,
достаточно часто бывает необходимо полагаться на текущие значения различных управляющих элементов.

Такие управляющие элементы могут быть локальными для сервера
и зависимыми только от внутреннего состояния сервера,
они также могут являться атрибутами клиента или управляющей задачи,
либо они могут быть глобальными для всей системы в целом.

Кроме того, состояние управляющих элементов может изменяться с момента вызова входа
(защищенного модуля или задачи)
до момента начала обработки обращения к входу.


<p align="JUSTIFY">
В самых простых случаях,
когда управляющие элементы известны вызывающему клиенту,
не изменяются с момента вызова
и имеют сравнительно небольшой дискретный диапазон значений,
использование возможностей предоставляемых семействами точек входа Ada83,
может оказаться вполне достаточным.

Однако в тех ситуациях, когда для построения логики обслуживания какого-либо сервиса,
необходимо использование внутри сервера предпочтительного управления (<i>preference control</i>),
такие ограничения, как правило, не соблюдаются.


<p align="JUSTIFY">
Примером сервера, который нуждается в использовании предпочтительного управления,
может служить сервер, управляющий распределением каких-либо ресурсов.

После вызова со стороны клиента подобный сервер должен начать обработку запроса только в том случае,
если этот запрос может быть удовлетворен немедленно.

В противном случае
запрос от клиента должен быть отправлен в очередь
для более позднего обслуживания.


<p align="JUSTIFY">
Идея альтернативного решения заключается в том, что
клиент должен сначала опросить состояние сервера,
а затем инициировать вызов с параметрами,
которые соответствуют текущему состоянию сервера
(предположительно, используя определенный индекс в семействе входов).

Однако недостатком такого решения является потенциальная возможность
возникновения состязания задач за ресурс,
поскольку не гарантируется атомарность операций.

Иными словами, между двумя обращениями клиента 
может произойти обслуживание запроса от другого клиента,
что приведет к изменению внутреннего состояния сервера.

Таким образом, при последующем обращении клиента
может быть утеряна достоверность параметров,
значения которых основаны на предыдущем запросе.


<p align="JUSTIFY">
В других случаях логика работы сервера нуждается в том,
чтобы обслуживание какого-либо сервиса было разделено на два (или более) этапа,
и чтобы задача-клиент, запрашивающая сервис,
была приостановлена после выполнения первого этапа до тех пор,
пока какие-либо условия не позволят выполнить последующий этап обработки.

В таком случае необходимы последовательные вызовы двух (или более) входов,
но попытки запрограммировать это в Ada83, как правило, затруднительны,
поскольку в этом случае также теряется атомарность операций
и требуется обеспечить видимость внутреннего протокола работы сервера,
что нежелательно.



<p><h4><a name="s15.4.2">15.4.2 Инструкция перенаправления очереди <tt><b>requeue</b></tt></a></h4>


<p align="JUSTIFY">
С целью поддержки построения необходимых управляющих алгоритмов,
позволяющих разделить обработку какого-либо сервиса на несколько (два и более) этапов
и для организации предпочтительного управления,
стандарт Ada95 ввел единственную и простую инструкцию перенаправления очереди
<tt><b>requeue</b></tt>.


<p align="JUSTIFY">
Инструкция перенаправления очереди используется для завершения инструкции принятия рандеву
(<tt><b>accept</b></tt>) или тела защищенного входа
при необходимости перенаправления соответствующего вызова клиента от одного входа
задачи или защищенного модуля
к другому входу (или даже к тому же самому входу).

Общий вид этой инструкции следующий:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>requeue</b>  <i>имя_входа</i> <i>[</i> <b>with abort</b> <i>]</i> ;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Для того чтобы сервер получил доступ к параметрам вызова,
нет необходимости возобновлять обработку вызова
и требовать от клиента инициирование вызова на другм входе,
основываясь на результатах первого вызова.

С помощью инструкции перенаправления <tt><b>requeue</b></tt>,
можно просто переслать вызов клиента в очередь другого входа.


<p align="JUSTIFY">
В случае вызова защищенного входа
исключительный доступ обеспечивается на протяжении периода проверки параметров
и выполнения перенаправления.

В случае тела инструкции принятия рандеву (<tt><b>accept</b></tt>),
задача-сервер управляет своим собственным состоянием,
и в данном случае атомарность также обеспечивается,
так как она может отвергнуть принятие любого промежуточного вызова.


<p align="JUSTIFY">
Инструкция перенаправления <tt><b>requeue</b></tt> предназначена для обработки двух основных
ситуаций:


<ul>
<li>
После начала выполнения инструкции принятия <tt><b>accept</b></tt> или тела защищенного входа,
может быть определено, что запрос не может быть удовлетворен немедленно.

Взамен, существует необходимость перенаправлять вызывающего клиента
до тех пор, пока его запрос/вызов не сможет быть обработан.
<li>
В качестве альтернативы,
часть запроса клиента может быть обработана немедленно,
но могут существовать дополнительные шаги, которые должны быть выполнены несколько позже.
</ul>


<p align="JUSTIFY">
В обоих случаях,
инструкция принятия <tt><b>accept</b></tt> или тело защищенного входа,
нуждается в передаче управления.

Таким образом, могут быть обработаны запросы от других клиентов
или выполнена какая-либо другая обработка.

Инструкция перенаправления <tt><b>requeue</b></tt>
позволяет разделить обработку оригинального запроса/вызова
на два (и более) этапа.


<p align="JUSTIFY">
Чтобы продемонстрировать логику работы и использования этой инструкции,
рассмотрим пример широковещательного сигнала (или события).

Задачи приостанавливаются для ожидания некоторого события,
а после того как оно происходит,
все приостановленные задачи продолжают свое выполнение, а событие очищается.

Сложность состоит в том, как предотвратить от попадания в ожидание задачи
которые вызвали операцию ожидания после того как событие произошло,
но до того как событие очищено.

Другими словами, мы должны очистить событие только после того как новые задачи
продолжат свое выполнение.

Нам позволяет запрограммировать такое предпочтительное управление
инструкция перенаправления <tt><b>requeue</b></tt>:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>protected</b> Event <b>is</b>

    <b>entry</b> Wait;
    <b>entry</b> Signal;

<b>private</b>
    <b>entry</b> Reset;
    Occurred: Boolean := False;

<b>end</b> Event;

<b>protected body</b> Event <b>is</b>

    <b>entry</b> Wait <b>when</b> Occurred <b>is</b>
    <b>begin</b>
        <b>null</b>;                   -- пустое тело!
    <b>end</b> Wait;

    <b>entry</b> Signal <b>when</b> True <b>is</b>   -- барьер всегда True
    <b>begin</b>
        <b>if</b> Wait<b>'<i>Count</i></b> &gt; 0 <b>then</b>
            Occurred := True;
            <b>requeue</b> Reset;
        <b>end if</b>;
    <b>end</b> Signal;

    <b>entry</b> Reset <b>when</b> Wait<b>'<i>Count</i></b> = 0 <b>is</b>
    <b>begin</b>
        Occurred := False;
    <b>end</b> Reset;

<b>end</b> Event;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Задачи указывают на то, что они желают ждать событие, выполняя вызов:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Event.Wait;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
а возникновение события индицируется тем, что какая-либо задача выполняет вызов:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Event.Signal;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
после чего, все приостановленные в ожидании события задачи
продолжат свое выполнение и событие очистится.

Таким образом, последующие вызовы входа <tt>Wait</tt> работают корректно.


<p align="JUSTIFY">
Логическая переменная <tt>Occurred</tt> обычно имеет значение <tt>False</tt>.

Она имеет значение <tt>True</tt> только тогда,
когда задачи возобновляют свое выполнение после приостановки в ожидании события.

Вход <tt>Wait</tt> существует, но фактически не имеет тела.

Таким образом, вызывающие задачи приостанавливают свое выполнение
в его очереди, ожидая того, что переменная <tt>Occurred</tt>
получит значение <tt>True</tt>.


<p align="JUSTIFY">
Особый интерес представляет вход <tt>Signal</tt>.

Значение его барьера постоянно и всегда равно <tt>True</tt>,
таким образом, он всегда открыт для обработки.

Если нет задач ожидающих событие (нет задач вызвавших вход <tt>Wait</tt>),
то его вызов просто ничего не делает.

С другой стороны, при наличии задач ожидающих событие,
он должен позволить им продолжить выполнение, причем так,
чтобы ни одна новая задача не попала в очередь ожидания события,
после чего, он должен сбросить флаг, чтобы восстановить управление.

Он выполняет это перенаправляя себя на вход <tt>Reset</tt>
(с помощью инструкции перенаправления <tt><b>requeue</b></tt>)
после установки флага <tt>Occurred</tt> в значение <tt>True</tt>,
для индикации появления события.


<p align="JUSTIFY">
Семантика инструкции перенаправления <tt><b>requeue</b></tt>
подобна тому, что описано при рассмотрении алгоритма работы <tt>Signal</tt>.

Однако, помните, что в конце обработки тела входа или защищенной процедуры
осуществляется повторное вычисление состояний тех барьерных условий
в очереди которых находятся задачи, приостановленные в ожидании обслуживания.

В этом случае, действительно существуют задачи
находящиеся в очереди входа <tt>Wait</tt>,
и существует задача в очереди входа <tt>Reset</tt>
(та задача которая перед эти вызвала вход <tt>Signal</tt>).

Барьер для <tt>Wait</tt> теперь имеет значение <tt>True</tt>,
а барьер для <tt>Reset</tt>, естественно, <tt>False</tt>,
поскольку очередь задач на входе <tt>Wait</tt> не пуста.

Таким образом, ожидающая задача способна выполнить тело входа <tt>Wait</tt>
(которое фактически ничего не делает),
после чего опять осуществляется повторное вычисление значений барьеров.

Этот процесс повторяется до тех пор,
пока все приостановленные в ожидании задачи не возобновят свое выполнение
и значение барьера для <tt>Reset</tt> не получит значение <tt>True</tt>.

Оригинальная задача, которая вызвала сигнал,
теперь выполняет тело входа <tt>Reset</tt>,
сбрасывая флаг <tt>Occurred</tt> в значение <tt>False</tt>,
возвращая всю систему в исходное состояние еще раз.

Теперь, защищенный объект (как единое целое) полностью освобожден,
поскольку нет ни одной ожидающей задачи, ни на одном барьере.


<p align="JUSTIFY">
Следует обратить внимание на то, что если какие-либо задачи
пытаются вызвать <tt>Wait</tt> или <tt>Signal</tt>,
когда происходит обработка всего выше описанного процесса,
то эти задачи будут заблокированы,
поскольку защищенный объект, как единое целое, будет находиться в занятом состоянии.

Это иллюстрирует два уровня защиты и является смысловой основой
отсутствия возможности появления состязания задач за ресурс.


<p align="JUSTIFY">
Другим следствием двухуровневой защиты является то, что
все будет работать надежно даже в случае таких сложностей как
временные и условные вызовы и принудительное завершение (<i>abort</i>).

Можно заметить, что это несколько противоположно использованию атрибута
<tt><b>'<i>Count</i></b></tt> для входов задач,
который не может быть использован при временных вызовах.


<p align="JUSTIFY">
Следует сделать небольшое замечание о том, что вход <tt>Reset</tt> описан в приватной части
защищенного объекта, и, следовательно, не может быть вызван извне.

Ada95 позволяет задачам также иметь приватную часть, содержащую приватные входы.


<p align="JUSTIFY">
Следует заметить, что показанный выше пример был приведен только в качестве демонстрации.

Внимательный читатель должен заметить, что
проверка условия внутри <tt>Signal</tt> не является строго необходимой.

Без этой проверки, вызвавшая задача будет просто
всегда осуществлять перенаправление <tt><b>requeue</b></tt>
и немедленно продолжать вторую часть обработки,
при отсутствии ожидающих задач.

Однако это условие делает описание более ясным и чистым.

Еще более внимательный читатель может заметить, что мы можем запрограммировать этот пример
на Ada95 вовсе без использования инструкции перенаправления <tt><b>requeue</b></tt>.


<p align="JUSTIFY">
Как видно из общего вида инструкции перенаправления <tt><b>requeue</b></tt>,
она может быть указана с принудительным завершением "<tt><b>with abort</b></tt>".

В Ada83, после начала рандеву,
вызывающий клиент не обладал возможностью отменить свой запрос
(таймаут мог быть получен только если запрос не был принят в обработку задачей-сервером).

Такое поведение весьма обосновано.

После того как сервер начал обработку запроса,
он находится в неустойчивом состоянии,
и асинхронное удаление вызывающего клиента
может нарушить внутренние структуры данных сервера.

В дополнение,
при наличии параметров переданных по ссылке,
сервер, принимающий вызов, должен быть способен получить доступ к данным вызывающего клиента
(таким как данные в стеке).

При исчезновении вызывающего клиента, это может привести к "висячим" ссылкам
и последующему краху работы программы.


<p align="JUSTIFY">
Однако, в некоторых случаях,
откладывание аннулирования вызова невозможно.

В частности,
когда значение таймаута необходимо использовать для контроля за общим временем обращения,
которое также включает время непосредственной обработки вызова,
а не только время ожидания принятия вызова.

В дополнение к асинхронной передаче управления Ada95,
подобная ситуация может возникнуть когда вызывающий клиент
"прерван" и должен изменить последовательность своего выполнения как можно быстрее.


<p align="JUSTIFY">
Поскольку не существует единственно возможного наилучшего решения сразу для всех приложений,
и поскольку отсутствует легкий обходной путь,
то использование инструкции перенаправления (<tt><b>requeue</b></tt>)
с принудительным завершением (<tt><b>with abort</b></tt>)
предоставляет программисту возможность выбора для его приложения
наиболее подходящего механизма.

В основном,
когда допускается аннулирование вызова в процессе перенаправления,
сервер будет сохранять состояние своих внутренних структур данных
перед началом выполнения инструкции перенаправления с принудительным завершением,
после чего, если вызывающий клиент будет удален из следующей очереди,
то сервер сможет нормально продолжить свою работу.

Когда это не возможно,
или когда не требуется аннулирование вызова в процессе перенаправления,
будет достаточно использования простого перенаправления,
и вызывающий клиент будет удерживаться до полного завершения обработки запроса.


<p align="JUSTIFY">
Инструкция перенаправления <tt><b>requeue</b></tt>
позволяет перенаправить вызывающего клиента в очередь
того же самого или какого-либо другого входа.

При этом, вызывающий клиент не обязан заботиться о таком перенаправлении
и даже о фактическом количестве необходимых для удовлетворения его запроса этапов обработки,
которые вообще могут быть не видимыми извне защищенного типа или типа задачи.

Использование такого эффекта,
предоставляет гибкие возможности построения сервера со сложной внутренней архитектурой
и простым, однозначным для клиента, интерфейсом.


<p align="JUSTIFY">
В процессе выполнения перенаправления,
не происходит никаких переопределений параметров.

Вместо этого, значения параметров прямо переносятся в новый вызов.

Если был предусмотрен новый список параметров,
то он может включать ссылки на данные, которые локальны
для инструкции принятия <tt><b>accept</b></tt> или тела защищенного входа.

Это может вызвать некоторые трудности,
поскольку выполнение инструкции принятия <tt><b>accept</b></tt> или тела защищенного входа
будет завершено в результате выполнения инструкции перенаправления <tt><b>requeue</b></tt>
и локальные переменные будут, таким образом, деаллоцированы (<i>deallocated</i>).

Необходимо соответствие используемых подтипов между вновь вызываемым целевым входом
(если он имеет какие-либо параметры)
и текущим входом.

Это позволяет использовать то же самое представление
для нового множества параметров,
когда они передаются по значению (<i>by-copy</i>) или по ссылке (<i>by-reference</i>),
а также исключить необходимость размещения (<i>allocate</i>) нового пространства
для хранения параметров.

Необходимо отметить, что при выполнении перенаправления,
кроме передачи тех же самых параметров,
существует еще только одна возможность -
не передавать никаких параметров вовсе.


<p align="JUSTIFY">
В заключение,
как общий итог обсуждения инструкции перенаправления <tt><b>requeue</b></tt>
и логики ее использования,
сделаем следующие выводы:

<ul>
<li>
Инструкция перенаправления <tt><b>requeue</b></tt>
допустима внутри тела защищенного входа или внутри инструкции принятия рандеву <tt><b>accept</b></tt>.

Целевой вход (допустим тот же самый вход) может быть
в той же самой задаче или том же защищенном объекте,
или другой задаче или другом защищенном объекте.

Возможно использование любых перечисленных комбинаций.
<li>
Любые фактические параметры оригинального вызова передаются к новому входу.

Следовательно, новый вход должен иметь такой же самый профиль параметров
или не иметь никаких параметров.
</ul>



<!---
<p><h4><a name="s15.4.3">15.4.3 </a></h4>


<p align="JUSTIFY">
Более реалистическим классическим примером является планировщик обращений к диску,
где вызывающая задача перенаправляется тогда, когда головка диска
находится в текущий момент времени не на требуемой дорожке.
--->



<p>
<h3><a name="s15.5">15.5 Цикл жизни задачи</a></h3>


<p align="JUSTIFY">
До сих пор, во всех примерах, мы подразумевали только то, что
создание задач осуществляется на этапе элаборации,
и никак не рассматривали,
что происходит с задачами в процессе их существования.

Однако, при построении сложных многозадачных программ,
необходимо понимание из чего состоит цикл жизни задачи, то есть,
как происходит создание, активация и завершение одной отдельно взятой задачи.


<!---
<p align="JUSTIFY">
Прежде чем непосредственно приступить к обсуждению цикла жизни задачи,
необходимо определить некоторые понятия, которые будут использоваться
при дальнейшем рассмотрении.


<p align="JUSTIFY">
Каждая задача имеет <i><b>владельца</b></i> (<i>master</i>),
которым может являться
задача, подпрограмма, инструкция блока или инструкция принятия <tt><b>accept</b></tt>,
содержащая описание объекта-задачи
(или, в некоторых случаях, ссылочного типа который ссылается на тип-задачи).

Таким образом, можно сказать, что концепция владельца относится к окружению какого-либо объекта.

Говорят, что задача <i><b>зависит</b></i> от своего владельца.


<p align="JUSTIFY">
Задачу, которая осуществляет выполнение владельца,
называют <i><b>ведущей</b></i> или <i><b>родительской</b></i> задачей (<i>parent task</i>).
--->


<!---
<p align="JUSTIFY">
Перед тем как прекратить выполнение владельца,
родительская задача ожидает завершение выполнения всех задач
которые зависят от этого владельца.


<p align="JUSTIFY">
Когда выполнение всех зависимых задач завершается или готово к завершению,
родительская задача продолжает свое выполнение.
--->




<p><h4><a name="s15.5.1">15.5.1 Создание задачи</a></h4>


<p align="JUSTIFY">
Напомним, что тип задачи может рассматриваться как шаблон для создания реальных объектов-задач.

Типы и объекты задач могут быть описаны в любой описательной части,
включая тело задачи.

Для любого типа задачи, спецификация и тело должны быть описаны вместе,
в одном и том же модуле (тело задачи, как правило, помещается в конце описательной части).


<p align="JUSTIFY">
Объект задачи может быть создан
в процессе элаборации описания какого-либо объекта, расположенного где-либо в описательной части,
или в процессе обработки аллокатора (выражение в виде "<tt><b>new</b> ...</tt>").

Все задачи, которые созданы в результате элаборации описаний объектов,
расположенных в одной описательной части (включая внутренние компоненты описываемых объектов),
активируются вместе.

Подобным образом, все задачи созданные в процессе обработки одиночного аллокатора,
также активируются вместе.


<p align="JUSTIFY">
Выполнение объекта-задачи имеет три основные фазы:

<ol>
<li>
<b><i>Активация</i></b> - элаборация описательной части тела задачи, если она есть
(локальные переменные для тела задачи создаются и инициализируются в процессе активации задачи).
<i>Активатор</i> идентифицирует задачу, которая создала и активировала задачу.

<li>
<b><i>Нормальное выполнение</i></b> - выполнение инструкций, видимых внутри тела задачи.

<li>
<b><i>Завершение</i></b> - выполнение любого кода завершения (<i>finalization</i>),
ассоциированного с любым объектом в описательной части задачи.
</ol>

<p align="JUSTIFY">
Вновь созданная задача находится в
<b><i>неактивированом</i></b> (<i>unactivated</i>) состоянии.

Затем, система времени выполнения осуществляет ассоциирование с этой задачей
потока управления (<i>thread of control</i>).

Если элаборация задачи терпит неудачу,
то задача сразу переходит в <b><i>прекращенное</i></b> (<i>terminated</i>) состояние.

В противном случае, задача переходит в <b><i>работоспособное</i></b> (<i>runnable</i>) состояние
и начинает выполнять код инструкций тела задачи.

Если этот код выполняет некоторые операции, которые блокируют выполнение задачи
(рандеву, защищенные операции, задержки выполнения...),
то задача переходит в <b><i>приостановленное</i></b> (<i>sleep</i>) состояние,
а затем возвращается обратно в <b><i>работоспособное</i></b> состояние.

Когда задача выполняет альтернативу завершения (<i>terminate alternative</i>)
или нормальным образом завершает свое выполнение,
она переходит в <b><i>прекращенное</i></b> (<i>terminated</i>) состояние.


<p align="JUSTIFY">
Задача индицирует свою готовность к началу завершения
выполнением инструкции <tt><b>end</b></tt>.

Кроме того, задача может начать процесс своего завершения
в результате необработанного исключения,
в результате выполнения инструкции отбора <tt><b>select</b></tt> с альтернативой завершения или
в случае выполнения инструкции принудительного завершения <tt><b>abort</b></tt>.

Задача, которая окончила свою работу называется
<b><i>завершенной</i></b> (<i>completed</i>) или <b><i>прекращенной</i></b> (<i>terminated</i>),
в зависимости от наличия активных задач которые от нее зависят.


<p align="JUSTIFY">
Каждая задача имеет <i><b>владельца</b></i> (<i>master</i>),
которым может являться
задача, подпрограмма, инструкция блока или инструкция принятия рандеву <tt><b>accept</b></tt>,
содержащая описание объекта-задачи
(или, в некоторых случаях, ссылочного типа который ссылается на тип-задачи).

Говорят, что задача <i><b>зависит</b></i> от своего владельца.


<p align="JUSTIFY">
Задачу, которая осуществляет выполнение владельца,
называют <i><b>ведущей</b></i> или <i><b>родительской</b></i> задачей (<i>parent task</i>).

Таким образом, для каждой задачи существует родительская задача от которой она также зависит.


<p align="JUSTIFY">
Приняты следующие правила:

<ul>
<li>
Если задача была описана как объект, то ее родительская задача - это та задача,
которая содержит описание объекта задачи.
<li>
Если задача была описана как часть аллокатора <tt><b>new</b></tt>,
то ее родительская задача - это та задача,
которая содержит соответствующее описание ссылочного типа.
</ul>


<p align="JUSTIFY">
Когда родительская задача создает новую, <b><i>дочернюю</i></b> задачу (<i>child task</i>),
ее выполнение приостанавливается на время активации ее дочерней задачи
(немедленно, если дочерняя задача создана аллокатором,
или после завершения процесса элаборации соответствующей описательной части).

Как только все дочерние задачи завершают свою активацию,
родительская задача и все ее дочерние задачи продолжают свое выполнение независимо.

Если задача, в процессе своей активации, создает другую задачу,
то, перед тем как продолжить свое выполнение,
она также должна ждать пока активируется ее дочерняя задача.


<p align="JUSTIFY">
Существует концептуальная задача, называемая <b><i>задачей окружения</i></b>
(<i>environment task</i>),
которая ответственна за элаборацию всей программы.

В общем случае, задача окружения - это поток управления операционной системы,
который осуществляет инициализацию системы времени выполнения
и выполняет головную подпрограмму Ады.

Перед вызовом головной подпрограммы Ада-программы,
задача окружения осуществляет элаборацию всех библиотечных модулей,
указанных в спецификаторе <tt><b>with</b></tt> головной подпрограммы.

В результате процесса элаборации
происходит создание и активация задач уровня библиотеки
до вызова головной подпрограммы Ада-программы.



<p><h4><a name="s15.5.2">15.5.2 Активация задачи</h4>


<p align="JUSTIFY">
Для процесса активации задач приняты следующие правла:


<ol>
<li>
Для статических задач, активация начинается немедленно после окончания процесса элаборации
описательной части в которой эти задачи описаны.

<li>
Первая инструкция, следующая за описательной частью, не будет выполняться до тех пор,
пока все созданные задачи не окончат свою активацию.

<li>
Задаче, перед выполнением своего тела,
не требуется ожидать активацию других задач, которые созданны одновременно с ней.

<li>
Задача может попытаться осуществить взаимодействие с другой задачей,
которая уже создана, но еще не активирована.

При этом, выполнение вызывающей задачи будет задержано
до тех пор, пока не произойдет взаимодействие.

<li>
Если объект-задачи описан в спецификации пакета, то он начнет свое выполнение
после окончания процесса элаборации описательной части тела пакета.

<li>
Динамические задачи активируются немедленно после завершения обработки
создавшего их аллокатора.

<li>
Задача, которая выполнила инструкцию,
ответственную за создание задач,
будет заблокирована до тех пор,
пока созданные задачи не окончат свою активацию.

<li>
Если в процессе элаборации описательной части возбуждено исключение,
то любая задача, созданная в процессе элаборации становится <b><i>прекращенной</i></b>
и никогда не активируется.

В виду того, что на этом этапе задача сама по себе не может обрабатывать исключения,
модель языка требует,
чтобы такую ситуацию обрабатывала родительская задача или владелец задачи,
поскольку будет возбуждено предопределенное исключение <i>Tasking_Error</i>.

  <ul>
    <li>
    В случае динамического создания задач,
    возбуждение исключения осуществляется после инструкции которая содержит аллокатор.
    
    Однако, если вызов аллокатора находится в описательной части
    (как часть инициализации объекта),
    то описательная часть, в результате неудачи, не выполняется, а 
    возбуждение исключения происходит в объемлющем блоке
    (или вызвавшей подпрограмме).
    <li>
    В случае статического создания задачи,
    возбуждение исключения осуществляется перед выполнением первой исполняемой инструкции,
    которая следует сразу после описательной части.
    
    Это исключение возбуждается после того как осуществлена активация всех созданных задач,
    вне зависимости от успешности их активации,
    и оно, в большинстве случаев, вызывается однократно.    
  </ul>

<li>
Атрибут задачи <tt><b>'<i>Callable</i></b></tt> возвращает значение <tt>True</tt>
только в случае, когда указанная задача не находится в состоянии
<b><i>завершенная</i></b> или <b><i>прекращенная</i></b>.

Любая задача находящаяся в <b><i>ненормальном</i></b> (<i>abnormal</i>) состоянии
является принудительно завершенной задачей.

Атрибут задачи <tt><b>'<i>Terminated</i></b></tt> возвращает значение <tt>True</tt>
когда указанная задача находится в <b><i>прекращенном</i></b> состоянии.
</ol>



<p><h4><a name="s15.5.3">15.5.3 Завершение задачи</a></h4>


<p align="JUSTIFY">
Перед выходом,
<b><i>владелец</i></b> (<i>master</i>) осуществляет выполнение конструкций,
которые включают очистку (<i>finalization</i>)
локальных объектов после их использования
(и после ожидания всех локальных задач).

Каждая задача зависит от одного владельца, или более:

<ul>
<li>
Если задача была создана в результате обработки аллокатора ссылочного типа,
то она зависит от каждого владельца,
который включает элаборацию описаний самого отдаленного предка
указанного ссылочного типа.

<li>
Если задача была создана в результате элаборации описания объекта,
то она зависит от каждого владельца,
который включает эту элаборацию.
</ul>


<p align="JUSTIFY">
Кроме того, если задача зависит от указанного владельца,
то считается, что она также зависит от задачи, которая выполняет этого владельца,
и (рекурсивно) от любого владельца такой задачи.


<p align="JUSTIFY">
В первую очередь, зависимая задача дожидается очистки (<i>finalization</i>) владельца.

Затем, осуществляется очистка
каждого объекта с таким же уровнем вложенности как и у очищаемого владельца,
если этот объект был успешно проинициализирован и до сих пор существует.

Примечательно, что любой объект, уровень вложенности которого глубже чем у владельца,
уже не должен существовать,
поскольку он должен был очиститься внутренним владельцем.

Таким образом, после выхода из владельца,
не очищенными остаются только те объекты,
уровень вложенности которых меньше чем у владельца.





<p>
<h3><a name="s15.6">15.6 Прерывания</a></h3>



<p align="JUSTIFY">
Ада позволяет программисту
ассоциировать определяемые пользователем обработчики прерываний
с некоторыми прерываниями системы.

Хотя обработчик прерываний может быть защищенной процедурой или входом задачи,
ассоциация с входом задачи, в настоящее время, считается устаревшим средством языка.

Таким образом, внимание будет сфокусировано на определяемых пользователем обработчиках прерываний
на основе защищенных процедур.


<p align="JUSTIFY">
Следует заметить, что в зависимости от решаемой задачи,
прерывания Ады могут ассоциироваться с внешними событиями,
которые могут являться как непосредственными аппаратными прерываниями,
так и определенными событиями используемой операционной системы.

В последнем случае, такие события, вне Ада-системы, могут носить название сигналов.



<p><h4><a name="s15.6.1">15.6.1 Модель прерываний Ады</a></h4>


<p align="JUSTIFY">
Стандарт описывает следующую модель прерывания:

<ul>
<li>
Прерывание представляет класс событий, которые детектируются оборудованием
или системным программным обеспечением.
<li>
<b><i>Появление</i></b> (<i>occurence</i>) прерывания
состоит из <b><i>генерации</i></b> (<i>generation</i>)
и <b><i>доставки</i></b> (<i>delivery</i>).
<li>
Генерация прерывания - это событие в оборудовании или системе,
которое делает прерывание доступным для программы.
<li>
Доставка прерывания - это действия, которые вызывают часть программы
(называемую <b><i>обработчиком</i></b> прерывания)
в ответ на появление прерывания.

Прерывание называют <b><i>ожидающим обслуживание</i></b> (<i>pending</i>),
когда оно находится между генерацией и доставкой прерывания.

Вызов обработчика происходит только после доставки каждого прерывания.
<li>
Пока происходит обработка прерывания, последующие прерывания от того же источника
<b><i>заблокированы</i></b>, то есть, предотвращается генерация всех последующих прерываний.

Будут ли утеряны заблокированные прерывания, обычно, зависит от устройства.
<li>
Некоторые прерывания <b><i>зарезервированы</i></b>.

Программист не может определить обработчик для зарезервированного прерывания.

Обычно, зарезервированные прерывания непосредственно обрабатываются
библиотекой времени выполнения Ады
(например, прерывание от часов, которое используется для реализации инструкций задержки).
<li>
Каждое не зарезервированное прерывание имеет обработчик по умолчанию,
который устанавливается библиотекой времени выполнения Ады.
</ul>



<p><h4><a name="s15.6.2">15.6.2 Защищенные процедуры обработки прерываний</a></h4>


<p align="JUSTIFY">
Ада предусматривает два стиля установки обработчиков прерываний:
<b><i>вложенный</i></b> (<i>nested</i>) и <b><i>не-вложенный</i></b> (<i>non-nested</i>).

При <b><i>вложенном</i></b> стиле,
обработчик прерываний в защищенном объекте устанавливается неявно
в момент появления данного защищенного объекта,
и после того как защищенный объект прекращает существовать,
происходит неявное восстановление старого обработчика прерывания.

При <b><i>не-вложенном</i></b> стиле,
обработчик прерываний устанавливается явным вызовом процедуры,
и старый обработчик прерывания может быть восстановлен только явно.


<p align="JUSTIFY">
Существует два способа определения устанавливаемого обработчика прерывания вложенного стиля,
в зависимости от используемой в защищенном описании директивы компилятора.


<p align="JUSTIFY">
В первом случае, устанавливаемый с использованием вложенного стиля обработчик прерывания,
идентифицируется последующей директивой компилятора <tt>Attach_Handler</tt>,
которая появляется в защищенном описании и имеет следующий вид:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>pragma</b> Attach_Handler (Handler, Interrupt);
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Здесь, <tt>Handler</tt> указывает имя защищенной процедуры без параметров,
которая описана в защищенном описании,
а <tt>Interrupt</tt> является выражением типа <tt>Interrupt_ID</tt>.

Защищенное описание должно выполняться на уровне библиотеки,
то есть, оно не может быть вложено в тело подпрограммы, тело задачи или инструкцию блока.

Однако, если защищенное описание описывает защищенный тип,
то индивидуальный защищенный объект этого типа может быть размещен в этих местах.

Динамическое размещение с помощью аллокатора <tt><b>new</b></tt> обладает большей гибкостью:
аллокация защищенного объекта с обработчиком прерывания устанавливает обработчик прерывания,
ассоциированный с этим защищенным объектом,
а деаллокация защищенного объекта восстанавливает ранее установленный обработчик.

Выражение типа <tt>Interrupt_ID</tt> не обязано быть статическим.

В частности, его значение может зависить от дискриминанта защищенного типа.
Например:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Nested_Handler_Example  <b>is</b>

    <b>protected type</b>  Device_Interface
            (Int_ID : Ada.Interrupts.Interrupt_ID)  <b>is</b>

        <b>procedure</b> Handler;
        <b>pragma</b> Attach_Handler (Handler, Int_ID);

<b>end</b> Nested_Handler_Example;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Во втором случае, устанавливаемый с использованием вложенного стиля обработчик прерывания,
идентифицируется последующей директивой компилятора <tt>Interrupt_Handler</tt>,
которая появляется в защищенном описании и имеет следующий вид:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>pragma</b> Interrupt_Handler (Handler, Interrupt);
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Здесь, также как и в первом случае,
<tt>Handler</tt> указывает имя защищенной процедуры без параметров,
которая описана в защищенном описании,
а <tt>Interrupt</tt> является выражением типа <tt>Interrupt_ID</tt>.


Как и в случае использования директивы <tt>Attach_Handler</tt>,
защищенное описание не может быть вложено в тело подпрограммы, тело задачи или инструкцию блока.

Кроме того, эта директива компилятора имеет одно дополнительное ограничение:
если защищенная процедура описана для защищенного типа,
то объекты этого типа также не могут быть расположены в этих местах.

Следовательно, они должны создаваться динамически, с помощью <tt><b>new</b></tt>.


<p><h4><a name="s15.6.3">15.6.3 Пакет <i>Ada.Interrupts</i></a></h4>


<p align="JUSTIFY">
<b><i>Не-вложенная</i></b> установка и удаление обработчиков прерываний
полагается на дополнительные средства стандартного пакета <i>Ada.Interrupts</i>
спецификация которого имеет следующий вид:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Ada.Interrupts <b>is</b>

    <b>type</b> Interrupt_ID <b>is</b> <u><i>Определяется_Реализацией</i></u>;
    <b>type</b> Parameterless_Handler <b>is access protected procedure</b>;

    <b>function</b> Is_Reserved (Interrupt : Interrupt_ID)
        <b>return</b> Boolean;

    <b>function</b> Is_Attached (Interrupt : Interrupt_ID)
        <b>return</b> Boolean;

    <b>function</b> Current_Handler (Interrupt : Interrupt_ID)
        <b>return</b> Parameterless_Handler;

    <b>procedure</b> Attach_Handler
       (New_Handler : <b>in</b>     Parameterless_Handler;
        Interrupt   : <b>in</b>     Interrupt_ID);

    <b>procedure</b> Exchange_Handler
       (Old_Handler : <b>in out</b> Parameterless_Handler;
        New_Handler : <b>in</b>     Parameterless_Handler;
        Interrupt   : <b>in </b>    Interrupt_ID);

    <b>procedure</b> Detach_Handler
       (Interrupt : <b>in</b>     Interrupt_ID);

    <b>function</b> Reference (Interrupt : Interrupt_ID)
        <b>return</b> System.Address;

<b>private</b>

    . . .   -- стандартом не определено

<b>end</b> Ada.Interrupts;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Процедура <tt>Attach_Handler</tt> используется для установки соответствующего обработчика прерывания,
переопределяя любой существующий обработчик (включая обработчик пользователя).

Если параметр <tt>New_Handler</tt> - <tt><b>null</b></tt>,
то осуществляется восстановление обработчика по умолчанию.

Если параметр <tt>New_Handler</tt> указывает защищенную процедуру
для которой не была применена директива компилятора <tt>Interrupt_Handler</tt>,
то возбуждается исключение <i>Programm_Error</i>.



<p><h4><a name="s15.5.4">15.5.4 Приоритеты</a></h4>


<p align="JUSTIFY">
Для установки приоритета защищенного объекта может быть использована директива компилятора
<tt>Interrupt_Priority</tt>, которая имеет следующий вид:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>pragma</b> Interrupt_Priority ( <i>expression</i> );
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Отсутствие выражения <tt><i>expression</i></tt> воспринимается как установка
максимального системного приоритета (<tt>Interrupt_Priority<b>'<i>Last</i></b></tt>).

Пока обрабатываются операции этого защищенного объекта,
прерывания с равным или низшим приоритетом будут заблокированы.

Во избежание возникновения ситуации инверсии приоритетов,
любая задача,
вызывающая операции этого защищенного объекта,
должна устанавливать свой приоритет
в приоритет этого защищенного объекта на время выполнения операции,
отражая срочность завершения операции.

Благодаря этому прерывания становятся не блокируемыми.

Любой обработчик прерывания
обрабатывается с приоритетом своего защищенного объекта,
который может быть выше чем приоритет прерывания,
если этот же обработчик защищенного объекта обрабатывает более одного вида прерывания.

В дополнение к этому, для динамического изменения приоритера,
может быть использована процедура <tt>Set_Priority</tt>,
расположенная в пакете <i>Ada.Dynamic_Priorities</i>.








<!--- footer --->




<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>




</blockquote>
</body>
</html>

