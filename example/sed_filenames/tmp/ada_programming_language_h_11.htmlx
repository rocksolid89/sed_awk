<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<title>Адское программирование.</title>
</head>


<body BGCOLOR="FFFFFF">
<basefont size=3>
<blockquote>

<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>



<!--- header --->



<h2><a name="s11">11. Организация ввода/вывода</a></h2>

<p align="JUSTIFY">
В отличие от своего прародителя Паскаля, Ада не содержит жестко встроенных средств ввода/вывода.

Вместо этого, для обеспечения поддержки ввода/вывода, Ада предусматривает простую,
но эффективную коллекцию стандартных пакетов,
средства которых концептуально подобны средствам ввода/вывода большинства
современных расширений Паскаля.

Преимуществом такого решения является то, что стандартно предопределенные пакеты ввода/вывода,
при необходимости, могут быть заменены.

Таким образом, высокопроизводительные приложения или системы использующие специфическое оборудование
могут не использовать большинство стандартно предлагаемых средств ввода/вывода непосредственно
(при этом следует учитывать, что может быть уменьшена или вовсе утрачена переносимость
конечных программ).

В подобных случаях, стандартные средства ввода/вывода помогают формировать
однородный базис для построения эффективной подсистемы файлового обмена.


<p align="JUSTIFY">
Средства ввода/вывода Ады, определяемые стандартом Ada83,
обеспечивают возможность работы с текстовыми и двоичными данными.

Стандарт Ada95 расширил эти средства возможностью использования
гетерогенных потоков.


<p align="JUSTIFY">
Прежде чем приступить к непосредственному обсуждению,
необходимо заметить, что использование средств ввода/вывода Ады
может показаться сначала достаточно не привычным.

Причина такой непривычности заключается в том, что природа строгой типизации данных Ады
накладывает свой отпечаток и на средства ввода/вывода,
а это значит, что  весь ввод/вывод в Аде также подвержен строгой типизации данных.




<p>
<h3><a name="s11.1">11.1 Текстовый ввод/вывод</a></h3>

<p align="JUSTIFY">
Заметим, что хотя средства поддержки текстового ввода/вывода Ады
не рассматривались до настоящего момента,
некоторые ранее рассмотренные примеры уже применяли эти средства,
осуществляя ввод/вывод с использованием стандартного устройства ввода/вывода.

Теперь, необходимо рассмотреть эти механизмы более детально.


<p align="JUSTIFY">
Как известно, текстовыми файлами являются файлы которые содержат символы.
Как мы уже знаем, согласно стандарта Ada95, Ада обеспечивает поддержку
двух символьных типов: <tt>Character</tt> и <tt>Wide_Character</tt>.

Поэтому, средства поддержки текстового ввода/вывода Ады
подразделяются на средства поддержки ввода/вывода для символов типа <tt>Character</tt> и
средства поддержки ввода/вывода для символов типа <tt>Wide_Character</tt>.


<p align="JUSTIFY">
Следует заметить, что 
стандартные пакеты поддержки текстового ввода/вывода для символов типа <tt>Character</tt>
содержат в своем названии строку <tt>Text_IO</tt>, а
стандартные пакеты поддержки текстового ввода/вывода для символов типа <tt>Wide_Character</tt>
содержат в своем названии строку <tt>Wide_Text_IO</tt>.


<p align="JUSTIFY">
Поскольку логика обработки текстового ввода/вывода для символов типа <tt>Character</tt>
соответствует логике обработки текстового ввода/вывода для символов типа <tt>Wide_Character</tt>,
то для понимания организации поддержки текстового ввода/вывода Ады
достаточно рассмотреть эти механизмы в контексте символов типа <tt>Character</tt>.





<p><h4><a name="s11.1.1">11.1.1 Пакет <i>Ada.Text_IO</i></a></h4>

<p align="JUSTIFY">
Основой организации текстового ввода/вывода Ады является пакет <i>Ada.Text_IO</i>
и коллекция его дочерних пакетов.

Этот пакет обеспечивает средства, которые позволяют манипулировать текстовыми файлами.

Примерами таких средств могут служить подпрограммы
<tt>Close</tt>, <tt>Delete</tt>, <tt>Reset</tt>, <tt>Open</tt>,
<tt>Create</tt> ...


<p align="JUSTIFY">
Главный тип данных пакета <i>Ada.Text_IO</i> - это лимитированный приватный тип <tt>File_Type</tt>.
Он является внутренним представлением файла.

Стандарт Ada95 добавил тип <tt>File_Access</tt>, как ссылку на тип <tt>File_Type</tt>
(объекты имеющие тип <tt>File_Access</tt> часто называют дескрипторами файлов).

При открытии или создании файла, производится ассоциирование
между именем файла в системе и объектом типа <tt>File_Type</tt>. 

Кроме того, при открытии или создании файла, необходимо указывать
режим доступа к файлу:



<dir><table border=0 width="85%">
<tr>
<td valign="TOP"><font size=1><tt>In_File</tt></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="TOP"><font size=1>чтение файла</td>
</tr>

<tr>
<td valign="TOP"><font size=1><tt>Out_File</tt></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="TOP"><font size=1>запись в файл</td>
</tr>

<tr>
<td valign="TOP"><font size=1><tt>Append_File</tt></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="TOP"><font size=1>запись в конец существующего файла (Ada95)</td>
</tr>
</table></dir>




<p align="JUSTIFY">
Заметим, что эти значения имеют тип <tt>File_Mode</tt>, который также описывается
в пакете <i>Ada.Text_IO</i>.

После этого, объект типа <tt>File_Type</tt> может быть использован для выполнения
непосредственных обращений к файлу.

<p align="JUSTIFY">
В приведенном ниже примере, процедура <tt>Create</tt> создает файл "<i>first_file.dat</i>",
после чего, в этот файл процедурами <tt>Put</tt> и <tt>New_Line</tt> производится запись
строки "<tt>It is my first text file!</tt>".

В завершение, процедура <tt>Close</tt> закрывает ранее открытый файл.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Ada.Text_IO;  <b>use</b> Ada.Text_IO;

<b>procedure</b> Demo_File_IO <b>is</b>

    My_File : Ada.Text_IO.File_type;

<b>begin</b>
    Create(File =&gt; My_File,
           Mode =&gt; Out_File,
           Name =&gt; "first_file.dat");

    Put(File =&gt; My_File,
        Item =&gt; "It is my first text file!");

    New_Line(My_File);

    Close(My_File);        -- требуется! Ада может не закрыть
                           -- открытый вами файл
<b>end</b> Demo_File_IO;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Программа, представленная в следующем примере,
выполняет посимвольное чтение данных из одного файла ("<i>input.dat</i>")
и посимвольную запись этих же данных в другой файл ("<i>output.dat</i>").


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Ada.Text_IO;        <b>use</b> Ada.Text_IO;

<b>procedure</b> Read_Write <b>is</b>

    Input_File  : File_type;
    Output_File : File_type;
    Char        : Character;

<b>begin</b>
    Open(Input_File, In_File, "input.dat");
    Create(Output_File, Out_File, "output.dat");

    <b>while not</b> End_Of_File(Input_File) <b>loop</b>
        <b>while not</b> End_Of_Line(Input_File) <b>loop</b>
            Get(Input_File, Char);
            Put(Output_File, Char);
        <b>end loop</b>;
        Skip_Line(Input_File);
        New_Line(Output_File);
    <b>end loop</b>;

    Close(Input_File);
    Close(Output_File);
<b>end</b> Read_Write;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Необходимо обратить внимание на то, что в таких языках программирования как Ада и Паскаль
существует концепция терминатора строки, который не является обычным символом файла.

Это значит, что понятие "конец строки" ("<i>End Of Line</i>", или сокращенно - <i>EOF</i>) Ады
отличается от того, что принято в системах DOS, Windows и UNIX.

В этих системах для обозначения конца строки используется обычный символ
(символ "<tt>CR</tt>" - для UNIX, и символы: "<tt>CR</tt>", "<tt>LF</tt>" - для DOS и Windows),
который может быть обработан обычными средствами символьной обработки.

<p align="JUSTIFY">
Для того чтобы, при чтении из файла, процедура <tt>Read</tt>
"прошла" этот терминатор, необходимо использовать процедуру <tt>Skip_Line</tt>.

Подобным образом, для того чтобы осуществить построчную запись
выходного файла, должна быть использована процедура <tt>New_Line</tt>.


<p align="JUSTIFY">
Пакет <i>Ada.Text_IO</i> обеспечивает большое число
процедур для выполнения различных файловых манипуляций.

В качестве примера наиболее часто используемых процедур можно перечислить следующие процедуры:



<p>
<dir><table border=0 width="85%">
<tr>
<td valign="top"><font size=1><tt>Create</tt></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="top"><font size=1>Создает файл с указанным именем и режимом использования. Примечательно, что если файл имеет строку <i>null</i>, то файл является временным и позднее будет удален.</td>
</tr>
<tr>
<td valign="top"><font size=1><tt>Open</tt></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="top"><font size=1>Открывает файл с указанным именем и режимом использования.</td>
</tr>
<tr>
<td valign="top"><font size=1><tt>Delete</tt></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="top"><font size=1>Удаляет указанный файл. При попытке удалить открытый файл происходит ошибка.</td>
</tr>
<tr>
<td valign="top"><font size=1><tt>Reset</tt></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="top"><font size=1>Возвращает позицию чтения (или записи) в начало файла.</td>
</tr>
</table></dir>


<p align="JUSTIFY">
К наиболее часто используемым функциям пакета <i>Ada.Text_IO</i>,
которые возвращают статус системы файлового обмена,
можно отнести следующие функции:


<p>
<dir><table border=0 width="85%">
<tr>
<td valign="top"><font size=1><tt>End_of_File</tt></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="top"><font size=1>Возвращает истину если мы находимся в конце текущего файла.</td>
</tr>
<tr>
<td valign="top"><font size=1><tt>End_of_Line</tt></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="top"><font size=1>Возвращает истину если мы находимся в конце текущей строки текста.</td>
</tr>
<tr>
<td valign="top"><font size=1><tt>Is_Open</tt></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="top"><font size=1>Возвращает истину если текущий файл открыт.</td>
</tr>
<tr>
<td valign="top"><font size=1><tt>Mode</tt></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="top"><font size=1>Возвращает режим использования текущего файла.</td>
</tr>
<tr>
<td valign="top"><font size=1><tt>Name</tt></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="top"><font size=1>Возвращает строку имени текущего файла.</td>
</tr>
</table></dir>


<p align="JUSTIFY">
Заметим, что список перечисленных здесь подпрограмм далеко не полон
и имеет лишь ознакомительный характер.

Поэтому, для получения более подробных сведений лучше всего
непосредственно обратиться к спецификации пакета <i>Ada.Text_IO</i>.



<p><h4><a name="s11.1.2">11.1.2 Искючения ввода/вывода</a></h4>

<p align="JUSTIFY">
Все средства организации ввода/вывода Ады полагаются на механизм исключений
для сообщения об ошибках, которые возникли в процессе выполнения
какой-либо операции ввода/вывода данных.

Описания исключений ввода/вывода находятся в пакете <i>Ada.IO_Exceptions</i>
который имеет следующий вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Ada.IO_Exceptions <b>is</b>
   <b>pragma</b> Pure(IO_Exceptions);

   Status_Error : <b>exception</b>; -- попытка обращения к файлу который не был открыт
                             --   или повторное открытие файла
   Mode_Error   : <b>exception</b>; -- попытка чтения из файла который открыт для записи
   Name_Error   : <b>exception</b>; -- попытка открытия не существующего файла
                             --   или попытка попытка создания файла
                             --   с не допустимым именем
   Use_Error    : <b>exception</b>; -- зависит от характеристик внешней среды;
                             --   например, при обращении к файлу
                             --   при отсутствии соответствующих
                             --   привелегий доступа
   Device_Error : <b>exception</b>; -- запрошенная операция ввода/вывода не может
                             --   быть выполнена по причине неисправности
                             --   оборудования
   End_Error    : <b>exception</b>; -- попытка чтения за концом файла
   Data_Error   : <b>exception</b>; -- прочитанный элемент не соответствует
                             --   ожидаемому типу данных
   Layout_Error : <b>exception</b>; -- при текстовом вводе/выводе;
                             --   как правило, при выполении операции
                             --   ввода/вывода которая нарушает
                             --   установленные диапазоны значений
                             --   форматирования текста
<b>end</b> Ada.IO_Exceptions;
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Таким образом, попытка создать файл, который уже существует, вызывает исключение, также как
и попытка открыть файл которого нет.

<p align="JUSTIFY">
Показанная ниже процедура <tt>Robust_Open</tt> является примером того,
как можно попытаться избежать подобные неприятности.

Сначала, она пытается открыть указанный файл,
и если это приводит к ошибке говорящей об отсутствии этого файла,
то тогда она пытается его создать:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Ada.Text_IO;        <b>use</b> Ada.Text_IO;

<b>procedure</b> Robust_Open(The_File : <b>in out</b> File_type;
                      Mode     : <b>in</b>     File_mode;
                      Name     : <b>in </b>    String) <b>is</b>
<b>begin</b>
    Open(The_File, Mode, Name);
        
<b>exception</b>
    <b>when</b> Name_Error =&gt;
        Create(The_File, Mode, Name);
<b>end</b> Robust_Open;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Следует обратить внимание на то,
что на корректность работы этого примера может оказать влияние одновременное выполнение
нескольких процессов.

Действительно, выполнение программы может быть приостановлено после попытки открыть файл,
но до того как она попытается его создать.

Следовательно, есть вероятность того, что за время простоя программы
этот файл будет создан другим процессом.


<p align="JUSTIFY">
Примером еще одной простой утилиты может служить логическая функция <tt>File_Exists</tt>,
которая позволяет осуществить проверку существования файла:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Ada.Text_IO;        <b>use</b> Ada.Text_IO;

<b>function</b> File_Exists(Name : String) <b>return</b> Boolean <b>is</b>

    The_File : Ada.Text_IO.File_Type;

<b>begin</b>
    Open(The_File, In_File, Name);

    -- файл открылся, закрываем его и возвращаем "истину"
    Close(The_File);
    <b>return</b> True;
        
<b>exception</b>
    <b>when</b> Name_Error =&gt;
        -- файл не окрылся, значит его нет
        <b>return</b> False;
<b>end</b> File_Exists;
</pre></dir>
</td></tr></table>




<p align="JUSTIFY">
Эта функция пытается открыть файл и если при этом не возникает исключения <i>Name_Error</i>,
то это значит что файл существует, и функция возвращает значение "истина"
(если файл уже открыт, то генерируется исключение <i>Use_Error</i>).




<p><h4><a name="s11.1.3">11.1.3 Файлы ввода/вывода по умолчанию</a></h4>

<p align="JUSTIFY">
В тех случаях, когда для осуществления ввода/вывода нет четкого указания внешних файлов
используются файлы ввода/вывода по умолчанию.

При этом, соответствующие файл ввода и файл вывода по умолчанию
всегда открыты перед началом выполнения программы и связаны
с двумя, определяемыми реализацией системы, внешними файлами.

Другие достаточно широко распространенные названия этих файлов: стандартный ввод и стандартный вывод,
или стандартное устройство ввода и стандартное устройство вывода.

Стандарт Ada95, кроме этого, добавил аналогичную концепцию стандартного файла ошибок,
позаимствовав эту идею от Unix/C.


<p align="JUSTIFY">
Как правило, файл стандартного ввода - это клавиатура, а 
файлы стандартного вывода и стандартного файла ошибок - это дисплей.

Пакет <i>Ada.Text_IO</i> предоставляет средства которые позволяют программно
определять и переопределять установленные по умолчанию файлы ввода/вывода.


<p align="JUSTIFY">
Функции пакета <i>Ada.Text_IO</i>,
которые позволяют определить стандартные файл ввода, файл вывода и файл ошибок,
а также файл ввода, файл вывода и файл ошибок используемые в текущий момент
имеют соответственные имена:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Standard_Input
Standard_Output
Standard_Error

Current_Input
Current_Output
Current_Error
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Такие функции возвращают значения типа <tt>File_Type</tt> или <tt>File_Access</tt>
(используется механизм совмещения имен функций).


<p align="JUSTIFY">
Для переопределения используемых в текущий момент файлов ввода, вывода и ошибок,
пакет <i>Ada.Text_IO</i> обеспечивает процедуры со следующими именами:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Set_Input
Set_Output
Set_Error
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
В качестве параметра, эти процедуры используют значения типа <tt>File_Type</tt>,
причем, указываемый файл должен быть предварительно открыт.




<p><h4><a name="s11.1.4">11.1.4 Настраиваемые пакеты текстового ввода/вывода</a></h4>

<p align="JUSTIFY">
Для поддержки текстового ввода/вывода численных данных и данных перечислимых
типов Ада предусматривает набор настраиваемых пакетов текстового ввода/вывода:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Ada.Text_IO.Integer_IO      -- для целочисленных типов
Ada.Text_IO.Modular_IO      -- для модульных типов
Ada.Text_IO.Float_IO        -- для вещественных типов с плавающей точкой
Ada.Text_IO.Fixed_IO        -- для вещественных типов с фиксированной точкой
Ada.Text_IO.Decimal_IO      -- для децимальных типов
Ada.Text_IO.Enumeration_IO  -- для перечислимых типов
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Примечательно, что все эти настраиваемые пакеты являются дочерними модулями пакета
<i>Ada.Text_IO</i>.

<p align="JUSTIFY">
Хотя эти настраиваемые модули предназначены для организации ввода/вывода
значений различных типов, спецификации этих модулей достаточно подобны.

Таким образом, спецификация любого из этих модулей, используя механизм совмещения имен подпрограмм,
предоставляет описания трех версий настраиваемых процедур <tt>Get</tt> и
трех версий настраиваемых процедур <tt>Put</tt>, которые можно разделить попарно.

Первая пара процедур <tt>Get</tt> и <tt>Put</tt> соответственно предназначена для чтения и записи
значений с устройств стандартного ввода/вывода,
вторая - для аналогичного взаимодействия с внешними файлами,
а третья для преобразования значений в строковое представление и обратно.

Для получения исчерпывающей информации лучше непосредственно
обратиться к спецификациям этих настраиваемых модулей.


<p align="JUSTIFY">
Рассмотрим пример использования настраиваемого пакета <i>Ada.Text_IO.Integer_IO</i>,
который предназначен для организации ввода/вывода целочисленных типов.

Предварительно, необходимо выполнить конкретизацию настраиваемого пакета
<i>Ada.Text_IO.Integer_IO</i> для соответствующего целочисленного типа
(в нашем случае выбран тип <tt>Integer</tt>, для простоты),
и получить экземпляр настроенного модуля:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Ada.Text_IO;        <b>use</b> Ada.Text_IO;

<b>package</b> Int_IO <b>is new</b> Integer_IO(Integer);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Теперь мы можем использовать полученный экземпляр настроенного модуля <i>Int_IO</i>,
например, следующим образом:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Ada.Text_IO;  <b>use</b> Ada.Text_IO;
<b>with</b> Int_IO;       <b>use</b> Int_IO;      -- указываем экземпляр настроенного модуля

<b>procedure</b> Demo_Int_IO <b>is</b>

    Data_File : Text_IO.File_type;

<b>begin</b>
    Create(File =&gt; Data_File,
           Mode =&gt; Out_File,
           Name =&gt; "data.dat");

    <b>for</b> I <b>in</b> 1..10 <b>loop</b>             -- цикл вывода в файл
        Put(Data_File, I);          -- чисел и их квадратов
        Put(Data_File, "    ");
        Put(Data_File, I * I);
        New_Line(Data_File);
    <b>end loop</b>;

    Close(Data_File);
<b>end</b> Demo_Int_IO;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Здесь, процедура <tt>Create</tt> создает файл данных "<i>data.dat</i>",
после чего, в этот файл производится запись некоторых данных процедурами
<tt>Put</tt> и <tt>New_Line</tt>. Процедура <tt>Close</tt> закрывает файл.

<p align="JUSTIFY">
Остальные вышеперечисленные настраиваемые пакеты могут быть использованы
аналогичным образом.

<p align="JUSTIFY">
Следует добавить, что в дополнение к настраиваемым пакетам, Ада также предоставляет
набор настроенных пакетов:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Ada.Short_Short_Integer_Text_IO -- для значений типа Short_Short_Integer
Ada.Short_Integer_Text_IO       -- для значений типа Short_Integer
Ada.Integer_Text_IO             -- для значений типа Integer
Ada.Long_Integer_Text_IO        -- для значений типа Long_Integer
Ada.Long_Long_Integer_Text_IO   -- для значений типа Long_Long_Integer

Ada.Short_Float_Text_IO         -- для значений типа Short_Float
Ada.Float_Text_IO               -- для значений типа Float
Ada.Long_Float_Text_IO          -- для значений типа Long_Float
Ada.Long_Long_Float_Text_IO     -- для значений типа Long_Long_Float
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Первые пять перечисленных пакетов, являются результатами конкретизации
настраиваемого пакета <i>Ada.Text_IO.Integer_IO</i> для использования со значениями
соответствующих целочисленных типов,
последние четыре - результатами соответствующих конкретизаций
настраиваемого пакета <i>Ada.Text_IO.Float_IO</i>.




<!---
<p><h4><a name="s11.1.5">11.1.5 Расширения <i>Ada.Text_IO</i> в Ada95</a></h4>

<p align="JUSTIFY">
В Ada95 был добавлен режим <tt>Append_File</tt> для текстовых файлов. Также
добавлена концепция стандартного файла ошибок (позаимствовано от Unix/C).
Добавлена процедура <tt>Flush</tt> для сброса буферов текстовых файлов.

<p align="JUSTIFY">
Улучшения в символьной обработке также включают <tt>Look_Ahead</tt> и <tt>Get_Immediate</tt>,
с различными опциями.

<p align="JUSTIFY">
Были включены настраиваемые пакеты для ввода/вывода новых модульных и десятичных типов
- их спецификации согласованны с другими настраиваемыми пакетами ввода/вывода чисел.
--->




<p>
<h3><a name="s11.2">11.2 Ввод/вывод двоичных данных</i></a></h3>

<p align="JUSTIFY">
Как правило, современные производительные системы обработки больших объемов данных
не используют текст для сохранения информации в своих файлах.

Это значит, что вместо текста, в целях повышения производительности,
файлы данных таких систем обычно используют двоичное представление.

В этом случае файлы состоят из композитных объектов, которыми чаще всего являются записи.


<p align="JUSTIFY">
В качестве основы для организации ввода/вывода двоичных данных
Ада предусматривает настраиваемые пакеты <i>Ada.Sequential_IO</i> и <i>Ada.Direct_IO</i>.

С помощью этих пакетов можно построить работу с двоичными файлами, состоящими из 
однотипных объектов одинаковой длины (записи, массивы, числа с плавающей точкой ...).





<p><h4><a name="s11.2.1">11.2.1 Пакет <i>Ada.Sequential_IO</i></a></h4>

<p align="JUSTIFY">
Стандартный настраиваемый пакет <i>Ada.Sequential_IO</i> позволяет нам создавать файлы,
состоящие из компонентов любого типа.

При этом, должно соблюдаться единственное условие:
тип компонентов должен быть ограничен (<i>constrained</i>).


<p align="JUSTIFY">
Базовое содержимое настраиваемого пакета <i>Ada.Sequential_IO</i> идентично
пакету <i>Ada.Text_IO</i>, за исключением того, что процедуры <tt>Get</tt> и <tt>Put</tt>
соответственно заменены процедурами <tt>Read</tt> и <tt>Write</tt>,
и эти процедуры будут работать с типом данных для которого была произведена
конкретизация настраиваемого пакета.

Кроме этого, отсутствует понятие строки текста, и, следовательно,
нет функции <tt>End_Of_Line</tt> и процедур <tt>Skip_Line</tt>, <tt>New_Line</tt>.


<p align="JUSTIFY">
Примером использования этого пакета может служить следующее:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Ada.Sequential_IO;        -- настраиваемый пакет

<b>with</b> Personnel_Details;        -- имеет тип записи "Personnel"
<b>use</b>  Personnel_Details;


<b>with</b> Produce_Retirement_Letter;

<b>procedure</b> Sequential_Demo <b>is</b>

    <b>package</b> Person_IO <b>is new</b> Ada.Sequential_IO(Personnel);

    Data_File : Person_IO.File_type;
    A_Person  : Personnel;

<b>begin</b>
    Person_IO.Open(Data_File, In_File, "person.dat");

    <b>while not</b> Person_IO.End_Of_File(Data_File) <b>loop</b>
        Person_IO.Read(Data_File, A_Person);

        <b>if</b> A_Person.Age &gt; 100 <b>then</b>
            Produce_Retirement_Letter(A_Person);
        <b>end if</b>;
    <b>end loop</b>;

    Close(Data_File);
<b>end</b> Sequential_Demo;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Заметим, что в данном примере мы не акцентируем внимание на содержимом пакета
<i>Personnel_Details</i>, а только указываем в комментарии, что он описывает тип
записи <tt>Personnel</tt>.

<p align="JUSTIFY">
После открытия файла, он последовательно обрабатывается от позиции начала файла,
и до тех пор, пока не будет достигнут конец файла,
или будет выполнена одна из процедур <tt>Reset</tt> или <tt>Close</tt>.

Прямой доступ к элементам файла не возможен
(отсюда и название: <i>Ada.Sequential</i> - последовательный).


<!---
<p align="JUSTIFY">
Ada95 добавила файловый режим <tt>Append_File</tt> в спецификацию <i>Ada.Sequential_IO</i>.
--->




<p><h4><a name="s11.2.2">11.2.2 Пакет <i>Ada.Direct_IO</i></a></h4>

<p align="JUSTIFY">
Пакет <i>Ada.Direct_IO</i> построен поверх пакета <i>Ada.Sequential_IO</i>.

Он предусматривает возможность прямого обращения к необходимой записи в файле,
определения размера файла и определения текущего индекса.

Кроме этого, он дополнительно позволяет открывать файлы в режиме - <tt>Inout_File</tt>
(чтение/запись).

Такие средства, в совокупности с подходящим индексирующим пакетом, должны позволять
построение пакета файловой обработки очень высокого уровня.


<p align="JUSTIFY">
Следующий пример демонстрирует использование файлов с прямым доступом:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Ada.Integer_Text_IO;    <b>use</b> Ada.Integer_Text_IO;

<b>with</b> Ada.Direct_IO;        -- настраиваемый пакет

<b>with</b> Personnel_Details;    -- имеет:
<b>use</b>  Personnel_Details;    --   тип записи "Personnel",
                           --   процедуру  "Display_Personnel",
                           --   и т.д. ...

<b>with</b> Display_Menu;         -- внешняя процедура отображения меню


<b>procedure</b> Direct_Demo <b>is</b>

    <b>package</b> Person_IO <b>is new</b> Direct_IO(Personnel);

    Data_File   : Person_IO.File_type;
    A_Person    : Personnel;
    Option      : Integer;
    Employee_No : Integer;

<b>begin</b>
    Person_IO.Open(Data_File, Inout_File, "Person.dat");

    <b>loop</b>
        Display_Menu;
        Get_Option(Option);

        <b>case</b> Option <b>is</b>
            <b>when</b> 1 =&gt;
                    Get(Employee_No);
                    Set_Index(Positive_Count(Employee_No));
                    Read(Data_File, A_Person);
                    Display_Person(A_Person);
            <b>when</b> 2 =&gt;
                    Get(Employee_No);
                    Set_Index(Positive_Count(Employee_No));
                    Read(Data_File, A_Person);
                    Get_New_Details(A_Person);
                    Write(Data_File, A_Person);
            <b>when</b> 3 =&gt;
                    <b>exit</b>;
            <b>when others</b> =&gt;
                    Put("not a great option!");
        <b>end case</b>;
    <b>end loop</b>;
    Close(Data_File);
<b>end</b> Direct_Demo;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Здесь, для краткости подразумевается, что записи о служащих сохраняются в
порядке номеров служащих - <tt>Employee_No</tt>.

<p align="JUSTIFY">
Также заметим, что мы не акцентируем внимание на содержимом внешних модулей: пакете
<i>Personnel_Details</i> и процедуре <tt>Display_Menu</tt>.



<p>
<h3><a name="s11.3">11.3 Потоки ввода/вывода</i></a></h3>


<p align="JUSTIFY">
Стандарт Ada95 обогатил средства ввода/вывода Ады возможностью использования
гетерогенных (состоящих из различных по составу, свойствам,
происхождению частей) потоков ввода/вывода.

Основная идея этого подхода заключается в том, что существует поток данных
который ассоциируется с каким-либо файлом.

За счет использования потоковых механизмов, обработка такого файла
может быть выполнена последовательно, подобно<i>Ada.Sequential_IO</i>,
или позиционно, подобно <i>Ada.Direct_IO</i>.

Причем, в отличие традиционных средств файлового ввода вывода
которые обеспечиваются пакетами <i>Ada.Sequential_IO</i> и <i>Ada.Direct_IO</i>,
один и тот же поток позволяет выполнять чтение/запись
для данных различного типа.

Для обеспечения поддержки механизмов потокового ввода/вывода Ада
предоставляет стандартный пакет <i>Ada.Streams.Stream_IO</i>.



<p align="JUSTIFY">
Прежде чем приступить к детальному рассмотрению потоковых механизмов, необходимо заметить,
что они достаточно тесно связаны с тэговыми типами, которые до настоящего момента не были рассмотрены.

Поэтому, при первом ознакомлении с Адой, рассмотрение поддержки ввода/вывода на потоках
можно пропустить, и вернуться к нему после ознакомления с тэговыми типами.


<p align="JUSTIFY">
Пакет <i>Ada.Streams.Stream_IO</i> предоставляет средства которые
позволяют создавать, открывать и закрывать файлы обычным образом.


Далее, функция <tt>Stream</tt>, которая в качестве параметра
принимает значение типа <tt>File_Type</tt> (потоковый файл),
позволяет получить доступ к потоку ассоциируемому с этим файлом.

Схематически, начало спецификации этого пакета имеет следующий вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Ada.Streams.Stream_IO <b>is</b>
    <b>type</b> Stream_Access <b>is access all</b> Root_Stream_Type<b>'<i>Class</i></b>;
    <b>type</b> File_Type <b>is limited private</b>;
    -- Create, Open, ...
    <b>function</b> Stream(File: <b>in</b> File_Type) <b>return</b> Stream_Access;
        . . .
<b>end</b> Ada.Streams.Stream_IO;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Заметим, что все объекты потокового типа являются производными от абстрактного типа 
<tt>Ada.Streams.Root_Stream_Type</tt>
и обычно получают доступ к потоку через параметр который ссылается на
объект типа <tt>Ada.Streams.Root_Stream_Type<b>'<i>Class</i></b></tt>.

<!---
Мы вернемся к рассмотрению пакета <i>Ada.Streams</i> 
и абстрактному типу <tt>Ada.Streams.Root_Stream_Type</tt> несколько позже.
--->




<p align="JUSTIFY">
Последовательная обработка потоков выполняется с помощью атрибутов
<tt><b>'<i>Read</i></b></tt>,
<tt><b>'<i>Write</i></b></tt>,
<tt><b>'<i>Input</i></b></tt> и
<tt><b>'<i>Output</i></b></tt>.

Эти атрибуты предопределены для каждого нелимитированного типа.

Следует заметить, что Ада, с помощью инструкции описания атрибута,
предоставляет программисту возможность переопределения этих атрибутов.

Таким образом, при необходимости, мы можем переопределять атрибуты которые установлены по умолчанию
и описывать атрибуты для лимитированных типов.

<!---
Вначале будут рассмотрены атрибуты
<tt><b>'<i>Read</i></b></tt> и <tt><b>'<i>Write</i></b></tt>,
которые важны для неопределенных подтипов.

Позже будут рассмотрены атрибуты
<tt><b>'<i>Input</i></b></tt> и <tt><b>'<i>Output</i></b></tt>.
--->


<p align="JUSTIFY">
Атрибуты <tt>T<b>'<i>Read</i></b></tt> и <tt>T<b>'<i>Write</i></b></tt>
принимают параметры которые указывают используемый поток
и элемент типа <tt>T</tt> следующим образом:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> T<b>'<i>Write</i></b>(Stream : <b>access</b> Streams.Root_Stream_Type<b>'<i>Class</i></b>;
                  Item   : <b>in</b> T);

<b>procedure</b> T<b>'<i>Read</i></b>(Stream : <b>access</b> Streams.Root_Stream_Type<b>'<i>Class</i></b>;
                 Item   : <b>out</b> T);
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В качестве простого примера, рассмотрим случай, когда нам необходимо
выполнить запись в поток значения типа <tt>Date</tt>, описание которого имеет вид:




<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Date <b>is</b>
    <b>record</b>
        Day   : Integer;
        Month : Month_Name;
        Year  : Integer;
    <b>end record</b>;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Сначала, мы создаем файл (используя обычный подход) и получаем доступ
к ассоциированному с ним потоку.

Затем, мы можем вызвать процедуру атрибута для значения которое необходимо записать в поток:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

    <b>use</b> Streams.Stream_IO;

    Mixed_File : File_Type;
    S          : Stream_Access;
      . . .
    Create(Mixed_File);
    S := Stream(Mixed_File);
      . . .
    Date<b>'<i>Write</i></b>(S, Some_Date);
    Integer<b>'<i>Write</i></b>(S, Some_Integer);
    Month_Name<b>'<i>Write</i></b>(S, This_Month);
      . . .
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Примечательно, что пакет <tt>Streams.Stream_IO</tt> не является настраиваемым пакетом
и, таким образом, не нуждается в конкретизации.

Все подобные гетерогенные файлы имеют один и тот же тип.

Записанный таким образом файл, может быть прочитан аналогичным образом.

Однако, необходимо заметить, что если мы попытаемся прочитать
записанные данные используя не подходящую для этих данных подпрограмму,
то мы получим ошибку <i>Data_Error</i>.




<p align="JUSTIFY">
В случае простой записи, такой как <tt>Date</tt>, предопределенный атрибут
<tt>Date<b>'<i>Write</i></b></tt>
будет последовательно вызывать атрибуты <tt><b>'<i>Write</i></b></tt> для каждого компонента
<tt>Date</tt>.

Это выглядит следующим образом:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Date<b>'<i>Write</i></b>(Stream : <b>access</b> Streams.Root_Stream_Type<b>'<i>Class</i></b>;
                     Item   : <b>in</b> Date) <b>is</b>
<b>begin</b>
   Integer<b>'<i>Write</i></b>(Stream, Item.Day);
   Month_Name<b>'<i>Write</i></b>(Stream, Item.Month);
   Integer<b>'<i>Write</i></b>(Stream, Item.Year);
<b>end</b>;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Мы можем написать свою собственную версию для <tt>Date<b>'<i>Write</i></b></tt>.

Предположим, что нам необходимо осуществлять вывод имени месяца
в виде соответствующего целого значения:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Date_Write(Stream : <b>access</b> Streams.Root_Stream_Type<b>'<i>Class</i></b>;
                     Item   : <b>in</b> Date) <b>is</b>
<b>begin</b>
   Integer<b>'<i>Write</i></b>(Stream, Item.Day);
   Integer<b>'<i>Write</i></b>(Stream, Month_Name'Pos(Item.Month) + 1);
   Integer<b>'<i>Write</i></b>(Stream, Item.Year);
<b>end</b> Date_Write;

<b>for</b> Date<b>'<i>Write</i></b> <b>use</b> Date_Write;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
тогда, следующая инструкция

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Date<b>'<i>Write</i></b>(S, Some_Date);
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
будет использовать новый формат для вывода значений типа <tt>Date</tt>.

<p align="JUSTIFY">
Аналогичные возможности предусматриваются для осуществления ввода.

Это значит, что если нам необходимо прочитать значение типа <tt>Date</tt>,
то теперь нам нужно описать дополнительную версию <tt>Date<b>'<i>Read</i></b></tt>
для выполнения чтения целых значений как значений месяца
с последующей конверсией этих значений в значения типа <tt>Month_Name</tt>.

<p align="JUSTIFY">
Примечательно, что мы изменили формат вывода <tt>Month_Name</tt> только для случая <tt>Date</tt>.

Если нам нужно изменить формат вывода <tt>Month_Name</tt> для всех случаев,
то разумнее переопределить <tt>Month_Name<b>'<i>Write</i></b></tt>
чем <tt>Date<b>'<i>Write</i></b></tt>.

Тогда, это произведет к косвенному изменению формата вывода для типа <tt>Date</tt>.


<p align="JUSTIFY">
Следует обратить внимание на то, что предопределенные атрибуты
<tt>T<b>'<i>Read</i></b></tt> и <tt>T<b>'<i>Write</i></b></tt>,
могут быть переопределены инструкцией определения атрибута
только в том же самом пакете (в спецификации или декларативной части)
где описан тип <tt>T</tt> (как любое описание представления).

В результате, как следствие, эти предопределенные атрибуты
не могут быть изменены для стандартно предопределенных типов.

Однако они могут быть изменены в их производных типах.


<p align="JUSTIFY">
Ситуация несколько усложняется для массивов и записей с дискриминантами,
поскольку необходимо принимать во внимание дополнительную информацию
предоставляемую значениями границ массива и значениями дискриминантов.

(В случае дискриминанта значение которого равно значению по умолчанию,
дискриминант рассматривается как обычный компонент записи).

Это выполняется с помощью использования дополнительных атрибутов
<tt><b>'<i>Input</i></b></tt> и <tt><b>'<i>Output</i></b></tt>.

Основная идея заключается в том, что атрибуты
<tt><b>'<i>Input</i></b></tt> и <tt><b>'<i>Output</i></b></tt>
обрабатывают дополнительную информацию (если она есть)
и затем вызывают
<tt><b>'<i>Read</i></b></tt> и <tt><b>'<i>Write</i></b></tt>
для обработки остальных значений.

Их описание имеет следующий вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> T<b>'<i>Output</i></b>(Stream : <b>access</b> Streams.Root_Stream_Type<b>'<i>Class</i></b>;
                   Item   : <b>in</b> T);

<b>function</b> T<b>'<i>Input</i></b>(Stream: <b>access</b> Streams.Root_Stream_Type<b>'<i>Class</i></b>)
    <b>return</b> T;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Примечательно, что <tt><b>'<i>Input</i></b></tt> - это функция, поскольку
<tt>T</tt> может быть неопределенным и нам могут быть не известны
ограничения которые установлены для конкретного типа.


<p align="JUSTIFY">
Таким образом, в случае массива процедура <tt><b>'<i>Output</i></b></tt>
выводит  значения границ и, после этого, вызывает <tt><b>'<i>Write</i></b></tt>
непосредственно для самого значения.


<p align="JUSTIFY">
В случае типа записи с дискриминантами, если запись имеет
дискриминанты значения которых равны значениям по умолчанию, то <tt><b>'<i>Output</i></b></tt>
просто вызывает <tt><b>'<i>Write</i></b></tt>, которая трактует дискриминант
как простой компонент записи.

Если значение дискриминанта не соответствует тому значению, которое
указано как значение по умолчанию, то сначала <tt><b>'<i>Output</i></b></tt>
выводит дискриминанты записи, а затем вызывает <tt><b>'<i>Write</i></b></tt>
для обработки остальных компонентов записи.

В качестве примера, рассмотрим случай определенного подтипа,
чей тип - это первый подтип, который не определен:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>subtype</b> String_6 <b>is</b> String(1 .. 6);
S: String_6 := "String";
    . . .
String_6<b>'<i>Output</i></b>(S);      -- выводит значения границ и "String"
String_6<b>'<i>Write</i></b>(S);       -- не выводит значения границ
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Примечательно, что атрибуты <tt><b>'<i>Output</i></b></tt> и <tt><b>'<i>Write</i></b></tt>
принадлежат типам и, таким образом, не имеет значения
или мы записываем <tt>String_6<b>'<i>Write</i></b></tt>, или <tt>String<b>'<i>Write</i></b></tt>.


<p align="JUSTIFY">
Приведенное выше описание работы <tt>T<b>'<i>Input</i></b></tt> и <tt>T<b>'<i>Output</i></b></tt>
относится к атрибутам которые заданы по умолчанию.

Они могут быть переопределены для выполнения чего-либо другого,
причем не обязятельно для вызова <tt>T<b>'<i>Read</i></b></tt> и <tt>T<b>'<i>Write</i></b></tt>.

Дополнительно отметим, что <tt><b><i>Input</i></b></tt> и <tt><b><i>Output</i></b></tt>
существуют также для определенного подтипа,
и их значения просто вызывают <tt><b><i>Read</i></b></tt> и <tt><b><i>Write</i></b></tt>.


<p align="JUSTIFY">
Для взаимодействия с надклассовыми типами предназначены атрибуты
<tt>T<b>'<i>Class</i>'<i>Output</i></b></tt> и <tt>T<b>'<i>Class</i>'<i>Input</i></b></tt>.

Для вывода значения надклассового типа, сначала производится вывод внешнего представления тэга,
после чего с помощю механизма диспетчеризации (перенаправления) вызывается
процедура <tt><b>'<i>Output</i></b></tt> которая соответствующим образом
выводит специфические значения (вызывая <tt><b>'<i>Write</i></b></tt>).

Подобным образом, для ввода значения такого типа, сначала производится чтение тэга,
а затем, в соответствии со значением тэга,
с помощю механизма диспетчеризации (перенаправления) вызывается функция <tt><b><i>Input</i></b></tt>.

Для полноты, также описаны атрибуты
<tt>T<b>'<i>Class</i>'<i>Write</i></b></tt> и <tt>T<b>'<i>Class</i>'<i>Read</i></b></tt>
которые выполняют диспетчеризацию (перенаправление) вызовов к подпрограммам
определяемых атрибутами <tt><b>'<i>Write</i></b></tt> и <tt><b>'<i>Read</i></b></tt>
специфического типа, который идентифицируется тэгом.


<p align="JUSTIFY">
Из рассмотренных нами примеров следует основной принцип работы с потоками:
то что сначала было записано, то и должно быть прочитано,
при выполнении подходящей обратной операции.


<p align="JUSTIFY">
Теперь можно продолжить рассмотрение структуры которая лежит в основе
всех этих механизмов.

Все потоки являются производными от абстрактного типа <tt>Streams.Root_Stream_Type</tt>
который имеет две абстрактных операции <tt>Read</tt> и <tt>Write</tt>
описанные следующим образом:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Read(Stream : <b>in out</b> Root_Stream_Type;
               Item   : <b>out</b> Stream_Element_Array;
               Last   : <b>out</b> Stream_Element_Offset) <b>is abstract</b>;

<b>procedure</b> Write(Stream : <b>in out</b> Root_Stream_Type;
                Item   : <b>in</b> Stream_Element_Array) <b>is abstract</b>;

</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Организацию работы этих механизмов лучше рассматривать
в терминах потоковых элементов, а не значений какого-либо типа.

Следует обратить внимание на разницу между
потоковыми элементами (<i>stream elements</i>) и элементами памяти (<i>storage elements</i>)
(элементы памяти будут рассмотрены при рассмотрении пулов памяти).

Элементы памяти (<i>storage elements</i>) затрагивают внутреннюю память (<i>storage</i>)
в то время как потоковые элементы (<i>stream elements</i>) затрагивают внешнюю информацию
и, таким образом, подходят для распределенных систем.


<p align="JUSTIFY">
Предопределенные атрибуты <tt><b>'<i>Read</i></b></tt> и <tt><b>'<i>Write</i></b></tt>
используют операции <tt>Read</tt> и <tt>Write</tt>
ассоциированного с ними потока, и пользователь может описывать
атрибуты одинаковым образом.

Примечательно, что параметр </tt>Stream</tt> для корневого типа
имеет тип </tt>Root_Stream_Type</tt>, тогда как атрибут - это ссылочный тип
обозначающий соответствующий класс.

Таким образом, такой атрибут, определяемый пользователем,
должен будет выполнять подходящее разыменование:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> My_Write(Stream : <b>access </b>Streams.Root_Stream_Type<b>'<i>Class</i></b>;
                   Item   : T) <b>is</b>
<b>begin</b>
        . . . -- преобразование значений в потоковые элементы
    Streams.Write(Stream.<b>all</b>, ...);  -- диспетчеризации (перенаправления) вызова
<b>end</b> My_Write;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В заключение рассмотрения потоков Ады заметим что <i>Ada.Stream_IO</i>
может быть использован для осуществления индексированного доступа.

Это возможно, поскольку файл структурирован как последовательность
потоковых элементов.

Таким образом, индексированный доступ работает в терминах потоковых элементов
подобно тому как работает <i>Direct_IO</i> в терминах элементов типа.

Это значит, что индекс может быть прочитан и переустановлен.

Процедуры <tt>Read</tt> и <tt>Write</tt> выполняют обработку
относительно текущего значения индекса, также существует альтернативная процедура <tt>Read</tt>
которая стартует согласно указанного значения индекса.

Процедуры <tt>Read</tt> и <tt>Write</tt> (которые используют файловый параметр)
точно соответствуют диспетчеризуемым (перенаправляемым) операциям
ассоциированного потока.




<p>
<h3><a name="s11.4">11.4 Взаимодействие с командной строкой и окружением</a></h3>


<p><h4><a name="s11.4.1">11.4.1 Параметры командной строки</a></h4>


<p align="JUSTIFY">
Во время выполнения программы
существует возможность получения доступа к аргументам,
которые указаны в командной строке запуска программы на выполнение.

Такая возможность обеспечивается средствами стандартного пакета <i>Ada.Command_Line</i>,
спецификация которого имеет следующий вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Ada.Command_Line <b>is</b>
<b>pragma</b> Preelaborate (Command_Line);

    <b>function</b> Argument_Count <b>return</b> Natural;

    <b>function</b> Argument (Number : <b>in</b> Positive) <b>return</b> String;

    <b>function</b> Command_Name <b>return</b> String;

    <b>type</b> Exit_Status <b>is</b> <i><u>Определяемый_Реализацией_Целочисленный_Тип</u></i>;

    Success : <b>constant</b> Exit_Status;
    Failure : <b>constant</b> Exit_Status;

    <b>procedure</b> Set_Exit_Status (Code : <b>in</b> Exit_Status);

<b>private</b>
    --  Стандартом языка не определено
<b>end</b> Ada.Command_Line;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В качестве простой демонстрации использования средств этого предопределенного стандартом пакета,
рассмотрим следующий пример:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b>  Ada.Text_IO;
<b>with</b>  Ada.Command_Line;

<b>procedure</b> Show_CMDLine <b>is</b>
<b>begin</b>

    Ada.Text_IO.Put_Line
        ("The program " &
         '"' & Ada.Command_Line.Command_Name & '"' &
         " has " &
         Ada.Command_Line.Argument_Count<b>'<i>Img</i></b> &
         " argument(s):");

    <b>for</b> I <b>in</b>  1..Ada.Command_Line.Argument_Count  <b>loop</b>

        Ada.Text_IO.Put_Line
            ("   The argument " & I<b>'<i>Img</i></b> & " is " &
            '"' & Ada.Command_Line.Argument (I) & '"');

    <b>end loop</b>;

<b>end</b> Show_CMDLine;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Данная программа отображает фактическое имя запущенной программы,
количество переданных в командной строке аргументов,
а затем показывает строковые значения переданных аргументов.

Процедура <tt>Set_Exit_Status</tt>, пакета <i>Ada.Command_Line</i>,
может быть использована для возврата во внешню среду
кода статуса завершения работы программы
(иначе - кода ошибки).



<p><h4><a name="s11.4.2">11.4.2 Переменные окружения программы</a></h4>


<p align="JUSTIFY">
Для поддержки организации взаимодействия с переменными окружения операционной системы,
реализация компилятора GNAT содержит дополнительный пакет <i>Ada.Command_Line.Environment</i>
спецификация которого имеет следующий вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Ada.Command_Line.Environment <b>is</b>

   <b>function</b> Environment_Count <b>return</b> Natural;

   <b>function</b> Environment_Value (Number : <b>in</b> Positive) <b>return</b> String;

<b>end</b> Ada.Command_Line.Environment;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Функция <tt>Environment_Count</tt>
возвращает общее количество переменных окружения, а
функция <tt>Environment_Value</tt>
возвращает строку в которой содержится имя переменной окружения и ее значение,
разделенные символом равенства.







<!--- footer --->




<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>




</blockquote>
</body>
</html>

