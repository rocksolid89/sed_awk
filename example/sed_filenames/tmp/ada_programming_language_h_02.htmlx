<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<title>Адское программирование.</title>
</head>


<body BGCOLOR="FFFFFF">
<basefont size=3>
<blockquote>

<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>



<!--- header --->



<h2><a name="s2">2. Скалярные типы данных языка Ада.</a></h2>

<p align="JUSTIFY">
К скалярным типам относятся типы данных которые определяют соответствующие
упорядоченные множества значений.
Эта глава описывает скалярные типы данных Ады, а также
атрибуты и операции допустимые для этих типов.


<p align="JUSTIFY">
Предопределенный пакет <i>Standard</i> содержит описания стандартных типов, таких как
<tt>Integer</tt>, <tt>Float</tt>, <tt>Boolean</tt>, <tt>Character</tt> и <tt>Wide_Character</tt>,
а также определяет операции, которые допускается производить над этими типами.

<p align="JUSTIFY">
Следующие знаки операций допустимы для всех скалярных типов:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

=, /=             проверка на равенство/не равенство
&lt;, &lt;=, &gt;, &gt;=      меньше, меньше или равно, больше, больше или равно
<b>in</b>, <b>not in</b>        проверка принадлежности к диапазону
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Перед тем как приступить к непосредственному детальному обсуждению скалярных типов Ады,
необходимо сделать некоторое общее введение в систему типов языка Ада

<p>
<h3><a name="s2.1">2.1 Введение в систему типов языка Ада</a></h3>

<p align="JUSTIFY">
Данные - это то, что обрабатывает программа. Практически, любой современный
язык программирования определяет свои соглашения и механизмы для разделения данных
на разные типы.

Известно, что Ада - это язык со строгой типизацией. И хотя это не единственное свойство
Ады, но, пожалуй, это свойство наиболее широко известно.

<p align="JUSTIFY">
Понятие типа данных Ады подразумевает, что:
<ol>
  <li>каждый тип данных имеет свое имя
  <li>каждый тип данных имеет свое множество допустимых значений
  <li>для каждого типа данных определено свое множество допустимых операций и знаков операций
  <li>строгое разделение объектов одного типа данных от объектов любого другого типа данных
</ol>

<p align="JUSTIFY">
Исходя из сказанного, в отличие от других языков программирования, Ада <b>не допускает</b>
прямого присваивания значений одного типа данных другому типу данных и/или
любого <b>неявного</b> преобразования значений одного типа в значения другого типа.
В случае необходимости преобразования значений одного типа в значения другого типа
можно указать (или описать) требуемое правило преобразования, но такое
правило преобразования должно быть указано явно.

<p align="JUSTIFY">
На первый взгляд,
строгое требование явного указания или описания всех правил преобразования выглядит раздражающе
(особенно для тех кто привык к С)
- без явного указания таких правил компилятор просто отказывается компилировать вашу программу.
Однако, в последствии это предохраняет от долгих и мучительных
поисков, в процессе отладки, тех "сюрпризов" неявного преобразования 
и/или некорректного присваивания значений различных типов, которые допускаются в других
языках программирования.
Таким образом, подобный подход является одним из основополагающих факторов обеспечения надежности
программного обеспечения.

<p align="JUSTIFY">
Ада обладает достаточным набором предопределенных встроенных типов,
а также предоставляет богатые возможности для описания новых типов данных
и их подтипов (<i>subtype</i>).
Кроме того, в языке представлены средства, которые
позволяют гибко управлять внутренним представлением вновь создаваемых типов данных.


<p align="JUSTIFY">
Приводимая ниже диаграмма демонстрирует общую организацию системы типов Ады.

<p>
<p><table BGCOLOR="E0E0E0" border=0 width="95%"><tr><td><font size=1>
<pre>

<u>Все типы</u>
 |
 |- <u>Простые типы</u>
 |    |
 |    |- <u>Скалярные типы</u>
 |    |    |
 |    |    |- <u>Вещественные (Real)</u>
 |    |    |    |
 |    |    |    |- <u>Универсальный Вещественный (Universal_Real)</u>    -- все вещественные
 |    |    |    |                                                 -- литералы
 |    |    |    |
 |    |    |    |- <u>Корневой Вещественный      (Root_Real)</u>         -- только Ada95
 |    |    |         |
 |    |    |         |- <u>с плавающей точкой     (Floating Point)</u>
 |    |    |         |- <u>с фиксированной точкой (Fixed Point)</u>
 |    |    |              |
 |    |    |              |- <u>с обычной фиксированной точкой</u>
 |    |    |              |      <u>(Ordinary Fixed Point)</u>
 |    |    |              |
 |    |    |              |- <u>с десятичной фиксированной точкой </u>   -- только Ada95
 |    |    |                     <u>(Decimal Fixed Point)</u>
 |    |    |
 |    |    |- <u>Дискретные типы</u>
 |    |         |
 |    |         |- <u>Целые типы</u>
 |    |         |     |
 |    |         |     |- <u>Универсальный Целый (Universal_Integer)</u>  -- все
 |    |         |     |                                           -- целочисленные
 |    |         |     |                                           -- литералы
 |    |         |     |
 |    |         |     |- <u>Корневой Целый (Root_Integer)</u>            -- только Ada95
 |    |         |         |
 |    |         |         |- <u>Знаковые Целые</u>
 |    |         |         |- <u>Модульные Целые (Modular Integer)</u>    -- только Ada95
 |    |         |
 |    |         |- <u>Перечислимые</u>
 |    |              |
 |    |              |- <u>Символьные   (Character, Wide_Character)</u>
 |    |              |- <u>Логический   (Boolean)</u>
 |    |              |- <u>Определяемые пользователем</u>
 |    |
 |    |-- <u>Ссылочные типы / указатели   (Access)</u>
 |          |
 |          |- <u>Ссылки на объекты</u>
 |          |- <u>Ссылки на подпрограммы</u>                         -- только Ada95
 |
 |- <u>Составные типы</u>
      |
      |-- <u>Массивы (Array)</u>
      |     |
      |     |- <u>Строки  (String)</u>
      |     |- <u>Другие, определяемые пользователем массивы</u>
      |
      |-- <u>Записи  (Record)</u>
      |
      |-- <u>Тэговые Записи (Tagged Record)</u>                      -- только Ada95
      |
      |-- <u>Задачи  (Task)</u>
      |
      |-- <u>Защищенные типы  (Protected)</u>                        -- только Ada95
</pre>
</td></tr></table>

<p align="JUSTIFY">
Примечательно, что, в отличие от языка Паскаль, Ада не предоставляет предопределенного
механизма поддержки множественных типов.
Однако, богатые средства описания типов Ады, при необходимости,
позволяют программисту конструировать подобные типы без значительных усилий.


<p>
<h3><a name="s2.2">2.2 Целочисленные типы</a></h3>

<p><h4><a name="s2.2.1">2.2.1 Предопределенный тип <tt>Integer</tt></a></h4>

<p align="JUSTIFY">
Предопределенный целочисленный тип <tt>Integer</tt> описан в пакете <i>Standard</i>
(пакет <i>Standard</i> не нужно указывать в инструкциях спецификации
контекста <tt><b>with</b></tt> и <tt><b>use</b></tt>). Точный диапазон целочисленных значений,
предоставляемых этим типом, зависит от конкретной реализации компилятора
и/или оборудования. Однако, стандарт определяет минимально допустимый диапазон значений
для этого типа от -(2 ** 15) до +(2 ** 15 - 1)
(например, в случае 32-битных систем, таких как <i>Windows</i> или <i>Linux</i>,
для реализации компилятора GNAT
диапазон значений типа <tt>Integer</tt> будет от -(2 ** 31) до +(2 ** 31 - 1)).

<p align="JUSTIFY">
Кроме типа <tt>Integer</tt>, в пакете <i>Standard</i> предопределены два его подтипа
(понятие подтипа будет рассмотрено позже)
<!---
(см. 4.8 Подтипы)
--->
<tt>Natural</tt> и <tt>Positive</tt>, которые, соответственно, описывают
множества не отрицательных (натуральных) и положительных целых чисел.



<p><h4><a name="s2.2.2">2.2.2 Тип <tt>Universal_Integer</tt></a></h4>

<p align="JUSTIFY">
Для предотвращения необходимости явного преобразования типов при описании целочисленных
констант, Ада предлагает понятие универсального целого типа - <tt>Universal_Integer</tt>.
Все целочисленные литералы принадлежат типу <tt>Universal_Integer</tt>.
Многие атрибуты языка (обсуждаемые позже) также возвращают значения универсального целого типа.
Установлено, что тип <tt>Universal_Integer</tt> совместим с любым другим целочисленным типом, поэтому,
в арифметических выражениях, компилятор будет автоматически преобразовывать значения
универсального целого типа в значения соответствующего целочисленного типа.


<p><h4><a name="s2.2.3">2.2.3 Описание целочисленных констант</a></h4>

<p align="JUSTIFY">
При хорошем стиле программирования, принято присваивать целочисленным значениям
символьные имена. Это способствует улучшению читабельности программы и, при необходимости,
позволяет легко вносить в нее изменения.


<p align="JUSTIFY">
Приведем простой пример описания константы (именованного числа):

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Max_Width : <b>constant</b> := 10_000; -- 10_000 - имеет тип <i>Universal_Integer</i>
                                -- это не тип <i>Integer</i>
</pre></dir>
</td></tr></table>



<p><h4><a name="s2.2.4">2.2.4 Тип <tt>Root_Integer</tt></a></h4>

<p align="JUSTIFY">
Модель целочисленной арифметики Ады базируется на понятии неявного типа <tt>Root_Integer</tt>.
Этот тип используется как базовый тип для всех целочисленных типов Ады.
Другими словами - все целочисленные типы являются производными от типа <tt>Root_Integer</tt>
(см. Производные типы).
Диапазон значений типа <tt>Root_Integer</tt> определяется как
<tt>System.Min_Int..System.Max_Int</tt>. Все знаки арифметических операций описаны так,
чтобы они могли выполняться над этим типом.

<p align="JUSTIFY">
При описании нового целочисленного типа возможны два различных подхода,
которые можно проиллюстрировать на следующем примере:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> X <b>is new</b> Integer <b>range</b> 0 .. 100;
<b>type</b> Y <b>is range</b> 0 .. 100;
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Здесь, тип <tt>X</tt> описывается как производный от типа <tt>Integer</tt>
с допустимым диапазоном значений от 0 до 100.
Исходя из этого, для типа <tt>X</tt> базовым типом будет тип <tt>Integer</tt>.

<p align="JUSTIFY">
Тип <tt>Y</tt> описывается как тип с допустимым диапазоном значений от 0 до 100,
и при его описании не указан тип-предок.
В таком случае, он будет производным от типа <tt>Root_Integer</tt>, но его базовый диапазон
не обязательно должен быть таким же как у <tt>Root_Integer</tt>. В результате, некоторые системы
могут размещать экземпляры объектов такого типа и его базового типа в одном байте.
Другими словами, определение размера распределяемого места под объекты такого типа
возлагается на компилятор.


<p><h4><a name="s2.2.5">2.2.5 Примеры целочисленных описаний</a></h4>

<p align="JUSTIFY">
Ниже приводятся примеры различных целочисленных описаний Ады.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

-- описания целочисленных статических переменных

Count           : Integer;
X, Y, Z         : Integer;
Amount          : Integer := 0;


-- описания целочисленных констант (иначе - именованных чисел)

Unity           : <b>constant</b> Integer := 1;
Speed_Of_Light  : <b>constant</b> := 300_000; -- тип <i>Universal_Integer</i>
A_Month         : Integer <b>range</b> 1..12;


-- описания целочисленных типов и подтипов
-- ( см. разделы "Подтипы" и "Производные типы" )

<b>subtype</b> Months <b>is</b> Integer <b>range</b> 1..12;        -- огранниченный тип <i>Integer</i>
-- подтипы - совместимы с их базовым типом (здесь - <i>Integer</i>)
-- например, переменная типа <i>Month</i> может быть "смешана" с переменными
-- типа <i>Integer</i>

<b>type</b> File_Id <b>is new</b> Integer; -- новый целочисленный тип, производный
                             -- от типа <i>Integer</i>

<b>type</b> Result_Range <b>is new</b> Integer range 1..20_000;
-- производный тип с объявлением ограничения

<b>type</b> Other_Result_Range <b>is range</b> 1..100_000;
-- тип производный от <i>Root_Integer</i>
-- при этом, компилятор будет выбирать подходящий размер целочисленного значения
-- для удовлетворения требований задаваемого диапазона
</pre></dir>
</td></tr></table>



<p><h4><a name="s2.2.6">2.2.6 Предопределенные знаки операций для целочисленных типов</a></h4>

<p align="JUSTIFY">
Следующие знаки операций предопределены для каждого целочисленного типа:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

+, -               унарные плюс и минус
+, -, *, /         сложить, вычесть, умножить и разделить
**                 возведение в степень (только целые значения степени)
<b>mod</b>                модуль
<b>rem</b>                остаток
<b>abs</b>                абсолютное значение
</pre></dir>
</td></tr></table>



<p><h4><a name="s2.2.7">2.2.7 Модульные типы</a></h4>

<p align="JUSTIFY">
Все целочисленные типы, которые мы рассматривали ранее, известны как целые числа со знаком.
Для таких типов соблюдается правило - если в случае вычисления результат выходит за диапазон
допустимых значений типа, то генерируется ошибка переполнения.
Такие целочисленные типы были представлены стандартом Ada83.

<p align="JUSTIFY">
Стандарт Ada95 разделяет целочисленные типы на целые числа со знаком и модульные типы.
По существу, модульные типы являются целыми числами без знака.
Характерной особенностью таких типов является свойство цикличности арифметических операций.
Таким образом, модульные типы соответствуют целочисленным беззнаковым типам
в других языках программирования (например: <tt>Byte</tt>, <tt>Word</tt>... - в реализациях Паскаля;
<tt>unsigned_short</tt>, <tt>unsigned</tt>... - в C/C++).


<p align="JUSTIFY">
В качестве простого примера рассмотрим следующий фрагмент кода:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

    . . .
<b>type</b>  Byte  <b>is mod</b> 2 ** 8;    -- (2 ** 8) = 256
    Count : Byte := 255;
<b>begin</b>
    Count := Count + 1;
    . . .
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Здесь не производится генерация ошибки в результате выполнения сложения.
Вместо этого, переменная <tt>Count</tt>, после выполнения сложения, будет содержать 0.

<p align="JUSTIFY">
Кроме этого, с модульными типами удобно использовать знаки битовых операций
"<tt><b>and</b></tt>", "<tt><b>or</b></tt>", "<tt><b>xor</b></tt>" и "<tt><b>not</b></tt>".
Такие операции трактуют значения модульного типа как битовый шаблон.
Например:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b>  Byte  <b>is mod</b> 2 ** 8;    -- (2 ** 8) = 256
    Some_Var_1  : Byte;
    Some_Var_2  : Byte;
    Mask        : <b>constant</b> := 16#0F#
<b>begin</b>
    . . .
    Some_Var_2 := Some_Var_1 <b>and</b> Mask;
    . . .
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Поскольку модульные типы не имеют отрицательных значений,
для них допускается смешивание знаков битовых операций со знаками арифметических операций
в одном выражении.

<p align="JUSTIFY">
Следует заметить, что хотя при описании модульных типов зачастую используют
степень двойки, использование двоичной системы счисления при описании модульных типов
не является обязательным требованием.

<p align="JUSTIFY">
Ада допускает выполнение преобразований беззнаковых чисел модульных типов в числа со знаком и обратно.
При этом, производится проверка результата преобразования на допустимость диапазону значений
типа назначения. В случае неудачи будет сгенерировано исключение <i>Constraint_Error</i>.
Например:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b>  Unsigned_Byte  <b>is mod</b> 2 ** 8;    -- (2 ** 8) = 256
<b>type</b>  Signed_Byte    <b>is range</b> -128 .. +127;

U : Unsigned_Byte := 150;
S : Signed_Byte   := Signed_Byte(U);  -- здесь будет сгенерировано исключение
                                      --   <i>Constraint_Error</i>
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Этот код будет вызывать генерацию исключения <i>Constraint_Error</i>.

<!---
<p align="JUSTIFY">
В подобных случаях, при необходимости, можно использовать неконтролируемое преобразование
(<tt>Unchecked_Convertion</tt>).
--->

<p align="JUSTIFY">
В следующем параграфе приводятся описания предопределенных модульных типов
представленных в пакете <i>Interfaces</i>.
Заметим, что для этих модульных типов
(они описаны с использованием двоичной системы счисления)
предопределены операции побитного сдвига и вращения.




<p><h4><a name="s2.2.8">2.2.8 Дополнительные целочисленные типы системы компилятора <i>GNAT</i></a></h4>

<p align="JUSTIFY">
Стандарт языка Ада допускает определять в реализации Ада-системы
собственные дополнительные целочисленные типы.
Таким образом,
в пакете <i>Standard</i> системы компилятора <i>GNAT</i> определены дополнительные
целочисленные типы:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b>   Short_Short_Integer <b>is range</b> -(2 ** 7) .. +(2 ** 7 - 1);
<b>type</b>   Short_Integer       <b>is range</b> -(2 ** 15) .. +(2 ** 15 - 1);
<b>type</b>   Long_Integer        <b>is range</b> -(2 ** 31) .. +(2 ** 31 - 1);
<b>type</b>   Long_Long_Integer   <b>is range</b> -(2 ** 63) .. +(2 ** 63 - 1);
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Кроме этого, стандарт требует наличия определения 
дополнительных 8-, 16-, 32- и 64-битных целочисленных типов в пакете <i>Interfaces</i>:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b>   Integer_8     <b>is range</b>   -2 **  7 .. 2 **  7 - 1;
<b>type</b>   Integer_16    <b>is range</b>   -2 ** 15 .. 2 ** 15 - 1;
<b>type</b>   Integer_32    <b>is range</b>   -2 ** 31 .. 2 ** 31 - 1;
<b>type</b>   Integer_64    <b>is range</b>   -2 ** 63 .. 2 ** 63 - 1;

<b>type</b>   Unsigned_8    <b>is mod</b>   2 **  8;
<b>type</b>   Unsigned_16   <b>is mod</b>   2 ** 16;
<b>type</b>   Unsigned_32   <b>is mod</b>   2 ** 32;
<b>type</b>   Unsigned_64   <b>is mod</b>   2 ** 64;
</pre></dir>
</td></tr></table>



<p>
<h3><a name="s2.3">2.3 Вещественные типы</a></h3>

<p align="JUSTIFY">
Ада предусматривает два способа представления вещественных чисел:
представление вещественных величин с плавающей точкой и
представление вещественных величин с фиксированной точкой.
Кроме этого вы можете использовать типы вещественных величин с десятичной
фиксированной точкой.


<p><h4><a name="s2.3.1">2.3.1 Вещественные типы с плавающей точкой, тип <tt>Float</tt></a></h4>

<p align="JUSTIFY">
Вещественные типы с плавающей точкой имеют неограниченный диапазон значений
и точность, определяемую количеством десятичных цифр после запятой.
Представление чисел с плавающей точкой имеет фиксированную относительную погрешность.

<p align="JUSTIFY">
Пакет <i>Standard</i> предоставляет предопределенный вещественный тип с плавающей
точкой <tt>Float</tt>, который обеспечивает точность в шесть десятичных цифр после запятой:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b>  Float  <b>is digits</b> 6 <b>range</b> -16#0.FFFF_FF#E+32 .. 16#0.FFFF_FF#E+32;
                         --    -3.40282E+38 ..  3.40282E+38
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
В пакете <i>Standard</i> компилятора <i>GNAT</i>,
для 32-битных систем Linux и Windows,
дополнительно представлены еще несколько вещественных типов с плавающей точкой
(фактические значения констант для различных платформ отличаются):

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b>  Short_Float     <b>is digits</b> 6
  <b>range</b> -16#0.FFFF_FF#E+32 .. 16#0.FFFF_FF#E+32;
  --    -3.40282E+38 ..  3.40282E+38

<b>type</b>  Long_Float      <b>is digits</b> 15
  <b>range</b> -16#0.FFFF_FFFF_FFFF_F8#E+256 .. 16#0.FFFF_FFFF_FFFF_F8#E+256;
  --    -1.79769313486232E+308 ..  1.79769313486232E+308

<b>type</b>  Long_Long_Float <b>is digits</b> 18
  <b>range</b> -16#0.FFFF_FFFF_FFFF_FFFF#E+4096 .. 16#0.FFFF_FFFF_FFFF_FFFF#E+4096;
  --    -1.18973149535723177E+4932 ..  1.18973149535723177E+4932
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Ниже следуют примеры описаний вещественных величин с плавающей точкой.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

X         : Float;
A, B, C   : Float;
Pi        : <b>constant</b> Float := 3.14_2;
Avogadro  : <b>constant</b> := 6.027E23;        -- тип <i>Universal_Float</i>

<b>subtype</b> Temperatures <b>is</b> Float <b>range</b> 0.0..100.0;
<b>type</b> Result <b>is new</b> Float <b>range</b> 0.0..20_000.0;

<b>type</b> Velocity <b>is new</b> Float;
<b>type</b> Height <b>is new</b> Float;
-- нельзя случайно смешивать <i>Velocity</i> и <i>Height</i>
-- без явного преобразования типов.

<b>type</b> Time <b>is digits</b> 6 <b>range</b> 0.0..10_000.0;
-- в этом диапазоне требуемая точность - шесть десятичных цифр
-- после точки

<b>type</b> Degrees <b>is digits</b> 2 <b>range</b> -20.00..100.00;
-- требуемая точность - две десятичных цифры после точки
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Следующие знаки операций предопределены для каждого вещественного типа с плавающей точкой.

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

+, -, *, /
**                 возведение в степень (только целые значения степени)
<b>abs</b>                абсолютное значение
</pre></dir>
</td></tr></table>




<p><h4><a name="s2.3.2">2.3.2 Вещественные типы с фиксированной точкой, тип <tt>Duration</tt></a></h4>

<p align="JUSTIFY">
Представление чисел с фиксированной точкой имеет более ограниченный диапазон
значений и указанную абсолютную погрешность, которая
задается как <tt><b>delta</b></tt> этого типа.

<p align="JUSTIFY">
В пакете <i>Standard</i> предоставлен предопределенный вещественный тип с фиксированной
точкой <tt>Duration</tt>, который используется для представления времени и обеспечивает
точность измерения времени в 50 микросекунд:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Duration <b>is delta</b> 0.000000001
     <b>range</b> -((2 ** 63 - 1) * 0.000000001) ..
           +((2 ** 63 - 1) * 0.000000001);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Ниже следуют примеры описаний вещественных типов с фиксированной точкой.

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Volt <b>is delta</b> 0.125 <b>range</b> 0.0 .. 255.0;

<b>type</b> Fraction <b>is delta</b> System.Fine_Delta <b>range</b> -1.0..1.0;        -- Ada95
        -- Fraction<b>'<i>Last</i></b> = 1.0 - System.Fine_Delta
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Последний пример показывает полезную способность вещественных типов с фиксированной точкой -
четкое определение насколько тип должен быть точным. Например, это позволяет
контролировать ошибки, возникающие при округлении.



<p><h4><a name="s2.3.3">2.3.3 Вещественные типы с десятичной фиксированной точкой</a></h4>

<p align="JUSTIFY">
Следует учитывать, что поскольку от реализации компилятора Ады
не требуется обязательное обеспечение поддержки вещественных величин с десятичной
фиксированной точкой, то это может вызвать трудности при переносе программного обеспечения на
другую систему или при использовании разных компиляторов.

<p align="JUSTIFY">
Примером описания вещественного типа с десятичной фиксированной точкой
может служить следующее:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Money <b>is delta</b> 0.01 <b>digits</b> 15; -- десятичная фиксированная точка,
                                    -- здесь величина, задаваемая в <i>delta</i>,
                                    -- должна быть степенью 10
<b>subtype</b> Salary <b>is</b> Money <b>digits</b> 10;  
</pre></dir>
</td></tr></table>



<p><h4><a name="s2.3.4">2.3.4 Типы <tt>Universal_Float</tt> и <tt>Root_Real</tt></a></h4>

<p align="JUSTIFY">
Подобно тому как все целочисленные литералы принадлежат универсальному классу
<tt>Universal_Integer</tt>,
все вещественные численные литералы принадлежат универсальному классу
<tt>Universal_Float</tt>.
Этот универсальный тип совместим с любым вещественным типом с плавающей точкой
и любым вещественным типом с фиксированной точкой.
Такой подход избавляет от необходимости выполнения различных преобразований типов при описании
вещественных констант и переменных.

<p align="JUSTIFY">
Модель вещественной арифметики Ады основывается на анонимном типе <tt>Root_Real</tt>.
Этот анонимный тип используется как базовый тип для всех вещественных типов.
Тип <tt>Root_Real</tt> имеет точность, которая определяется значением
константы <tt>Max_Base_Digits</tt> пакета <i>System</i> (<tt>System.Max_Base_Digits</tt>).
Такой подход использован для облегчения переносимости программ.


<p><h4><a name="s2.3.5">2.3.5 Пакеты для численной обработки</a></h4>

<p align="JUSTIFY">
Полное обсуждение поддержки численной обработки в Аде - весьма обширная тема.
Поэтому здесь, чтобы указать "куда бежать дальше", мы только приведем список
пакетов для численной обработки, которые предоставляются поставкой компиляора
<i>GNAT</i>:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Ada.Numerics
Ada.Numerics.Aux
Ada.Numerics.Float_Random
Ada.Numerics.Discrete_Random

Ada.Numerics.Complex_Types
Ada.Numerics.Complex_Elementary_Functions
Ada.Numerics.Elementary_Functions

Ada.Numerics.Generic_Complex_Types
Ada.Numerics.Generic_Complex_Elementary_Functions
Ada.Numerics.Generic_Elementary_Functions

Ada.Numerics.Long_Complex_Types
Ada.Numerics.Long_Complex_Elementary_Functions
Ada.Numerics.Long_Elementary_Functions

Ada.Numerics.Long_Long_Complex_Types
Ada.Numerics.Long_Long_Complex_Elementary_Functions
Ada.Numerics.Long_Long_Elementary_Functions

Ada.Numerics.Short_Complex_Types
Ada.Numerics.Short_Complex_Elementary_Functions
Ada.Numerics.Short_Elementary_Functions
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Следует заметить, что пакет <i>Ada.Numerics.Aux</i>, который указан выше,
не предназначен для непосредственного использования в программах пользователя,
и упоминается только с целью полноты показанного выше списка.

<p>
<h3><a name="s2.4">2.4 Преобразование численных типов</a></h3>

<p align="JUSTIFY">
Поскольку тип <tt>Float</tt> и тип <tt>Integer</tt> - различные типы, то
Ада не допускает смешивания величин этих типов в одном выражении.
Однако, встречаются случаи, когда нам необходимо комбинировать значения этих типов. 
В таких ситуациях нам необходимо производить преобразование значений одного численного типа
в значения другого численного типа.

<p align="JUSTIFY">
Ада позволяет явно указывать необходимость преобразования значения типа <tt>Float</tt>
в значение типа <tt>Integer</tt>, и наоборот.
Для выполнения такого преобразования используется синтаксис подобный синтаксису вызова функции:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

X : Integer := 4;
Y : Float;

Y := Float(X);

  . . .

X := Integer(Y);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В этом случае компилятор, во время трансляции, добавит необходимый код для преобразования типов.
Такое преобразование типов всегда возможно, и будет успешным если значение результата
не будет нарушать границ допустимого диапазона значений.

<p align="JUSTIFY">
Следует заметить, что при преобразовании вещественного
значения <tt>Float</tt> в целое значение <tt>Integer</tt>
Ада использует традиционные для математики правила округления, то есть:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>

<p><table border=0 width="100%">
<tr>
<th width="50%"><font size=1>Значение <tt>Float</tt></th>
<th width="50%"><font size=1>Округленное значение <tt>Integer</tt></th>
</tr>
<tr>
<td align="center" valign="top"><font size=1>1.5</td>
<td align="center" valign="top"><font size=1>2</td>
</tr>
<tr>
<td align="center" valign="top"><font size=1>1.3</td>
<td align="center" valign="top"><font size=1>1</td>
</tr>
<tr>
<td align="center" valign="top"><font size=1>-1.5</td>
<td align="center" valign="top"><font size=1>-2</td>
</tr>
<tr>
<td align="center" valign="top"><font size=1>-1.3</td>
<td align="center" valign="top"><font size=1>-1</td>
</tr>
</table>

</td></tr></table>



<p>
<h3><a name="s2.5">2.5 Перечислимые типы</a></h3>

<p align="JUSTIFY">
До настоящего момента были рассмотрены типы данных которые представляли численные
значения (целые и вещественные числа).
Однако, при решении многих практических задач, важное значение имеет понятие перечислимого типа.
Перечислимыми типами называют такие типы данных значения которых перечислены, то есть
представлены списком некоторых значений. Перечислимый тип полезен когда необходимо
представить фиксированное множество значений, которые не являются числами.
Примером может служить представление дней недели или месяцев в году.


<p><h4><a name="s2.5.1">2.5.1 Описание перечислимого типа</a></h4>

<p align="JUSTIFY">
Перечислимый тип описывается путем предоставления списка всех возможных значений
данного типа в виде идентификаторов (другими словами, перечислением всех возможных значений
данного типа). Например:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Computer_Language <b>is</b> (Assembler, Cobol, Lisp, Pascal, Ada);
<b>type</b> C_Letter_Languages <b>is</b> (Cobol, C);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
После такого описания типов, константы и переменные этих типов могут быть описаны следующим образом:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

A_Language      : Computer_Language;
Early_Language  : Computer_Language := Cobol;
First_Language  : <b>constant</b> Computer_Language := Assembler;
Example         : C_Letter_Language := Cobol;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Необходимо заметить, что порядок перечисления значений типа,
при описании перечислимого типа, имеет самостоятельное значение - он
устанавливает отношение порядка следования значений перечислимого типа,
которое используется атрибутами
<tt><b>'<i>First</i></b></tt>,
<tt><b>'<i>Last</i></b></tt>,

<tt><b>'<i>Pos</i></b></tt>,
<tt><b>'<i>Val</i></b></tt>,
<tt><b>'<i>Pred</i></b></tt>,
<tt><b>'<i>Succ</i></b></tt> (см "Атрибуты типов"), а также
при сравнении величин перечислимого типа. Так, для типа <tt>Computer_Language</tt>,
описанного в примере выше, значение <tt>Assembler</tt> будет меньше
чем значение <tt>Cobol</tt>.

<p align="JUSTIFY">
В одной программе допускается использование одного и того же перечислимого литерала
в описаниях различных перечислимых типов.
Так, в показанном выше примере, литерал <tt>Cobol</tt> встречается при описании
двух разных типов: <tt>Computer_Language</tt> и <tt>C_Letter_Languages</tt>.
Такие литералы называют <b>совмещенными</b> (или перегруженными).
При этом, Ада, в большинстве случаев,
распознает одинаковые перечислимые литералы различных перечислимых типов.
В случаях, когда это не возможно - необходимо использовать квалификацию типов.



<p align="JUSTIFY">
Рассмотрим следующий пример:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Primary <b>is</b> (Red, Green, Blue);
<b>type</b> Rainbow <b>is</b> (Red, Yellow, Green, Blue, Violet);
...
<b>for</b> I <b>in</b> Red..Blue <b>loop</b> ...      -- это двусмысленно
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Здесь, компилятор не может самостоятельно определить
к какому из двух типов (<tt>Primary</tt> или <tt>Rainbow</tt>)
принадлежит диапазон значений <tt>Red..Blue</tt> переменной цикла <tt>I</tt>
(литералы <tt>Red</tt> и <tt>Blue</tt> - совмещены).
Поэтому, в подобных случаях, нам необходимо точно указывать требуемый тип,
используя квалификацию типа:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>for</b> I <b>in</b> Rainbow'(Red)..Rainbow'(Blue) <b>loop</b> ...
<b>for</b> I <b>in</b> Rainbow'(Red)..Blue <b>loop</b> ...     -- необходима только одна квалификация
<b>for</b> I <b>in</b> Primary'(Red)..Blue <b>loop</b> ...
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Квалификация типа не изменяет значения типа и не выполняет никаких преобразований типа.
Она только информирует компиляор о том какой тип, в данном случае, подразумевает программист.




<p align="JUSTIFY">
При описании перичислимых типов, для указания значений перечислимого типа
также как и символические имена, допускается использовать символьные константы.
В этом случае перечислимый тип будет символьным (см. "Символьные типы Ады"). 

<p align="JUSTIFY">
В заключение обсуждения описания перечислимых типов, заметим, что
перечислимые и целочисленные типы называют <b>дискретными типами</b>,
потому что они описывают множества упорядоченных дискретных значений.
Вещественные числа не могут считаться дискретными поскольку
между двумя любыми вещественными числами располагается бесконечное
множество вещественных чисел (естественно, теоретически).


<p><h4><a name="s2.5.2">2.5.2 Предопределенный логический тип <tt>Boolean</tt></a></h4>

<p align="JUSTIFY">
В Аде, предопределенный логический тип <tt>Boolean</tt> описывается как перечислимый тип в пакете
<i>Standard</i>:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b>  Boolean  <b>is</b>  (False, True);
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Таким образом, переменные логического типа <tt>Boolean</tt> могут принимать только одно из двух
значений: <tt>True</tt> (истина) или <tt>False</tt> (ложь).

<p align="JUSTIFY">
Примечательно, что предопределеннный логический тип <tt>Boolean</tt> имеет специальное предназначение.
Значения этого типа используются в условных инструкциях языка Ада ("<tt><b>if</b> ... </tt>",
"<tt><b>exit when</b> ... </tt>", ...).
Это подразумевает, что если вы пытаетесь описать свой собственный
логический тип <tt>Boolean</tt>, и описываете его точно также как и предопределенный тип
<tt>Boolean</tt> (полное имя предопределенного логического типа - <tt>Standard.Boolean</tt>),
то вы получаете абсолютно самостоятельный тип(!). В результате, вы не можете
использовать значения, описанного вами типа <tt>Boolean</tt>, в условных
инструкциях языка Ада, которые ожидают только тип <tt>Standard.Boolean</tt>.

<p align="JUSTIFY">
Значения предопределенного логического типа <tt>Standard.Boolean</tt>
возвращают знаки операций сравнения:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

=     -- равно
/=    -- не равно
&lt;     -- меньше
&lt;=    -- меньше или равно
&gt;     -- больше
&gt;=    -- больше или равно
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Для обработки значений типа <tt>Boolean</tt> могут быть использованы следующие знаки операций:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>and</b>         -- логическое И:    вычисляются и левая, и правая часть выражения
<b>and then</b>    -- логическое И:    правая часть выражения вычисляется, если
            --                  результат вычисления левой части - True

<b>or</b>          -- логическое ИЛИ:  вычисляются и левая, и правая часть выражения
<b>or else</b>     -- логическое ИЛИ:  правая часть выражения вычисляется, если
            --                  результат вычисления левой части - False

<b>xor</b>         -- исключающее ИЛИ
<b>not</b>         -- отрицание (инверсия); унарная операция
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Обычно, при вычислении значений логических выражений, компилятор сам определяет
последовательность вычисления каждого логического значения.
При этом, производится вычисление всех логических переменных, указанных в логическом выражении.

Тем кто знаком с языком Паскаль следует заметить, 
что такой подход отличается от правил принятых в современных диалектах
Паскаля, где, для повышения производительности,
определение значения результата всего логического выражения может быть выполнено сокращенно,
в зависимости от предварительных результатов обработки выражения.

Например, при определении значения результата следующего логического выражения

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

(B /= 0) <b>and</b> (A/B > 0)
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
в случае, когда значение <tt>B</tt> равно нулю будет возникать ошибка деления на ноль.
Причина в том, что значение части выражения, расположенной справа от "<tt><b>and</b></tt>",
вычисляется всегда, не зависимо от значения результата полученного при вычислении <tt>(B /= 0)</tt>.

<p align="JUSTIFY">
Чтобы избежать подобных ошибок, а также в целях увеличения производительности,
необходимо производить вычисление значений логических переменных в определенной последовательности
и прекращать ее как только результат всего выражения уже определен.
Для этого можно использовать "<tt><b>and then</b></tt>" вместо "<tt><b>and</b></tt>",
и "<tt><b>or else</b></tt>" вместо "<tt><b>else</b></tt>", указывая
порядок обработки логического выражения явно:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

(B /= 0) <b>and then</b> (A/B > 0)
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
В этом случае, обработка выражения справа от "<tt><b>and then</b></tt>" будет производиться
только в случае когда <tt>B</tt> не равно нулю,
т.е. результат слева от "<tt><b>and then</b></tt>" - <tt>True</tt>.

<p align="JUSTIFY">
Можно переписать предыдущий пример с использованием "<tt><b>or else</b></tt>".
Тогда, обработка логического выражения будет завершена в случае если значение
слева от "<tt><b>or else</b></tt>" вычислено как <tt>True</tt>:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

(B = 0) <b>or else</b> (A/B <= 0)
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В заключение обсуждения логического типа отметим, что
Ада не позволяет одновременное использование
"<tt><b>and</b></tt>" ("<tt><b>and</b></tt>" или "<tt><b>and then</b></tt>"),
"<tt><b>or</b></tt>" ("<tt><b>or</b></tt>" или "<tt><b>or else</b></tt>")
и "<tt><b>xor</b></tt>"
в одном выражении не разделенном скобками.
Это уменьшает вероятность разночтения содержимого сложного
логического выражения. Например:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

(A &lt; B) <b>and</b> (B &gt; C) <b>or</b> (D &lt; E)    -- запрещено
((A &lt; B) <b>and</b> (B &gt; C)) <b>or</b> (D &lt; E)  -- разрешено
</pre></dir>
</td></tr></table>






<p><h4><a name="s2.5.3">2.5.3 Символьные типы Ады (<tt>Character</tt>, <tt>Wide_Character</tt>)</a></h4>

<p align="JUSTIFY">
Ада имеет два предопределенных перечислимый типа, <tt>Character</tt> и <tt>Wide_Character</tt>,
для поддержки обработки символьных значений.
Согласно стандарта, любой перичислимый тип который содержит хотя бы один
символьный литерал является символьным типом.

<p align="JUSTIFY">
Оригинальный стандарт Ada83 описывал 7-битный тип <tt>Character</tt>.
Еще до появления стандарта Ada95, это ограничение было ослаблено,
но оставалось принудительным для старых компиляторов
(например таких как компилятор <i>Meridian Ada</i>).
Это создавало трудности при попытках отобразить графические символы на PC,
поскольку для отображения символов с кодами большими чем ASCII-127
приходилось использовать целые числа.
Такая поддержка обеспечивалась за счет специальных подпрограмм
предоставляемых разработчиками соответствующего компилятора.

<p align="JUSTIFY">
В настоящее время, предопределенный символьный тип <tt>Character</tt> предусматривает 256
различных символьных значений (то есть, является 8-битным), и
основывается на стандарте ISO-8859-1 (Latin-1).

<p align="JUSTIFY">
Некоторые символы не имеют непосредственно печатаемого значения (первые 32 символа).
Такие символы используются в качестве управляющих (примером может служить символ CR - возврат каретки).
Для обращения к таким символам можно использовать пакет <i>ASCII</i>, который
является дочерним пакетом пакета <i>Standard</i> (благодаря этому, нет необходимости
указывать пакет <i>ASCII</i> в спецификаторах контекста
<tt><b>with</b></tt> и/или <tt><b>use</b></tt>).
Например, для обращения к символу возврат каретки можно использовать: <tt>ASCII.CR</tt>.
Однако, пакет <i>ASCII</i> содержит только первые 128 символов и считается устаревшим, и
возможно, что в будущем он будет удален. Поэтому, вместо старого пакета <i>ASCII</i>
рекомендуется использовать пакет <i>Ada.Characters.Latin_1</i>, который предоставляет
256 символов. Следовательно, используя пакет <i>Ada.Characters.Latin_1</i>,
к символу возврата каретки можно обратиться следующим образом:
<tt>Ada.Characters.Latin_1.CR</tt>.

<p align="JUSTIFY">
Предопределенный символьный тип <tt>Wide_Character</tt>
основывается на стандарте ISO-10646 Basic Multilingual Plane (BMP) и предусматривает 65336
различных символьных значений (использует 16 бит).

<p align="JUSTIFY">
Также, Ада предоставляет пакет <i>Ada.Characters.Handling</i>, предлагающий
набор полезных подпрограмм символьной обработки.

<p align="JUSTIFY">
Система компилятора <i>GNAT</i> предоставляет дополнительный пакет <i>Ada.Characters.Wide_Latin_1</i>,
который описывает символьные значения типа <tt>Wide_Character</tt> соответствующие кодировке Latin_1.

<p align="JUSTIFY">
Таким образом, для работы с символьными значениями, в Аде представлены следующие пакеты:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Standard.ASCII                -- предоставляет только первые 128 символов
                              -- (считается устаревшим)

Ada.Characters                -- 
Ada.Characters.Latin_1        -- предоставляет 256 символов ISO-8859-1 (Latin-1)
Ada.Characters.Handling       -- предоставляет подпрограммы символьной обработки

Ada.Characters.Wide_Latin_1   -- дополнительный пакет из поставки
                              -- системы компилятора GNAT
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Следует заметить, что пакет <i>ASCII</i> считается устаревшим и его не рекомендуется использовать
при написании новых программ.
Вместо него необходимо использовать стандартный пакет <i>Ada.Characters.Latin_1</i>.

<p align="JUSTIFY">
Также следует заметить, что стандарт не требует полноценного обеспечения поддержки национальных
кодировок, которые отличны от кодировки Latin-1.
Возможность предоставления такой поддержки возлагается на разработчиков соответствующего компилятора.
Другими словами, в настоящее время,
обеспечение поддержки кириллических кодировок не регламентируется стандартом.




<p>
<h3><a name="s2.6">2.6 Типы и подтипы</a></h3>

<p align="JUSTIFY">
Как уже говорилось,
концепция типа является в Аде основопологающим фактором создания надежного программного обеспечения.
Предположим, что у нас есть два целочисленных типа, которые как-то характеризуют "звоночки" и
"свисточки", и мы никак не хотим смешивать эти понятия. Нам необходимо, чтобы компилятор
имел возможность предупредить нас: "Ба, да вы пытаетесь смешать выши "звоночки" и "свисточки"! Что Вы
в действительности подразумеваете?". Это выглядит излишними осложнениями для людей, которые
используют другие языки программирования со слабой типизацией данных.
Размышления над тем какие данные необходимо представить, описание различных типов данных и
правил конвертирования типов требуют некоторых усилий.
Однако, такие усилия оправдываются тем, что как только это сделано,
компилятор сможет помочь отыскать разные глупые ошибки.

<p align="JUSTIFY">
Бывают случаи, когда нам необходимо указать, что какие-то переменные могут хранить
только какое-то ограниченное число значений предоставляемых определенным типом данных.
При этом, мы не хотим описывать самостоятельный новый тип данных, поскольку это потребует
явного указания правила преобразования типа при взаимодействии со значениями, которые
имеют оригинальный тип данных, то есть нам необходима возможность смешивать различные типы,
которые, по своей сути, являются одинаковыми сущностями, но при этом имеют некоторые
различия в своих характеристиках. К тому же, мы хотим сохранить преимущества
проверки корректности наших действий, которые предоставляет компилятор.
В таких случаях, Ада позволяет нам описывать подтипы (<tt><b>subtype</b></tt>)
существующих типов данных (это соответствует типам определяемым пользователем в Паскале).


<p align="JUSTIFY">
Общий синтаксис объявления подтипа имеет вид:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>subtype</b> Name_1 <b>is</b> Base_Type;  -- в данном случае, Name_1 является
                              -- синонимом типа Base_Type

<b>subtype</b> Name_2 <b>is</b> Base_Type <b>range</b> Lowerbound..Upperbound;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Примеры объявления подтипов приводятся ниже:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Processors <b>is</b> (M68000, i8086, i80386, M68030, Pentium, PowerPC);
<b>subtype</b> Old_Processors <b>is</b> Processors <b>range</b> M68000..i8086;
<b>subtype</b> New_Processors <b>is</b> Processors <b>range</b> Pentium..PowerPC;

<b>subtype</b> Data <b>is</b> Integer;
<b>subtype</b> Age <b>is</b> Data <b>range</b> 0..140;
<b>subtype</b> Temperatures <b>is</b> Float <b>range</b> -50.0..200.0;
<b>subtype</b> Upper_Chars <b>is</b> Character <b>range</b> 'A'..'Z';
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Подтип, по своей сути, является той же самой сущностью, что
и оригинальный тип, но при этом он может иметь ограниченный диапазон значений оригинального типа.
Значения подтипа могут использоваться
везде, где могут использоваться значения оригинального типа,
а также значения других подтипов этого оригинального типа
При этом, любая попытка присваивания переменной такого подтипа значения
выходящего за границы указанного для этого подтипа диапазона допустимых значений
будет приводить к исключительной ситуации <i>Constraint_Error</i> (проще говоря - ошибке программы).
Такой подход облегчает обнаружение ошибок, а также,
позволяет отделить обработку ошибок от основного алгоритма программы.

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

My_Age  : Age;
Height  : Integer;

Height := My_Age;   -- глупо, но никогда не вызывает проблем

My_Age := Height;   -- может вызвать проблемы, когда значение типа <i>Height</i>
                    -- будет за пределами диапазона значений <i>My_Age (0..140)</i>,
                    -- но при этом остается совметимым
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Чтобы избежать генерацию исключительной ситуации, можно использовать
проверки принадлежности диапазону ("<tt><b>in</b></tt>" и/или "<tt><b>not in</b></tt>"). Например: 

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

I : Integer;
N : Natural;

    . . .

<b>if</b>  I <b>in</b> Natural  <b>then</b>
    N := I
<b>else</b>
    Put_Line ("I can't be assigned to N!");
<b>end if</b>;

    . . .
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Реально, все типы Ады являются подтипами анонимных типов, рассматриваемых как их <b>базовые типы</b>.
Поскольку базовые типы анонимны, то на них нельзя ссылаться по имени. При этом, для получения
базового типа можно использовать атрибут <tt><b>'<i>Base</i></b></tt>. Например,
<tt>Integer<b>'<i>Base</i></b></tt> - это базовый тип для <tt>Integer</tt>. Базовые типы
могут иметь или могут не иметь диапазон значений больший чем их подтипы. Это имеет
значение только в выражениях вида "<tt>A * B / C</tt>" которые, при вычислении промежуточных
значений, используют базовый тип. То есть, результат "<tt>A * B</tt>" может
выходить за пределы значений типа не приводя к генерации исключительной ситуации если
общий результат вычисленного значения всего выражения будет находиться в допустимом диапазоне
значений для данного типа.

<p align="JUSTIFY">
Таким образом, необходимо заметить, что проверка допустимости диапазона
производится только для значений подтипов, а
для значений базовых анонимных типов такая проверка не производится.
При этом, чтобы результат вычислений был математически корректен,
всегда производится проверка на переполнение.




<h3><a name="s2.7">2.7 Производные типы</a></h3>

<p align="JUSTIFY">
Мы уже рассмотрели, что подтипы остаются совместимыми со своими базовыми типами.
Однако, нам может понадобиться создать абсолютно новый тип, который не
будет ассоциироваться ни с каким другим типом вообще, в том числе и
с оригинальным типом.
Такая концепция типа сильно отличается от того, что принято в других языках программирования,
и, даже, в прародителе Ады - Паскале.

<p align="JUSTIFY">
Для выполнения поставленной задачи, мы производим новый тип от другого типа,
используя подобный синтаксис:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Child_Type <b>is new</b> Parent_Type;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Такое описание создает новый тип данных - <tt>Child_Type</tt>, при этом
<tt>Parent_Type</tt> - это тип-предок для типа <tt>Child_Type</tt>,
а тип <tt>Child_Type</tt> - это производный тип от типа <tt>Parent_Type</tt>.

<p align="JUSTIFY">
В данном случае, тип <tt>Child_Type</tt> будет обладать такими же характеристиками
что и его тип-предок <tt>Parent_Type</tt>: у него такой же диапазон допустимых значений
как и у типа-предка, для него допустимы те же операции, которые допустимы для типа-предка
(говорят, что тип <tt>Child_Type</tt> унаследовал операции от типа-предка
<tt>Parent_Type</tt>).

<p align="JUSTIFY">
Однако, в этом случае, производный тип <tt>Child_Type</tt> - это абсолютно самостоятельный
и независимый тип данных.
Он не совместим ни с каким другим типом, включая тип <tt>Parent_Type</tt>,
от которого он был произведен, и другими типами, производными от типа <tt>Parent_Type</tt>.
Это подразумевает, что при необходимости комбинирования значений типа <tt>Child_Type</tt>
со значениями типа <tt>Parent_Type</tt> требуется выполнять преобразование типов.
В Аде, разрешается выполнять преобразование значений производного типа
в значения типа-предка и наоборот.


<p align="JUSTIFY">
Для того, чтобы преобразовать значение одного типа в значение другого типа
необходимо указать имя типа к которому требуется выполнить преобразование:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Parent  : Parent_Type;
Child   : Child_Type := Child_Type (Parent);  -- конвертирует значение Parent,
                                              -- имеющее тип Parent_Type
                                              -- в значение типа Child_Type
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Описание производного типа может указывать ограничение диапазона значений типа-предка,
например:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Child_Type <b>is new</b> Parent_Type <b>range</b> Lowerbound..Upperbound;
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
В этом случае диапазон значений производного типа <tt>Child_Type</tt> будет ограничен
значениями нижней границы диапазона (<tt>Lowerbound</tt>) и
верхней границы диапазона (<tt>Upperbound</tt>).


<p align="JUSTIFY">
Механизм производства новых типов данных из уже существующих типов позволяет создавать
целые семейства родственных типов, которые обычно называют классами.
Так, например, тип <tt>Integer</tt> принадлежит к целому классу целочисленных типов.
Класс целочисленных типов является, в свою очередь, подмножеством более обширного класса
дискретных типов.

<p align="JUSTIFY">
Основной смысл использования производных типов заключается в том, что
для определенного типа данных уже существует определенный набор примитивных операций
и этот набор операций можно унаследовать от такого типа при производстве от него
нового типа данных.

<p align="JUSTIFY">
Можно создать новый тип данных и затем описать для него идентичный набор операций.
Однако, при производстве нового типа данных от уже существующего типа, производный тип
автоматически наследует версии примитивных операций, описанные для типа-предка.
Таким образом, нет необходимости переписывать код заново.

<p align="JUSTIFY">
Например, класс дискретных типов предусматривает атрибут <tt><b>'<i>First</i></b></tt>,
который наследуется всеми дискретными типами. Класс целочисленных типов добавляет
к унаследованным от класса дискретных типов операциям
знак операции арифметического сложения "<tt>+</tt>".
Эти механизмы более полно рассматриваются при обсуждении
тэговых типов.


<p align="JUSTIFY">
Производные типы используются в случаях когда моделирование определенного объекта
предполагает, что тип-предок не соответствует нашим потребностям, или тогда, когда мы желаем
разделить объекты в различные, несмешиваемые классы.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Employee_No <b>is new</b> Integer;
<b>type</b> Account_No  <b>is new</b> Integer <b>range</b> 0..999_999;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Здесь <tt>Employee_No</tt> и <tt>Account_No</tt> различные и не смешиваемые типы,
которые нельзя комбинировать между собой без явного использования преобразования типов.
Производные типы наследуют все операции объявленные для базового типа.
Например, если была объявлена запись которая имела процедуры <tt>Push</tt> и <tt>Pop</tt>,
то производный тип автоматически унаследует эти процедуры.

<p align="JUSTIFY">
Другое важное использование производных типов - это создание переносимого кода.
Ада разрешает нам создавать новые уровни абстракции, на один уровень выше чем, скажем,
абстракция целого числа на последовательности битов.


<p align="JUSTIFY">
Это определяется использованием производных типов, без типа-предка.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Name <b>is range</b> <i>&lt;некоторый_диапазон_значений&gt;</i>;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Например,


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Data <b>is range</b> 0..2_000_000;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В этом случае ответственность, за выбор подходящего размера для целого, ложится на компилятор.
Таким образом, для PC, этот размер может быть 32 бита, что эквивалентно типу <tt>Long_Integer</tt>,
а для рабочей станции Unix, этот размер можт остаться равным 32-битному целому,
но это будет эквивалентно типу <tt>Integer</tt>. Такое предоставление компилятору возможности
выбирать освобождает программиста от обязанности выбирать. Поэтому перекомпиляция
программы на другой машине не требует изменения исходного текста.



<p>
<h3><a name="s2.8">2.8 Атрибуты</a></h3>

<p align="JUSTIFY">
Ада предусматривает специальный класс предопределенных операций, которые позволяют
в удобной форме определять и использовать различные характеристики типов и экземпляров объектов.
Они называются атрибутами.

<p align="JUSTIFY">
Указание имени требуемого атрибута производится в конце имени экземпляра объекта
(переменной, константы) или имени типа с использованием символа одинарных кавычек.

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<i>имя_типа</i>'<i><b>имя_атрибута</b></i>
<i>имя_экземпляра_объекта</i>'<i><b>имя_атрибута</b></i>
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Некоторыми из атрибутов для дискретных типов являются:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Processors <b>is</b> (M68000, i8086, i80386, M68030, Pentium, PowerPC);

Integer<b>'<i>First</i></b>             -- наименьшее целое <i>Integer</i>
Integer<b>'<i>Last</i></b>              -- наибольшее целое <i>Integer</i>
Processors<b>'<i>Succ</i></b>(M68000)   -- последующее за M68000 в типе
Upper_Chars<b>'<i>Pred</i></b>('C')     -- предшествующее перед 'C' в типе ('B')
Integer<b>'<i>Image</i></b>(67)         -- строка " 67"
                          -- пробел для '-'
Integer<b>'<i>Value</i></b>("67")       -- целое значение 67
Processors<b>'<i>Pos</i></b>(M68030)    -- позиция M68030 в типе
                          -- (3, первая позиция - 0)
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Простым примером использования атрибутов, - для улучшения переносимости программы, - может служить
следующий пример описания подтипа <tt>Positive</tt>, предоставляющего положительные целые числа:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>subtype</b> Positive <b>is</b> Integer <b>range</b> 1..Integer<b>'<i>Last</i></b>;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Здесь мы получаем размер максимального положительного целого не зависимо
от любых системно зависимых свойств.

<p align="JUSTIFY">
В Ada83 для не дискретных типов, - таких как <tt>Float</tt>, <tt>Fixed</tt>, всех их подтипов
и производных от них типов, - концепции <tt><b>'<i>Pred</i></b></tt> и <tt><b>'<i>Succ</i></b></tt> -
не имеют смысла. В Ada95 - они присутствуют. Все другие атрибуты скалярных типов
также справедливы и для вещественных типов.

<p align="JUSTIFY">

<p align="JUSTIFY">
<!---
Полный список атрибутов приводится в приложении.
--->




<!--- footer --->




<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>




</blockquote>
</body>
</html>

