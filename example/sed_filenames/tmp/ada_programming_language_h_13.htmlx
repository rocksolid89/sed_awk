<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<title>Адское программирование.</title>
</head>


<body BGCOLOR="FFFFFF">
<basefont size=3>
<blockquote>

<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>



<!--- header --->



<h2><a name="s13">13. Тэговые типы (<i>tagged types</i>)</a></h2>

<p align="JUSTIFY">
Тэговые типы являются нововведением стандарта Ada95.

Они дополняют традиционную систему типов языка Ада, и позволяют обеспечить
полную поддержку объектно-ориентированного программирования.

Концептуально новыми особенностями тэговых типов являются
возможность расширения структуры данных типа при наследовании,
способствующая программированию посредством расширения, и
динамическая диспетчеризация вызовов примитивных операций,
являющаяся основой полиморфизма.



<p align="JUSTIFY">
Чтобы в последствии не породить терминологической путаницы,
необходимо сразу сделать одно важное замечание которое специально предназначено
для знатоков ООП, активно использующих другие языки программирования
(например, <i>C++</i> или какой-либо современный диалект Паскаля,
поддерживающий объектно-ориентированное расширение).

В традиционном понимании, слово "класс" трактуется как спецификация типа данных
и множество методов (операций) этого типа данных.

В отличие от этого, Ада трактует понятие "класс"
как набор типов которые объединены иерархией наследования.
<!---
--->



<p>
<h3><a name="s13.1">13.1 Механизмы наследования</a></h3>

<p align="JUSTIFY">
Согласно концепции производных типов Ады, которая известна со времен стандарта Ada-83,
производный тип наследует структуру данных и операции типа-предка.

Позже, для работы с производным типом, можно изменить унаследованные от типа-предка операции
и/или добавить к ним новые операции.

Хотя такая модель наследования является достаточно мощным инструментом,
она не позволяет нам дополнить унаследованную структуру данных
новыми элементами, то есть, мы не можем выполнять расширение типа при наследовании.




<p><h4><a name="s13.1.1">13.1.1 Расширение существующего типа данных</a></h4>

<p align="JUSTIFY">
Как было сказано ранее, тэговые типы, в отличие от обычных не тэговых типов,
позволяют осуществлять расширение структуры данных типа предка при наследовании.

Рассмотрим следующий пример описания:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Object_1 <b>is tagged</b>
    <b>record</b>
        Field_1 : Integer;
    <b>end record</b>;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В данном случае тип <tt>Object_1</tt> содержит всего одно поле
<tt>Field_1</tt> типа <tt>Integer</tt>, и описан как тэговый тип.

Не трудно заметить, что внешний вид такого описания
подобен описанию обычной записи, и отличается только наличием
зарезервированного слова <tt><b>tagged</b></tt>, которое, собственно, и указывает
на то, что описываемый тип является тэговым типом.
<!---
, и подразумевает,
что каждый экземпляр объекта этого типа содержит некий скрытый "тэг",
используемый для идентификации типа.
--->

 

<p align="JUSTIFY">
Теперь, в качестве примера, мы можем описать производные от <tt>Object_1</tt> типы,
расширяя их новыми компонентами следующим образом:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Object_2 <b>is new</b>  Object_1  <b>with</b>
    <b>record</b>
        Field_2 : Integer;
    <b>end record</b>;

<b>type</b> Object_3 <b>is new</b>  Object_2  <b>with</b>
    <b>record</b>
        Field_3 : Integer;
    <b>end record</b>;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В данном примере, тип <tt>Object_2</tt> является производным типом от типа <tt>Object_1</tt>,
а тип  <tt>Object_3</tt> - производным типом от типа <tt>Object_2</tt>.

Таким образом, в результате показанных описаний, получилась следующая иерархия типов:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

          Object_1
             |
          Object_2
             |
          Object_3
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Следует заметить, что тип, производный от тэгового типа, также будет являться тэговым типом.

Поэтому все описанные выше типы: <tt>Object_1</tt>, <tt>Object_2</tt> и <tt>Object_3</tt>, -
являются тэговыми типами, и, следовательно, обладают способностью расширения.

<p align="JUSTIFY">
В результате показанных выше описаний,
типы <tt>Object_1</tt>, <tt>Object_2</tt> и <tt>Object_3</tt>
будут содержать следующие поля:


<p>
<dir><table BGCOLOR="FFFFFF" border=0 width="45%">
<tr>
<th width="33%"><font size=1>Object_1</th>
<th width="33%"><font size=1>Object_2</th>
<th width="33%"><font size=1>Object_3</th>
</tr>

<tr>
<td align="CENTER"><font size=1><tt>Field_1</tt></td>
<td align="CENTER"><font size=1><tt>Field_1</tt></td>
<td align="CENTER"><font size=1><tt>Field_1</tt></td>
</tr>

<tr>
<td align="CENTER"><font size=1>&nbsp;</td>
<td align="CENTER"><font size=1><tt>Field_2</tt></td>
<td align="CENTER"><font size=1><tt>Field_2</tt></td>
</tr>

<tr>
<td align="CENTER"><font size=1>&nbsp;</td>
<td align="CENTER"><font size=1>&nbsp;</td>
<td align="CENTER"><font size=1><tt>Field_3</tt></td>
</tr>
</table></dir>


<p align="JUSTIFY">
Примечательным фактом является то, что описание типа <tt>Object_2</tt>
не указывает явно наличие поля <tt>Field_1</tt>.

Это поле наследуется от типа <tt>Object_1</tt>.

Также, описание типа <tt>Object_3</tt>
не указывает явно наличие полей <tt>Field_1</tt> и <tt>Field_2</tt>.

Эти поля наследуются от типа <tt>Object_2</tt>.





<p><h4><a name="s13.1.2">13.1.2 Описание переменных и преобразование типов</a></h4>


<p align="JUSTIFY">
В отличие от других объектно-ориентированных языков программирования,
Ада не использует каких либо специальных конструкторов,
поэтому объекты (иначе переменные) тэговых типов могут быть описаны обычным образом.

Инициализация индивидуальных полей может быть выполнена отдельно или
с помощью агрегатов. Например:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>declare</b>
    Instance_1  : Object_1;
    Instance_2  : Object_2;
    Instance_3  : Object_3;
<b>begin</b>
    Instance_1.Field_1 := 1;
    Instance_2 := ( 1, 2 );
    Instance_3 := ( Field_1 => 1,
                    Field_2 => 2,
                    Field_3 => 3 );
    . . .
<b>end</b>;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Ада позволяет выполнять явное преобразование типов при преобразовании типа потомка к типу
предка (снизу-вверх). Так, используя приведенные в предыдущем примере описания,
можно выполнить следующие преобразования:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

    . . .
    Instance_1 := Object_1 (Instance_3);
    Instance_2 := Object_2 (Instance_3);
    . . .
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
При таком преобразовании типов значение дополнительных полей потомка просто отбрасываются.


<p align="JUSTIFY">
Кроме того, допускается выполнение преобразования типов от предка к потомку (сверху-вниз).

Этот случай несколько сложнее, поскольку потомок может содержать дополнительные поля,
которые отсутствуют у типа предка.

В таких случаях используются расширяющие агрегаты, например:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

    . . .
    Instance_2 := (Instance_1 <b>with</b> 2);
    Instance_3 := (Instance_1 <b>with</b> Field_2 => 2, Field_3 => 3);
    . . .
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Следует заметить, что клиентские программы не часто используют эти средства,
поскольку тэговые типы, как правило, описываются как приватные типы.


<p><h4><a name="s13.1.3">13.1.3 Примитивные и не примитивные операции над тэговыми типами<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                                Наследование операций</a></h4>


<p align="JUSTIFY">
Концепция примитивной операции типа имеет важное значение в Аде.

В общем случае, примитивная операция над типом <tt>T</tt> -
это или предопределенный знак операции
(например, знаки операций для выполнения действий над целыми числами типа <tt>Integer</tt>),
или операция (подпрограмма или знак операции)
которая описывается в том же самом пакете в котором описывается тип <tt>T</tt>
вслед за описанием типа <tt>T</tt>, и принимает параметр типа  <tt>T</tt>
или возвращает значение типа  <tt>T</tt> (в случае функции).

При этом, необходимо обратить особое внимание на тот факт,
что все примитивные операции являются наследуемыми.

<p align="JUSTIFY">
Концепция примитивной операции приобретает дополнительную важность в случае с тэговыми типами,
поскольку обращения к примитивным операциям над тэговыми типами являются
потенциально диспетчеризуемыми вызовами,
а это, в свою очередь, является одним из базовых механизмов обеспечения динамической полиморфности
объектов тэговых типов.


<p align="JUSTIFY">
Следует также заметить, что если тэговый тип должен иметь какие-либо примитивные операции,
то он должен быть описан в спецификации пакета.

Описание тэгового типа в подпрограмме, с последующим описанием операций над этим тэговым типом
не подразумевает того, что такие операции будут примитивными.

Также, если в пакете описывается другой тэговый тип, производный от первого описанного
в этом пакете тэгового типа, то после описания второго тэгового типа становится невозможным
описание примитивных операций для первого тэгового типа (обратное будет подразумевать, что
второй теговый тип способен наследовать примитивные операции которые еще не описаны).

<p align="JUSTIFY">
Для уточнения сказанного рассмотрим следующий пример:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Simple_Objects  <b>is</b>

    <b>type</b> Object_1 <b>is tagged</b>
        <b>record</b>
            Field_1 : Integer;
        <b>end record</b>;

    -- примитивные операции типа Object_1
    <b>procedure</b> Method_1 (Self: <b>in out</b> Object_1);


    <b>type</b> Object_2 <b>is new</b>  Object_1  <b>with</b>
        <b>record</b>
            Field_2 : Integer;
        <b>end record</b>;

    -- примитивные операции типа Object_2
    <b>procedure</b> Method_2 (Self: <b>in out</b> Object_2);
    <b>procedure</b> Method_2 (Self: <b>in out</b> Object_1); -- НЕДОПУСТИМО!!!
                -- должна быть примитивной операцией для Object_1,
                -- но недопустима поскольку следует за описанием типа Object_2
                -- который является производным от типа Object_1

<b>end</b> Simple_Objects;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В подобных случаях говорят, что описание типа <tt>Object_1</tt>
становится "замороженным" при обнаружении описания типа <tt>Object_2</tt>,
производного от типа <tt>Object_1</tt>.

Подобное "замораживание" осуществляется также в случаях когда
обнаруживается описание какого-либо объекта (переменной) типа <tt>Object_1</tt>.

Как только описание типа "заморожено", описание примитивных операций этого типа
становится невозможным.


<p align="JUSTIFY">
Следует также обратить внимание на то,
как выполняется наследование примитивных операций, -
подобных подпрограмме <tt>Method_1</tt> для типа <tt>Object_1</tt>,
в показанном выше примере, -
для производного типа.


Подразумевается, что такие операции идентичным образом описываются неявно
сразу за описанием производного типа.

Причем, тип парамета, где тип параметра соответствует типу предка,
заменяется на производный тип.

Таким образом, для приведенного выше примера, в случае типа <tt>Object_2</tt>,
выполняется неявное описание операции <tt>Method_1</tt>,
наследуемой  от типа-предка <tt>Object_1</tt>.

Такое неявное описание будет иметь следующий вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

    . . .
    <b>procedure</b> Method_1 (Self: <b>in out</b> Object_2);
    . . .
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Бывают случаи, когда необходимо описать подпрограмму которая не будет наследоваться
потомками тэгового типа, то есть, описать подпрограмму так, чтобы она не являлась
примитивной операцией типа.

Типичными примерами таких подпрограмм могут служить
функция, которая создает экземпляр объекта тэгового типа и возвращает его в качестве результата,
или процедура инициализации полей объекта тэгового типа
(назначение таких подпрограмм подобно конструкторам в других языках программирования).

Опасность наследования подобных подпрограмм заключается в том,
что подпрограмма предка не имеет никаких сведений о дополнительных полях
которые описаны в объекте-потомке как расширение типа-предка.

Следовательно, результат работы таких подпрограмм, в случае производного типа, будет не корректным
(точнее - не полным).


<p align="JUSTIFY">
Решением подобной проблемы,
при описании пакета содержащего тэговый тип,
может служить размещение описаний таких подпрограмм во внутреннем пакете.

В качестве примера, рассмотрим следующее описание:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Simple_Objects  <b>is</b>

    <b>type</b> Object_1 <b>is tagged</b>
        <b>record</b>
            Field_1 : Integer;
        <b>end record</b>;

    -- примитивные операции типа Object_1
    <b>procedure</b> Method_1 (Self: <b>in out</b> Object_1);
    . . .


    <b>package</b> Constructors  <b>is</b>    -- внутренний пакет содержащий не наследуемые
                                --   операции типа Object_1

        <b>function</b>  Create (Field_1_Value: <b>in</b> Integer) <b>return</b> Object_1;
        . . .

    <b>end</b> Constructors;
    . . .

<b>end</b> Simple_Objects;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Здесь, функция <tt>Create</tt>, которая возвращает значение типа <tt>Object_1</tt>,
расположена во внутреннем пакете <i>Constructors</i>.

В результате такого описания, функция <tt>Create</tt>
(а также другие подпрограммы для типа <tt>Object_1</tt>,
расположенные во внутреннем пакете <i>Constructors</i>)
не будет наследоваться потомками типа <tt>Object_1</tt>
(типами, производными от типа <tt>Object_1</tt>).

<!---
<p align="JUSTIFY">
Следует заметить, что такое решение не лишено недостатков.

Несомненно - оно надежно работает.

Однако, некоторой платой за надежность является
затруднение автоматической генерации кода
и хотя бы однократное принудительное копирование объектов после их создания.
--->

<p align="JUSTIFY">
В заключение обсуждения наследования операций над тэговыми типами,
следует сделать одно важное замечание.

Поскольку производные типы явно не отображают операции которые они наследуют от
своих типов-предков, то могут возникнуть трудности в понимании того,
какие операции реально выполняются над объектами конкретного производного типа.

Действительно, для получения таких сведений необходимо изучить исходные тексты
с описаниями всех типов-предков требуемого производного типа.

Осуществление этого может быть достаточно трудоемким процессом для сложной иерархии типов.

Для справедливости, следует заметить, что такая проблема характерна не только для Ады,
но и для остальных объектно ориентированных языков программирования.






<p><h4><a name="s13.1.4">13.1.4 "Пустые" записи (<i>null record</i>) и расширения</a></h4>


<p align="JUSTIFY">
Достаточно часто возникает необходимость создания типа который не имеет полей (атрибутов),
а имеет только операции (методы). 

Как правило, подобный тип используется для последующего построения целой
иерархии типов как базовый (или корневой) тип.

Это может быть достигнуто описанием "пустой" записи при описании типа:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Root <b>is tagged</b>
    <b>record</b>
        <b>null</b>;
    <b>end record</b>;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Для таких случаев, Ада обеспечивает специальный синтаксис описания "пустых" записей:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Root <b>is tagged null record</b>;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Описание операций над таким типом традиционно, и может быть выполнено
в спецификации пакета:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Do_Something(Item : <b>in out</b> Root);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Также, бывают случаи, когда описание нового производного типа не нуждается
в расширении (нет добавления новых полей),
но при этом добавляются новые подпрограммы или переопределяются старые.

Вид описания такого расширения следующий:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Child <b>is new</b> Root <b>with null record</b>;

<b>procedure</b> Child_Method (Item : <b>in out</b> Child);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В результате такого описания получается новый
тип <tt>Child</tt>, производный от типа <tt>Root</tt>,
который не будет иметь дополнительных компонентов, но имеет
дополнительный метод - <tt>Child_Method</tt>.






<p><h4><a name="s13.1.5">13.1.5 Абстрактные типы и подпрограммы</a></h4>



<p align="JUSTIFY">
В большинстве случаев, типы которые разрабатываются как родоначальники иерархий производных типов
не предназначены для непосредственного описания объектов (переменных).

Такие типы называют абстрактными, а для их описания используется
зарезервированное слово <tt><b>abstract</b></tt>.

Например:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Empty_Root <b>is abstract tagged null record</b>;

<b>type</b> Simple_Root <b>is abstract tagged</b>
    <b>record</b>
        Simple_Field: Integer;
    <b>end record</b>;
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Здесь, в первом случае, тип <tt>Empty_Root</tt> - это абстрактный тип является
"пустой" записью которая не содержит никаких полей.
В свою очередь, тип <tt>Simple_Root</tt>, который также описан как абстрактный,
содержит единственное поле <tt>Simple_Field</tt> типа <tt>Integer</tt>.



<p align="JUSTIFY">
Абстрактный тип может иметь абстрактные подпрограммы.

Абстрактными называют подпрограммы которые фактически не имеют тела (то есть реализации),
а это значит, что они обязательно должны быть переопределены в производных типах.

Смысл использования описания абстрактного типа с абстрактными подпрограммами
заключается в том, что все производные типы, в последствии,
будут вынуждены поддерживать общую логическую функциональность.

<p align="JUSTIFY">
Описание абстрактного типа имеющего абстрактные подпрограммы может иметь следующий вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Sets <b>is</b>
    <b>type</b> Set <b>is abstract tagged null record</b>;

    <b>function</b> Empty <b>return</b> Set <b>is abstract</b>;
    <b>function</b> Empty(Element : Set) <b>return</b> Boolean <b>is abstract</b>;
    <b>function</b> Union(Left, Right : Set) <b>return</b> Set <b>is abstract</b>;
    <b>function</b> Intersection(Left, Right : Set) <b>return</b> Set <b>is abstract</b>;
    <b>procedure</b> Insert(Element : Natural; Into : Set) <b>is abstract</b>;
<b>end</b> Sets;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Это описание множества натуральных чисел взято из справочного руководства по языку Ада.

Примечательно то, что компиляор не позволит описать переменную типа <tt>Set</tt>,
поскольку тип <tt>Set</tt> - это абстрактный тип.

Таким образом, следующий пример не будет компилироваться:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Sets;        <b>use</b> Sets;

<b>procedure</b> Wont_Compile <b>is</b>

    My_Set : Set;        -- НЕДОПУСТИМО!!! абстрактный тип

<b>begin
    null</b>;
<b>end</b> Wont_Compile;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Как правило, тип, производный от абстрактного, обеспечивает реализацию
функциональности которая была задана в абстрактном типе предке.

Например:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Sets;

<b>package</b> Quick_Sets <b>is</b>

    <b>type</b> Bit_Vector <b>is array</b>(0..255) <b>of</b> Boolean;
    <b>pragma</b> Pack (Bit_Vector);

    <b>type</b> Quick_Set <b>is new</b> Sets.Set <b>with</b>
        <b>record</b>
            Bits : Bit_Vector := (<b>others</b> =&gt; False);
        <b>end record</b>;

    -- объявление конкретной реализации
    <b>function</b> Empty <b>return</b> Quick_Set;
    <b>function</b> Empty(Element : Quick_Set) <b>return</b> Boolean;

    . . .

</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Показанный выше схематический пример описывает тип <tt>Quick_Set</tt>,
производный от абстрактного типа <tt>Set</tt>.

В этом примере, тип <tt>Quick_Set</tt> осуществляет реализацию
функциональности которая была задана в абстрактном типе <tt>Set</tt>.

В результате, после описания типа <tt>Quick_Set</tt>,
мы можем описывать и использовать объекты типа <tt>Quick_Set</tt>
логическая функциональность которых будет
соответствовать функциональности абстрактного типа <tt>Set</tt>.




<p align="JUSTIFY">
Необходимо также заметить, что Ада позволяет чтобы вновь описываемый тип,
производный от абстрактного типа, также был абстрактным.

Используя такие возможности можно разработать иерархию абстрактных типов,
которая будет определять логическую функциональность программной подсистемы или всего
программного проекта.



<p>
<h3><a name="s13.2">13.2 Динамическое связывание и полиморфизм</a></h3>



<p align="JUSTIFY">
Обеспечение полиморфности поведения объектов полагается на механизм который осуществляет
связывание места вызова подпрограммы с конкретной реализацией (телом) подпрограммы.


<p align="JUSTIFY">
Следует заметить, что механизм совмещения имен подпрограмм и знаков операций Ады,
при использовании традиционных не тэговых типов,
обладает свойством полиморфизма.

<!---
<p align="JUSTIFY">
Также следует заметить, что механизм наследования операций является достаточно тонкой формой
механизма совмещения имен.

При описании производного типа, выполняется совмещение унаследованных примитивных операций предка
с операциями которые имеют такой же профиль, но с соответственной заменой
типа предка на тип производного типа.
--->


Действительно, одно и то же имя может быть использовано для целого множества
различных реализаций подпрограмм (что, собствено, и является полиморфностью).

Однако, как мы знаем, все совмещаемые операции должны быть различимы по профилю.

Таким образом, до настоящего момента предполагалось, что реализация подпрограммы,
которую необходимо вызвать для обработки объекта,
всегда точно определяется на этапе компиляции программы.

В результате, в подобных случаях, и полиморфизм, предоставляемый механизмом совмещения,
и связывание называют статическими, поскольку типы всех обрабатываемых объектов
известны на этапе компиляции.


<p align="JUSTIFY">
При использовании тэговых типов,
некоторые объекты могут принадлежать одному иерархическому образованию класса
и обладать некоторыми общими логическими свойствами
(напомним, что понятие "класс" Ады отличается от понятия "класс",
которое используется в других объектно-ориентированных языках программирования).

Следовательно, выполнение обработки таких объектов по единым логическим правилам
будет более предпочтительным.

Однако, в такой ситуации фактический тип индивидуального объекта не может быть определен вплоть
до начала выполнения программы.

А это значит, что связывание места вызова подпрограммы с конкретной реализацией подпрограммы
должно осуществляться в процессе выполнения программы на основе информации о фактическом типе объекта
во время выполнения программы.

В таких ситуациях, и связывание, и полиморфизм называют динамическими.



<p><h4><a name="s13.2.1">13.2.1 Надклассовые типы (<i>wide class types</i>)</a></h4>


<p align="JUSTIFY">
Все типы, производные и расширенные (прямо или косвенно) от определенного тэгового типа <tt>T</tt>,
принадлежат одному иерархическому образованию класса, корнем которого будет тэговый тип <tt>T</tt>.

Тэговый тип <tt>T</tt> неявно ассоциирован с надклассовым типом
который обозначает целый класс типов - иерархию включающую данный тэговый тип <tt>T</tt>
и все производные от него типы.

Надклассовый тип не имеет явного имени и обозначается как атрибут <tt>T<b>'<i>Class</i></b></tt>,
где <tt>T</tt> - имя соответствующего тэгового типа.

В таком контексте, явно описанные типы удобно называть индивидуальными типами,
чтобы подчеркнуть их отличие от надклассовых типов.


<p align="JUSTIFY">
В иерархическом образовании класса каждый индивидуальный тип идентифицируется тэгом (<i>tag</i>),
который скрыто присутствует в каждом тэговом типе (отсюда, собственно, и название "тэговые" типы).

Наличие такой информации позволяет осуществлять идентификацию индивидуального типа объекта
во время выполнения программы (то есть, динамически)
и, используя результат такой идентификации, находить для этого объекта
соответствующую реализацию операций.


<p align="JUSTIFY">
Следует также заметить, что такой подход является некоторым ослаблением
традиционной модели строгой типизации Ады,
поскольку любой тип, производный от типа <tt>T</tt>, может быть неявно преобразован
в надклассовый тип <tt>T<b>'<i>Class</i></b></tt>.


<p align="JUSTIFY">
Для демонстрации сказанного, предположим, что у нас имеется следующая иерархия типов:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

                 Root
                  |
         -----------------
         |               |
      Child_1         Child_2
                         |
                         |
                         |
                   Grand_Child_2_1
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Предположим также, что спецификация пакета, описывающего показанную выше иерархию типов,
имеет следующий вид
(заметим, что пустые записи и расширения использованы для упрощения примера):


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Simple_Objects  <b>is</b>

    -- тип Root  и его примитивные операции

    <b>type</b> Root <b>is tagged null record</b>;

    <b>function</b> The_Name (Self: <b>in</b> Root) <b>return</b> String;
    <b>procedure</b> Show (Self: <b>in</b> Root<b>'<i>Class</i></b>);


    -- тип Child_1  и его примитивные операции

    <b>type</b> Child_1 <b>is new</b>  Root  <b>with null record</b>;

    <b>function</b> The_Name (Self: <b>in</b> Child_1) <b>return</b> String;


    -- тип Child_2  и его примитивные операции

    <b>type</b> Child_2 <b>is new</b>  Root  <b>with null record</b>;

    <b>function</b> The_Name (Self: <b>in</b> Child_2) <b>return</b> String;


    -- тип Grand_Child_2_1  и его примитивные операции

    <b>type</b> Grand_Child_2_1 <b>is new</b>  Child_2  <b>with null record</b>;

    <b>function</b> The_Name (Self: <b>in</b> Grand_Child_2_1) <b>return</b> String;

<b>end</b> Simple_Objects;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В этом случае, все типы показанной иерархии
(<tt>Root</tt>, <tt>Child_1</tt>, <tt>Child_2</tt> и <tt>Grand_Child_2_1</tt>)
будут принадлежать к надклассовому типу <tt>Root<b>'<i>Class</i></b></tt>.


<p align="JUSTIFY">
Надклассовые типы могут быть использованы при описании переменных, параметров подпрограмм
и объектов ссылочного типа.


<p align="JUSTIFY">
При описании любой переменной надклассового типа, следует учитывать,
что любой надклассовый тип <tt>T<b>'<i>Class</i></b></tt>
является неограниченным, а это значит, что компилятору заранее не известен размер
резервируемого для размещения такой переменной пространства.

Следовательно, при описании переменной надклассового типа, необходимо обязательно предусматривать
инициализацию такой переменной начальным значением:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

V : T<b>'<i>Class</i></b> := <i>значение_инициализации</i> ;
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
В результате выполнения инициализации, для значения переменной надклассового типа,
будет осуществляться фиксирование индивидуального типа переменной,
которое будет сохраняется на протяжении всего времени жизни данной переменной.

Следует заметить, что <tt><i>значение_инициализации</i></tt>, в свою очередь,
может быть динамически вычисляемым выражением.



<p align="JUSTIFY">
С учетом приведенной ранее иерархии типов,
рассмотрим простой пример следующего описания переменной:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Instance : Root<b>'<i>Class</i></b> := Child_1<b>'</b>(Root <b>with null record</b>);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Здесь, <tt>Instance</tt> - это переменная надклассового типа <tt>Root<b>'<i>Class</i></b></tt>,
а ее индивидуальный тип указывается значением инициализации как тип <tt>Child_1</tt>.




<p align="JUSTIFY">
Формальный параметр подпрограммы также может иметь надклассовый тип.

В таком случае, каждый фактический параметр,
принадлежащий к иерархическому образованию класса (или, короче, - к классу),
будет совместим с формальным параметром.

Такие подпрограммы не будут ограничены использованием только одного специфического типа
и могут принимать парараметр тип которого принадлежит указанному классу.

Как правило, такие подпрограммы называют надклассовыми подпрограммами. Например:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Show (Self : <b>in</b> Root<b>'<i>Class</i></b>);
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В результате, любой фактический параметр, который принадлежит надклассовому типу
<tt>Root<b>'<i>Class</i></b></tt> тэгового типа <tt>Root</tt>
(напомним, что это все типы, производные от типа <tt>Root</tt>)
будет совместим с формальным параметром <tt>Self</tt>. Например:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>declare</b>

    Root_Instance             : Root;
    Child_1_Instance          : Child_1;
    Child_2_Instance          : Child_2;
    GRand_Child_2_1_Instance  : GRand_Child_2_1;

    Instance : Root<b>'<i>Class</i></b> := Child_1<b>'</b>(Root <b>with null record</b>);

<b>begin</b>

    Show (Root_Instance);
    Show (Child_1_Instance);
    Show (Child_2_Instance);
    Show (GRand_Child_2_1_Instance);
    Show (Instance);

<b>end</b>;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Надклассовые типы могут быть использованы при описании ссылочных типов:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Root_Ref <b>is access</b> Root<b>'<i>Class</i></b>;
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Как правило, описанные подобным образом типы называют типами надклассовых ссылок,
а использование подобных типов в программе
позволяет создавать переменные которые, во время выполнения программы, будут способны
хранить значения с типами принадлежащими любому типу класса:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>declare</b>

    Any_Instance:  Root_Ref;

<b>begin</b>
    Any_Instance := <b>new</b> Child_1<b>'</b>(Root <b>with null record</b>);

        . . .

    Any_Instance := <b>new</b> Child_2<b>'</b>(Root <b>with null record</b>);
        . . .
<b>end</b>;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В показанном выше примере, переменная <tt>Any_Instance</tt> имеет тип надклассовой ссылки
<tt>Root_Ref</tt> и может обозначать любой объект который принадлежит классу
<tt>Root<b>'<i>Class</i></b></tt>.

Таким образом, как показано в примере, индивидуальным типом объекта
обозначаемого переменной <tt>Any_Instance</tt> сначала будет тип <tt>Child_1</tt>,
а затем - <tt>Child_2</tt>.


<p><h4><a name="s13.2.2">13.2.2 Проверка типа объекта во время выполнения программы</a></h4>


<p align="JUSTIFY">
В процессе выполнения программы можно осуществить проверку объекта
на принадлежность его к какому-либо индивидуальному типу
путем использования атрибута <tt><b>'<i>Tag</i></b></tt>

<p align="JUSTIFY">
Чтобы продемонстрировать это, предположим, что реализация процедуры <tt>Show</tt>
описывается следующим образом:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Show (Self: <b>in</b> Root<b>'<i>Class</i></b>) <b>is</b>
<b>begin</b>

    <b>if</b>    Self<b>'<i>Tag</i></b> = Root<b>'<i>Tag</i></b>  <b>then</b>
        Ada.Text_IO.Put_Line ("Root");
    <b>elsif</b> Self<b>'<i>Tag</i></b> = Child_1<b>'<i>Tag</i></b>  <b>then</b>
        Ada.Text_IO.Put_Line ("Child_1");
    <b>elsif</b> Self<b>'<i>Tag</i></b> = Clild_2<b>'<i>Tag</i></b>  <b>then</b>
        Ada.Text_IO.Put_Line ("Clild_2");
    <b>elsif</b> Self<b>'<i>Tag</i></b> = Grand_Child_2_1<b>'<i>Tag</i></b>  <b>then</b>
        Ada.Text_IO.Put_Line ("Grand_Child_2_1");
    <b>else</b>
        Ada.Text_IO.Put_Line ("Unknown type");
    <b>end if</b>;

<b>end</b> Show;
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Кроме того, в процессе выполнения программы, возможно осуществление проверки
принадлежности (или не принадлежности) типа объекта к какому-либо классу.

Для выполнения таких проверок используются операции проверки диапазона "<tt><b>in</b></tt>"
и "<tt><b>not in</b></tt>":


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

    . . .
    <b>if</b>  Some_Instance <b>in</b> Child_1<b>'<i>Class</i></b>   <b>then</b>
        . . .
    <b>end if</b>;
    . . .
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
В данном примере выполняется проверка принадлежности переменной <tt>Some_Instance</tt>
к иерархии типов, корнем которой будет тип <tt>Child_1</tt>,
причем, предполагается, что переменная <tt>Some_Instance</tt>
является переменной надклассового или тэгового типа.

<p align="JUSTIFY">
Следует также обратить внимание на то, что для выполнения этой проверки
используется "<tt>Some_Instance <b>in</b> Child_1<b>'<i>Class</i></b></tt>",
а не "<tt>Some_Instance <b>in</b> Child_1</tt>".




<p><h4><a name="s13.2.3">13.2.3 Динамическая диспетчеризация</a></h4>


<p align="JUSTIFY">
При внимательном рассмотрении показанной ранее реализации процедуры <tt>Show</tt>
не трудно заметить, что хотя она и использует средства тэговых типов,
позволяющие определить фактический тип объекта во время выполнения программы,
аналогичный результат мог бы быть получен путем использования
вместо тэговых типов обычных записей с дискриминантами.

<p align="JUSTIFY">
В данном случае, подразумевается, что если мы решим описать новый тип,
производный от любого типа входящего в показанную иерархию
(<tt>Root</tt>, <tt>Child_1</tt>, <tt>Child_2</tt> и <tt>Grand_Child_2_1</tt>),
то результатом работы такой реализации процедуры <tt>Show</tt>
всегда будет сообщение "<tt>Unknown type</tt>", извещающее о том,
что фактический тип параметра <tt>Self</tt> - не известен.

Например, такая ситуация может возникнуть когда мы опишем новый тип <tt>Grand_Child_1_1</tt>,
производный от типа <tt>Child_1</tt>, в каком-либо другом пакете.

<p align="JUSTIFY">
С первого взгляда может показаться, что будет достаточно переписать процедуру <tt>Show</tt>
с учетом нового типа <tt>Grand_Child_1_1</tt>.

Действительно, такое решение будет работать, но это значит, что при описании
каждого нового типа, входящего в эту иерархию, мы вынуждены вносить изменения
в уже написанные и отлаженные модули.

<p align="JUSTIFY">
Для того, чтобы избавиться от таких трудностей, реализацию процедуры <tt>Show</tt>
надо действительно переписать, но так, чтобы задействовать механизм динамической
диспетчеризации вызовов подпрограмм, который предоставляет использование тэговых типов.

<p align="JUSTIFY">
Вспомним, что при демонстрации примера иерархии типов,
был также приведен пример спецификации пакета <i>Simple_Objects</i>,
в котором эта иерархия типов описывается.

Теперь, перед непосредственным обсуждением механизма динамической диспетчеризации
вызовов подпрограмм, предположим, что описание тела этого пакета имеет следующий вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b>  Ada.Text_IO;

<b>package body</b> Simple_Objects  <b>is</b>

    -- примитивные операции типа Root

    <b>function</b> The_Name (Self: <b>in</b> Root) <b>return</b> String <b>is</b>
    <b>begin</b>
        <b>return</b> ("Root");
    <b>end</b> The_Name;
    
    <b>procedure</b> Show (Self: <b>in</b> Root<b>'<i>Class</i></b>) <b>is</b>
    <b>begin</b>
        Ada.Text_IO.Put_Line ( The_Name(Self) );
    <b>end</b> Show;


    -- примитивные операции типа Child_1

    <b>function</b> The_Name (Self: <b>in</b> Child_1) <b>return</b> String <b>is</b>
    <b>begin</b>
        <b>return</b> ("Child_1");
    <b>end</b> The_Name;


    -- примитивные операции типа Child_2

    <b>function</b> The_Name (Self: <b>in</b> Child_2) <b>return</b> String <b>is</b>
    <b>begin</b>
        <b>return</b> ("Child_2");
    <b>end</b> The_Name;


    -- примитивные операции типа Grand_Child_2_1

    <b>function</b> The_Name (Self: <b>in</b> Grand_Child_2_1) <b>return</b> String <b>is</b>
    <b>begin</b>
        <b>return</b> ("Grand_Child_2_1");
    <b>end</b> The_Name;

<b>end</b> Simple_Objects;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Не сложно догадаться, что особое внимание следует обратить на реализацию процедуры
<tt>Show</tt>, которая теперь, перед вызовом <tt>Ada.Text_IO.Put_Line</tt>,
выдающим строку сообщения,
вызывает функцию <tt>The_Name</tt>, возвращающую строку которая, собственно,
содержит текст сообщения.

Заметим также, что важным моментом в этой реализации является то, что процедура <tt>Show</tt>
имеет формальный параметр надклассового типа, что позволяет ей принимать в качестве
фактического параметра любые объекты тип которых принадлежит данной иерархии типов.

<p align="JUSTIFY">
При дальнейшем внимательном рассмотрении спецификации и тела пакета <i>Simple_Objects</i>,
следует обратить внимание на то, что функция <tt>The_Name</tt> описана для всех типов иерархии
(<tt>Root</tt>, <tt>Child_1</tt>, <tt>Child_2</tt> и <tt>Grand_Child_2_1</tt>)
и является примитивной операцией для этих типов.

Напомним, что в случае тэговых типов, примитивные операции являются потенциально
диспетчеризуемыми операциями.

<p align="JUSTIFY">
В результате, процедура <tt>Show</tt>, принимая во время выполнения программы фактический параметр,
осуществляет диспетчеризацию вызова соответствующей реализации функции <tt>The_Name</tt>
на основании информации о тэге фактического параметра.

Это значит, что в данном случае присутствует динамическое связывание
которое обеспечивает динамическую полиморфность поведения объектов.



<p align="JUSTIFY">
Таким образом, для выполнения диспетчеризации вызова подпрограммы во время выполнения программы
должно соблюдаться два условия:

<ul>
<li>подпрограмма должна иметь формальный параметр тэгового типа
<li>при вызове подпрограммы, фактический параметр, соответствующий параметру тэгового типа
должен быть объектом надклассового типа
</ul>

<p align="JUSTIFY">
Следовательно, если фактический надклассовый тип
представляет объекты двух или более индивидуальных типов,
которые имеют подпрограммы с одинаковыми параметрами (исключая параметр надклассового типа), то
определение реализации подпрограммы на этапе компиляции (иначе, статическое связывание) не возможно.

Вместо этого, осуществляется динамическое связывание во время выполнения программы.


<p align="JUSTIFY">
Возвращаясь к проблеме с которой мы начинали обсуждение диспетчеризации, следует заметить, что
использование этого механизма в процедуре <tt>Show</tt>,
позволяет теперь описывать новые типы, производные от любого типа входящего в иерархию,
без необходимости изменения реализации процедуры <tt>Show</tt>.

Действительно, при описании нового производного типа, достаточно описать
соответствующую реализацию функции <tt>The_Name</tt> для нового типа,
не внося никаких изменений в ранее написанные модули.

Заметим также, что если при описании нового производного типа
не будет предусмотрена реализация функции <tt>The_Name</tt>,
то для этого типа процедура <tt>Show</tt>, используя диспетчеризацию, будет вызывать реализацию
функции <tt>The_Name</tt> унаследованную от типа предка.


<p align="JUSTIFY">
Мы рассмотрели случай динамической диспетчеризации в подпрограмме
при описании которой используется формальный параметр надклассового типа.

Следует заметить, что вызов подпрограммы с параметром надклассового ссылочного типа также является
диспетчеризуемым:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

    ... The_Name(Any_Instance<b>.all</b>)...
        -- Any_Instance может обозначать объект который принадлежит любому
        -- типу класса Root<b>'<i>Class</i></b>
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Еще одним случаем диспетчеризации является использование переменной надклассового типа.
В этом случае нужно обратить внимание на отличие диспетчеризуемого вызова
от обычного вызова:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>declare</b>
    Instance_1 : Root;
    Instance_2 : Root<b>'<i>Class</i></b> ... ;
<b>begin</b>
    ... The_Name(Instance_1)...
        -- статическое связывание: компилятор знает индивидуальный тип
        -- Instance_1, поэтому он может определить реализацию

    ... The_Name(Instance_2)...
        -- динамическое связывание: Instance_2 может принадлежать любому
        -- типу класса Root<b>'<i>Class</i></b>
        -- поэтому компилятор не может точно определить реализацию
        -- подпрограммы, она будет выбрана во время выполнения программы
<b>end</b> ;
</pre></dir>
</td></tr></table>





<p><h4><a name="s13.2.4">13.2.4 Модель механизма диспетчеризации</a></h4>


<p align="JUSTIFY">
Для лучшего понимания особенностей использования тэговых типов и свойств диспетчеризации
вызовов операций,
может оказаться полезным рассмотрение возможной модели реализации механизма диспетчеризации.

Следует подчеркнуть, что не смотря на достаточную реалистичность нашей модели,
мы рассматриваем только возможную модель, сознательно опуская множество нюансов,
а это значит,
что реализация для какого-либо конкретного компилятора может не соответствовать
этой модели.


<p align="JUSTIFY">
Согласно нашей модели, подразумевается, что тэг - это указатель на таблицу диспетчеризации вызовов.

Каждый элемент такой таблицы содержит указатель на реализацию подпрограммы которая является
примитивной операцией.

Диспетчеризация осуществляется путем выполнения косвенного вызова
с помощью таблицы диспетчеризации, а необходимая примитивная операция выбирается как
соответствующий индекс элемента в таблице диспетчеризации.


<p align="JUSTIFY">
Таким образом, наша модель для рассмотренной ранее иерархии типов 
(<tt>Root</tt>, <tt>Child_1</tt>, <tt>Child_2</tt> и <tt>Grand_Child_2_1</tt>)
будет иметь следующий вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

                         ------------
Root<b>'<i>Tag</i></b>            ---&gt; | The_Name |---&gt; The_Name для Root
                         ------------


                         ------------
Child_1<b>'<i>Tag</i></b>         ---&gt; | The_Name |---&gt; The_Name для Child_1
                         ------------


                         ------------
Child_2<b>'<i>Tag</i></b>         ---&gt; | The_Name |---&gt; The_Name для Child_2
                         ------------


                         ------------
Grand_Child_2_1<b>'<i>Tag</i></b> ---&gt; | The_Name |---&gt; The_Name для Grand_Child_2_1
                         ------------
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Следует заметить, что наша иллюстрация максимально упрощена и не содержит
множества предопределенных примитивных операций, кроме того,
описания типов иерархии также были очень простыми.


<p align="JUSTIFY">
Базовый адрес каждой таблицы соответствует значению тэга и содержится
в значении надклассового объекта.

Примечательно также, что в таблицах диспетчеризации не содержатся указатели на надклассовые операции
(подобные процедуре <tt>Show</tt>), поскольку они не являются диспетчеризуемыми операциями.


<p align="JUSTIFY">
Таким образом, при динамическом связывании во время выполнения программы,
на основе информации о тэге объекта осуществляется выбор соответствующей таблицы
диспетчеризации.

Далее, по выбранной таблице, осуществляется косвенный вызов подпрограммы,
для которой индекс в таблице соответствует требуемой примитивной операции.


<p align="JUSTIFY">
Для лучшей демонстрации этой идеологии,
предположим теперь, что мы решили описать новый тип <tt>Grand_Child_1_1</tt>,
производный от типа <tt>Child_1</tt>, следующим образом:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b>  Simple_Objects;   <b>use</b>   Simple_Objects;

<b>package</b> Simple_Objects_New  <b>is</b>

    <b>type</b> Grand_Child_1_1 <b>is new</b>  Child_1  <b>with null record</b>;

    <b>procedure</b> New_Method (Self: <b>in</b> Grand_Child_1_1);
    <b>procedure</b> New_Method_Call (Self: <b>in</b> Grand_Child_1_1<b>'<i>Class</i></b>);
        . . .

<b>end</b> Simple_Objects_New;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Дополнительно предположим, что далее в пакете <i>Simple_Objects_New</i> описываются типы,
производные от типа <tt>Grand_Child_1_1</tt>, и то, что реализация надклассовой процедуры
<tt>New_Method_Call</tt> выполняет диспетчеризуемый вызов процедуры <tt>New_Method</tt>.

Тогда, в этом описании содержится два примечательных факта:

<ul>
<li>Мы сознательно не определили для типа <tt>Grand_Child_1_1</tt>
реализацию функции <tt>The_Name</tt>.
Следовательно, она будет унаследована от типа <tt>Child_1</tt>
<li>Описание типа <tt>Grand_Child_1_1</tt> определяет
новую примитивную диспетчеризуемую операцию - процедуру <tt>New_Method</tt>.
</ul>


<p align="JUSTIFY">
Согласно нашей модели, вид тэга для типа <tt>Grand_Child_1_1</tt> будет следующий:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

                         --------------
Grand_Child_1_1<b>'<i>Tag</i></b> ---&gt; | The_Name   |---&gt; The_Name для Child_1
                         --------------
                         | New_Method |---&gt; New_Method для Grand_Child_1_1
                         --------------
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Из данной иллюстрация видно, что поскольку тип <tt>Grand_Child_1_1</tt>
не имеет собственной реализации функции <tt>The_Name</tt>,
то таблица диспетчеризации, которая соответствует его тэгу,
содержит указатель на реализацию функции <tt>The_Name</tt>
для его предка, типа <tt>Child_1</tt>.

Таким образом, вызов процедуры <tt>Show</tt>, для типа <tt>Grand_Child_1_1</tt>,
осуществит вызов унаследованной от типа <tt>Child_1</tt> реализации функции <tt>The_Name</tt>
(в соответствии с индексом в таблице диспетчеризации).


<p align="JUSTIFY">
Примечательно также, что описание новой примитивной операции (процедура <tt>New_Method</tt>)
обусловило появление нового элемента в таблице диспетчеризации
для типа <tt>Grand_Child_1_1</tt>.



<p><h4><a name="s13.2.5">13.2.5 Вызов  переопределенной операции предка</a></h4>


<p align="JUSTIFY">
Достаточно часто, реализация примитивной операции производного типа нуждается
в вызове переопределенной примитивной операции предка.

Предположим, что для типов <tt>Root</tt> и <tt>Child_1</tt>
существуют описания операции <tt>Display</tt> имеющие следующий вид:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

    . . .
<b>procedure</b> Display (Self: <b>in</b> Root);
<b>procedure</b> Display (Self: <b>in</b> Child_1);
    . . .
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Поскольку такие операции совмещены, то можно сказать, что реализация операции <tt>Display</tt>
типа <tt>Root</tt> (предка для типа <tt>Child_1</tt>)
является "затененной", в виду переопределения реализации в производном типе <tt>Child_1</tt>.


<p align="JUSTIFY">
В таком случае, для вызова "затененной" операции предка можно использовать следующее:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Display (Self: <b>in</b> Child_1) <b>is</b>
<b>begin</b>
    Display ( Root(Self) ); -- вызов "затененной" операции предка
    . . .
<b>end</b> Display;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Здесь, для вызова "затененной" реализации операции предка,
используется явное преобразование представления параметра <tt>Self</tt>
к типу <tt>Root</tt>.

За счет этого, в подобных случаях, всегда осуществляется статическое связывание,
а также отсутствует опасность получения бесконечного рекурсивного вызова.

<!---
Преобразование представления используется для вызова "затененной" реализации операции предка,
таким образом, здесь не получается бесконечный рекурсивный вызов.
--->




<p><h4><a name="s13.2.6">13.2.6 Динамическая передиспетчеризация</a></h4>


<p align="JUSTIFY">
Известно, что производный тип всегда может переопределить примитивную операцию своего предка,
то есть, предусмотреть свою собственную реализацию примитивной операции.

В случае использования классов, необходимо заботиться в правильном распознавании
вызова реализации для потомка от вызова реализации для предка.

Рассмотрим следующий схематический вариант реализации процедуры
<tt>Display</tt> для типа <tt>Root</tt>:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure </b>Display (Self: <b>in</b> Root) <b>is</b>
<b>begin</b>
    Put ( The_Name(Self) &amp; ... ); -- ???
    . . .
<b>end</b> Display;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В данном случае, при вызове реализации <tt>Display</tt> для типа <tt>Child_1</tt>,
которая была показана ранее,
первая же инструкция выполняет вызов затененной реализации предка,
то есть, реализации для типа <tt>Root</tt>:
<tt>Display ( Root(Self) )</tt>.


<p align="JUSTIFY">
Показанный пример реализации процедуры <tt>Display</tt> для типа <tt>Root</tt>
всегда будет выполнять вызов функции <tt>The_Name</tt> полагая,
что индивидуальным типом параметра <tt>Self</tt> является тип <tt>Root</tt>.

Таким образом, этот вызов будет статически связан с реализацией
функции <tt>The_Name</tt> для типа <tt>Root</tt>.


<p align="JUSTIFY">
Следовательно, при вызове реализации процедуры <tt>Display</tt> для типа <tt>Child_1</tt>,
в результате вызова затененной реализации предка
будет получена та же строка имени, что и для типа <tt>Root</tt>.


<p align="JUSTIFY">
Для того, чтобы процедура <tt>Display</tt> для типа <tt>Root</tt>
правильно осуществила вызов той реализации функции <tt>The_Name</tt>
которая соответствует фактическому индивидуальному типу параметра <tt>Self</tt>
ее необходимо переписать следующим образом:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure </b>Display (Self: <b>in</b> Root) <b>is</b>
<b>begin</b>
    Put ( The_Name( Root<b>'<i>Class</i></b>(Self) ) &amp; ... ); -- передиспетчеризация
    . . .
<b>end</b> Display;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В данном случае, в реализации процедуры <tt>Display</tt> для типа <tt>Root</tt>
выполняется преобразование параметра <tt>Self</tt>
к типу <tt>Root<b>'<i>Class</i></b></tt> предусматривая передиспетчеризацию вызова
к корректной реализации <tt>The_Name</tt>, в зависимости от тэга параметра <tt>Self</tt>.




<p><h4><a name="s13.2.7">13.2.7 Двойная диспетчеризация</a></h4>


<p align="JUSTIFY">
Бывают случаи, когда при описании в одном пакете двух различных тэговых типов
возникает желание описать подпрограмму которая принимает параметры обоих тэговых типов.

В подобной ситуации получается, что такая подпрограмма
будет считаться примитивной операцией для обоих типов.

Однако, компилятор должен иметь какой-нибудь способ определения того,
какой параметр использовать для диспетчеризации.

Чтобы, яснее представить суть подобной проблемы,
рассмотрим следующий (не корректный!!!) пример


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b>  Message_Type  <b>is</b>
    <b>tagged record</b>
        . . .
    <b>end record</b>;

<b>type</b>  Output_Device <b>is</b>
    <b>tagged record</b>
        . . .
    <b>end record</b>;

<b>procedure</b> Put (M : <b>in</b> Message_Type; D : <b>in</b> Output_Device);
            -- записать сообщение M в устройство вывода D (не допустимо!!!)

    . . .
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
На первый взгляд, идея выглядит достаточно логично,
при наличии различных типов устройств вывода
иметь процедуру, которая позволяет выдать определенного типа сообщение
в устройство вывода определенного типа.

Каждый тип сообщения может переопределить соответствующим образом
процедуру вывода <tt>Put</tt> для того чтобы осуществить свой вывод
необходимым образом.

Каждый тип устройства вывода переопределяет процедуру <tt>Put</tt>
с целью использования средств предоставляемых устройством вывода.


Однако, при вызове процедуры <tt>Put</tt> становится не понятным какую версию
этой процедуры необходимо использовать, ту которая определена в типе, производном
от типа <tt>Message_Type</tt>, или ту которая определена в типе, производном
от типа <tt>Output_Device</tt>.


<p align="JUSTIFY">
Ада решает эту проблему очень просто: использование подпрограмм
которые являются примитивными операциями для двух (и более) тэговых типов,
подобно процедуре <tt>Put</tt>, - не допускается.

Следовательно, необходимо изменить описание процедуры таким образом,
чтобы она была примитивной операцией только для одного типа.

Примером такой модификации может служить следующее:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Put (M : <b>in</b> Message_Type;
               D : <b>in</b> Output_Device<b>'<i>Class</i></b>);
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Теперь, параметр <tt>D</tt> больше не имеет тип <tt>Output_Device</tt>,
а значит, процедура <tt>Put</tt> больше не является примитивной операцией для типа
<tt>Output_Device</tt>.

Однако, внутри процедуры, значение <tt>Output_Device<b>'<i>Class</i></b></tt>
приведет к осуществлению диспетчеризации в случае вызова примитивной операции для типа
<tt>Output_Device</tt>.

Подобный прием называют двойной диспетчеризацией.

Например, предположим, что тип <tt>Output_Device</tt> имеет следующую примитивную
операцию:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Write_Output (D : <b>in</b> Output_Device; S : <b>in</b> String);
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В этом случае, тип <tt>Message_Child_Type</tt>,
производный от типа <tt>Message_Type</tt>, может переопределить реализацию
процедуры <tt>Put</tt> приблизительно следующим образом:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Put (M : <b>in</b> Message_Child_Type;
               D : <b>in</b> Output_Device<b>'<i>Class</i></b>) is
<b>begin</b>
    Put (Message_Type(M), D);    -- вызов версии Put предка
    . . .
    Write_Output (D, ... );      -- отображение данных сообщения
    . . .
<b>end</b> Put;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Вызов процедуры <tt>Put</tt>, осуществленный с вовлечением параметра надклассового типа,
который соответствует типу <tt>Message_Child_Type</tt>,
и параметром с определенным типом устройства вывода
приведет к вызову показанной выше версии процедуры <tt>Put</tt>.

Это приведет к тому, что отображение данных сообщения будет осуществлено
с помощью процедуры <tt>Write_Output</tt>, реализация которой будет выбрана в результате
диспетчеризации.



<p>
<h3><a name="s13.3">13.3 Стандартные низкоуровневые средства, пакет <i>Ada.Tags</i></a></h3>


<p align="JUSTIFY">
Стандартным низкоуровневым средством работы с тэговыми типами является пакет <i>Ada.Tags</i>.

Спецификация этого пакета, согласно стандарта, имеет следующий вид:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Ada.Tags <b>is</b>

    <b>type</b> Tag <b>is private</b>;

    <b>function</b> Expanded_Name(T : Tag) <b>return</b> String;
    <b>function</b> External_Tag(T : Tag) <b>return</b> String;
    <b>function</b> Internal_Tag(External : String) <b>return</b> Tag;

    Tag_Error : <b>exception</b>;

<b>private</b>

    . . .   -- стандартом не определено

<b>end</b> Ada.Tags;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
<!---
The function Expanded_Name returns the full expanded name of the first subtype 
of the specific type identified by the tag, in upper case, starting with a root library
unit. 

The result is implementation defined if the type is declared within an unnamed block_statement.
--->
Функция <tt>Expanded_Name</tt> возвращает полное расширенное имя типа,
индефицируемого значением тэга, в виде строки (в верхнем регистре).

Результат будет зависеть от реализации компилятора, если тип описан внутри неименованного
блока инструкций.


<p align="JUSTIFY">
<!---
The function External_Tag returns a string to be used in an external representation 
for the given tag. 

The call External_Tag(S'Tag) is equivalent to the
attribute_reference S'External_Tag. 
--->
Функция <tt>External_Tag</tt> возвращает строку, которая может быть использована
для внешнего представления указанного тэга.

Вызов <tt>External_Tag(S<b>'<i>Tag</i></b>)</tt> эквивалентен обращению к атрибуту
<tt>S<b>'<i>External_Tag</i></b></tt>.


<p align="JUSTIFY">
<!---
The function Internal_Tag returns the tag that corresponds to the given external tag, 
or raises Tag_Error if the given string is not the external tag for any specific type
of the partition. 
--->
Функция <tt>Internal_Tag</tt> возвращает тэг который соответствует указанному
внешнему представлению тэга, или возбуждает исключение <tt>Tag_Error</tt>
если ни для одного из типов, в пределах раздела программы,
указанная строка не является внешним представлением тэга.





<!--- footer --->




<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>




</blockquote>
</body>
</html>

