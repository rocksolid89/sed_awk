<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<title>Адское программирование.</title>
</head>


<body BGCOLOR="FFFFFF">
<basefont size=3>
<blockquote>

<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>



<!--- header --->



<h2><a name="s5">5. Записи (<i>record</i>)</a></h2>

<p align="JUSTIFY">
Понятие записи, также как и понятие массива, является механизмом структурирования данных.
Однако, в отличие от массива, запись позволяет сгруппировать в одном объекте
набор объектов которые могут принадлежать различным типам.
При этом объекты из которых состоит запись часто называют компонентами или полями записи.

<p align="JUSTIFY">
Для работы с записями, Ада предлагает средства подобные тем, которые предоставляют
другие современные языки программирования, а также дополняет их некоторыми своими особенностями.
Также как и для массивов, для записей предусматривается использование агрегатов.
Использование дискриминантов позволяет создавать вариантные записи,
указывать размер для записи переменного размера и выполнять инициализацию компонентов записи.


<p>
<h3><a name="s5.1">5.1 Простые записи</a></h3>



<p><h4><a name="s5.1.1">5.1.1 Описание простой записи</a></h4>

<p align="JUSTIFY">
Как уже было сказано, запись - это структура данных состоящая из набора различных
компонентов. В Аде, для описания такой структуры данных, необходимо описать тип записи.
В общем случае, описание типа записи имеет следующий вид:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> <i>&lt;имя_записи&gt;</i> <b>is</b> 
    <b>record</b>
        <i>&lt;имя_поля_1&gt;</i> : <i>&lt;тип_поля_1&gt;</i>;
        <i>&lt;имя_поля_2&gt;</i> : <i>&lt;тип_поля_2&gt;</i>;
            . . .
        <i>&lt;имя_поля_N&gt;</i> : <i>&lt;тип_поля_N&gt;</i>;
    <b>end record</b>;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Например:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Bicycle <b>is</b>
    <b>record</b>
        Frame       : Construction;
        Maker       : Manufacturer;
        Front_Brake : Brake_Type;
        Rear_Brake  : Brake_Type;
    <b>end record</b>;

My_Bicycle  : Bicycle;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Примечательно, что описание индивидуальных компонентов записи выглядит как описание переменных.
Также, следует заметить, что описание типа записи не создает экземпляр объекта записи.
В приведенном выше примере, тип <tt>Bicycle</tt> описывает структуру записи, а переменная
<tt>My_Bicycle</tt> типа <tt>Bicycle</tt> - является экземпляром записи.

<p align="JUSTIFY">
В отличие от массивов, Ада не позволяет создавать анонимные записи.
Таким образом, следующий пример описания будет неправильным:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

My_Bicycle  : <b>record</b>                          -- использование анонимных
                                              -- записей - ЗАПРЕЩЕНО!!!
                  Frame       : Construction;
                  Maker       : Manufacturer;
                  Front_Brake : Brake_Type;
                  Rear_Brake  : Brake_Type;
              <b>end record</b>;
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Из этого следует, что сначала необходимо описать тип записи, а затем описывать объекты
этого типа.



<p><h4><a name="s5.1.2">5.1.2 Значения полей записи по-умолчанию</a></h4>

<p align="JUSTIFY">
При описании записи, полям записи могут быть назначены значения по-умолчанию.
Эти значения будут использоваться всякий раз при создании экземпляра записи данного типа
(до тех пор пока они не будут инициализированы другими значениями).

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Bicycle <b>is</b>
    <b>record</b>
        Frame       : Construction := CromeMolyebdenum;
        Maker       : Manufacturer;        
        Front_Brake : Brake_Type   := Cantilever;
        Rear_Brake  : Brake_Type   := Cantilever;
    <b>end record</b>;
</pre></dir>
</td></tr></table>



<p><h4><a name="s5.1.3">5.1.3 Доступ к полям записи</a></h4>

<p align="JUSTIFY">
В Аде организация доступа к индивидуальным полям записи осуществляется с помощью точечной нотации,
за именем переменной-записи, которое сопровождается точкой, следует имя поля записи.
Например:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Expensive_Bike  : Bicycle;

Expensive_Bike.Frame        := Aluminium;
Expensive_Bike.Manufacturer := Cannondale;
Expensive_Bike.Front_Brake  := Cantilever;
Expensive_Bike.Rear_Brake   := Cantilever;        

<b>if</b> Expensive_Bike.Frame = Aluminium <b>then</b> ...
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Это идентично организации доступа к полям записи в таких языках
программирования как Паскаль или Си.





<p><h4><a name="s5.1.4">5.1.4 Агрегаты для записей</a></h4>

<p align="JUSTIFY">
Так же как и в случае массива,
все множество значений элементов записи может присваиваться с помощью агрегата.
При этом агрегат должен предоставлять значения для всех компонентов записи даже в случаях
когда некоторые компоненты обеспечены значениями по-умолчанию.
Для записей различают агрегаты использующие <b>позиционную</b>, <b>именованную</b> и <b>смешанную</b>
нотацию.

<p align="JUSTIFY">
Примером использования <b>позиционного</b> агрегата может служить следующее:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Expensive_Bike := (Aluminium, Cannondale, Cantilever, Cantilever);
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
При позиционной нотации порядок следования присваиваемых значений в агрегате
соответствует порядку следования полей в описании типа записи.

<p align="JUSTIFY">
Альтернативно позиционной нотации, показанной выше,
для присваивания таких же значений полям переменной <tt>Expensive_Bike</tt>
можно применить агрегат использующий <b>именованную</b> нотацию.
В этом случае поля записи могут перечисляться в произвольном порядке:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Expensive_Bike := (
                   Rear_Brake   =&gt; Cantilever
                   Front_Brake  =&gt; Cantilever,
                   Manufacturer =&gt; Cannondale,
                   Frame        =&gt; Aluminium,
                  );
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Для записей допускается смешивать в одном агрегате оба варианта нотации.
При этом все позиционные значения должны предшествовать именованным значениям.
Такой вариант нотации будет <b>смешанным</b>.

<p align="JUSTIFY">
Также как и в случае агрегатов для массивов, в агрегатах для записей допускается использование
опции <tt><b>others</b></tt>.
При этом, для опции <tt><b>others</b></tt> должен быть представлен
хотя бы один компонент, а в случае когда для опции <tt><b>others</b></tt> предоставляется более
одного компонента, все компоненты должны иметь один и тот же тип.

<p align="JUSTIFY">
Агрегаты являются удобным средством указания значений полей при описании переменных и констант:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Expensive_Bike :  Bicycle := (Aluminium, Cannondale, Cantilever, Cantilever);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Одинаковые значения могут присваиваться разным полям записи
при использовании символа '|'.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Expensive_Bike := (
                   Frame                    =&gt; Aluminium,
                   Manufacturer             =&gt; Cannondale,
                   Front_Brake | Rear_Brake =&gt; Cantilever
                  );
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В заключение обсуждения применения агрегатов для записей рассмотрим следующий
обобщающий пример:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Summary  <b>is
    record</b>
      Field_1 : Boolean;
      Field_2 : Float;
      Field_3 : Integer;
      Field_4 : Integer;
    <b>end record</b>;

Variable_1  : Summary := (True, 10.0, 1, 1);  -- позиционная нотация
Variable_2  : Summary := (                    -- именованная нотация
                          Field_4 =&gt; 1
                          Field_3 =&gt; 1,
                          Field_2 =&gt; 10.0,
                          Field_1 =&gt; True
                         );
Variable_2  : Summary := (                    -- смешанная нотация
                          True, 10.0,
                          Field_4 =&gt; 1,
                          Field_3 =&gt; 1
                         );

-------------------------- использование символа '|'
Variable_4  : Summary := (
                          True, 10.0,
                          Field_3|Field_4 =&gt; 1
                         );
Variable_5  : Summary := (
                          Field_1 =&gt; True,
                          Field_2 =&gt; 10.0,
                          Field_3|Field_4 =&gt; 1
                         );

-------------------------- использование others
Variable_6  : Summary := (True, 10.0, <b>others</b> =&gt 1);
Variable_7  : Summary := (
                          Field_1 =&gt; True,
                          Field_2 =&gt; 10.0,
                          <b>others</b> =&gt; 1
                         );
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">





<p><h4><a name="s5.1.5">5.1.5 Записи-константы</a></h4>

<p align="JUSTIFY">
Записи-константы могут быть созданы также как и обычные переменные.
В этом случае значения всех полей записи должны быть инициализированы
с помощью агрегата или значений определенных по-умолчанию.

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

My_Bicycle : <b>constant</b> Bicycle := ( Hi_Tensile_Steel,
                                   Unknown,
                                   Front_Brake =&gt; Side_Pull,
                                   Rear_Brake  =&gt; Side_Pull );
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Присваивать новые значения полям записи-константы или самой записи-константе <b>нельзя</b>.
Необходимо также заметить, что отдельные поля записи не могут быть описаны как константы.





<p><h4><a name="s5.1.6">5.1.6 Лимитированные записи</a></h4>


<p align="JUSTIFY">
Тип записи может быть описан как лимитированная запись.

В качестве примера, рассмотрим следующие описания:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b>  Person  <b>is  limited</b>
    <b>record</b>
        Name    : String(1..Max_Chs); -- строка имени
        Height  : Height_Cm := 0;     -- рост в сантиметрах
        Sex     : Gender;             -- пол
    <b>end record</b>;

Mike    : Person;
Corrina : Person;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В случае, когда тип записи является лимитированной записью,
компилятор не позволяет выполнять присваивание и сравнение
экземпляров этого типа записи.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

  . . .
Mike    := Corrina;       -- ОШИБКА КОМПИЛЯЦИИ!!!
                          -- для лимитированных записей присваивание запрещено
  . . .

<b>if</b>  Corrina = Mike  <b>then</b>  -- ОШИБКА КОМПИЛЯЦИИ!!!
                          -- для лимитированных записей сравнение запрещено
    Put_Line("This is strange");
<b>end if</b>;
  . . .
</pre></dir>
</td></tr></table>




<p align="JUSTIFY">
В результате,
при компиляции показанного выше кода,
будут выдаваться сообщения об ошибке компиляции.



<p>
<h3><a name="s5.2">5.2 Вложенные структуры</a></h3>

<p align="JUSTIFY">
В качестве компонентов записи можно использовать составные типы.
Например, полем записи может быть массив или какая-либо другая запись.
Таким образом, Ада предоставляет возможность построения описаний сложных структур данных.
Однако, описания таких структур данных обладают некоторыми характерными особенностями
на которые необходимо обратить внимание.


<p><h4><a name="s5.2.1">5.2.1 Поля типа массив</a></h4>

<p align="JUSTIFY">
В случаях когда какой-либо компонент записи необходимо описать как массив
необходимо учесть, что такой компонент не может быть указан как анонимный массив.
Это означает, что тип массива для такого компонента записи должен быть предварительно описан.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b>  Illegal <b>is
    record</b>
        Simple_Field_1: Boolean;
        Simple_Field_2: Integer;
        Array_Field   : <b>array</b> (1..10) <b>of</b> Float; -- использование
                                                -- анонимного массива
                                                -- ЗАПРЕЩЕНО!!!
    <b>end record</b>;


<b>type</b>  Some_Array  <b>is array</b> (1..10) <b>of</b> Float;    -- предварительно описанный
                                                -- тип массива
<b>type</b>  Legal <b>is
    record</b>
        Simple_Field_1: Boolean;
        Simple_Field_2: Integer;
        Array_Field   : Some_Array;             -- компонент предварительно
                                                -- описанного типа массив
    <b>end record</b>;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Также следует учесть, что в качестве компонентов записей
не допускается использование неограниченных массивов.
Рассмотрим следующий пример:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b>  Some_Array  <b>is array</b> (Integer <b>range</b> &lt;&gt;) of Float; -- неограниченный
                                                        -- массив
<b>type</b>  Some_Record <b>is
    record</b>
        Field_1: Boolean;
        Field_2: Integer;
        Field_3: Some_Array (1..10);  -- описание компонента записи
                                      -- задает ограничение индекса
    <b>end record</b>;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Здесь, тип <tt>Some_Array</tt> - это неограниченный массив. Поэтому,
при описании поля <tt>Field_3</tt> записи <tt>Some_Record</tt>
указывается ограничение значений индекса для массива - <tt>(1..10)</tt>.
После этого, компонент <tt>Field_3</tt> становится ограниченным массивом.

<p align="JUSTIFY">
Для доступа к индивидуальному компоненту поля  <tt>Field_3</tt>
какой-либо переменной типа <tt>Some_Record</tt> можно использовать:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

. . .
Some_Var :  Some_Record;
. . .
Some_Var.Field_3(1) := 1;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Для инициализации всех значений какой-либо переменной типа <tt>Some_Record</tt>
можно использовать агрегаты. В качестве демонстрации, приведем несколько примеров.

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Some_Var_1 :  Some_Record := (False, 0, (1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
Some_Var_2 :  Some_Record := (
                              Field_1 =&gt; False,
                              Field_2 =&gt; 0,
                              Field_3 =&gt; (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
                             );

Some_Var_3 :  Some_Record := (
                              Field_1 =&gt; True,
                              Field_2 =&gt; 10,
                              Field_3 =&gt; (<b>others</b> =&gt; 0)
                             );
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Из приведенных примеров видно, что для инициализации простых полей
<tt>Field_1</tt> и <tt>Field_2</tt>
записей <tt>Some_Var_1</tt>, <tt>Some_Var_2</tt>, <tt>Some_Var_3</tt>
типа <tt>Some_Record</tt> используются обычные литералы соответствующего типа,
а для инициализации поля <tt>Field_3</tt>, которое является массивом,
используется агрегат массива.
Таким образом, для инициализации подобных структур необходимо
использовать вложенные агрегаты.



<p><h4><a name="s5.2.2">5.2.2 Поля записей типа <tt>String</tt></a></h4>

<p align="JUSTIFY">
Частным случаем использования массивов в качестве компонентов записей являются строки <tt>String</tt>.
Тип <tt>String</tt>, по сути, является предопределенным неограниченным массивом символов,
поэтому для строк, при описании полей записи, допускается
как предварительное описание какого-либо строкового типа или подтипа,
так и непосредственное использование типа <tt>String</tt>. Например:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b>    Name_String     <b>is new</b> String(1..10);
<b>subtype</b> Address_String  <b>is</b> String(1..20);

<b>type</b>  Person  <b>is
    record</b>
        First_Name: Name_String;
        Last_Name : Name_String;
        Address   : Address_String;
        Phone     : String(1..15);
    <b>end record</b>;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В приведенном выше примере описания типа записи <tt>Person</tt>,
для описания полей <tt>First_Name</tt> и <tt>Last_Name</tt>
используется самостоятельный строковый тип <tt>Name_String</tt>, производный
от типа <tt>String</tt>.
Для описания поля <tt>Address</tt>, используется подтип <tt>Address_String</tt>.
Следует заметить, что тип <tt>Name_String</tt> и подтип <tt>Address_String</tt>,
оба описывают ограниченные строки (или массивы символов).
При описании поля <tt>Phone</tt> непосредственно использован тип <tt>String</tt>.
В этом случае, для типа <tt>String</tt>, указывается ограничение для значений индекса -
<tt>(1..15)</tt>.

<p align="JUSTIFY">
Для строковых полей, вместо агрегатов массива допускается использование строковых литералов.
Например:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Chief : Person := (
                    First_Name  =&gt; "Matroskin ",
                    Last_Name   =&gt; "Kot       ",
                    Address     =&gt; "Prostokvashino      ",
                    Phone       =&gt; "8-9-222-333    "
                  );
</pre></dir>
</td></tr></table>




<p><h4><a name="s5.2.3">5.2.3 Вложенные записи</a></h4>

<p align="JUSTIFY">
Бывают случаи, когда компонент записи сам является записью,
или, говоря иначе, требуется использование вложенных записей.
Например:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b>  Point <b>is record</b>
    X : Integer;
    Y : Integer;
<b>end record</b>

<b>type</b> Rect <b>is record</b>
    Left_Hight_Corner : Point;
    Right_Low_Corner  : Point;
<b>end record</b>

P : Point := (100, 100);
R : Rect;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В этом случае, доступ к полям переменной <tt>R</tt> типа <tt>Rect</tt>
может быть выполнен следующим образом:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

R.Left_Hight_Corner.X := 0;
R.Left_Hight_Corner.Y := 0;

R.Right_Low_Corner := P;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Для указания всех значений можно использовать агрегаты.

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

R_1 : Rect := ( (0, 0), (100, 100) );
R_2 : Rect := (
                Left_Hight_Corner =&gt; (Y =&gt; 0, X =&gt; 0),
                Right_Low_Corner  =&gt; (100, 100)
              );
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Как видно из приведенных примеров, здесь используются вложенные агрегаты.




<p>
<h3><a name="s5.3">5.3 Дискриминанты</a></h3>

<p align="JUSTIFY">
Особенность всех ранее рассмотренных записей в том,
что они всегда имеют строго определенные структуры.
Действительно, число полей таких записей и их размеры строго
зафиксированы на этапе описания типа записи и никак не могут быть изменены впоследствии.
Однако, в реальной жизни, достаточно часто возникают ситуации когда необходимо
сделать структуру записи зависимой от каких-либо условий.

<p align="JUSTIFY">
Для решения такого рода задач, Ада разрешает записям содержать дополнительные поля - дискриминанты.
Такие дополнительные поля являются средством "параметризации"
и помогают выполнять для записей требуемую настройку.
В этом случае, разные экземпляры записей могут принадлежать одному и тому же типу,
но при этом иметь разный размер и/или разное количество полей.

<p align="JUSTIFY">
Следует заметить, что
значения дискриминантов записей должны быть дискретного или ссылочного типа.



<p><h4><a name="s5.3.1">5.3.1 Вариантные записи</a></h4>

<p align="JUSTIFY">
Использование дискриминантов позволяет конструировать вариантные записи
(или, называемые иначе, записи с вариантами).
В этом случае, значение дискриминанта определяет наличие или отсутствие
некоторых полей записи.

<p align="JUSTIFY">
Рассмотрим следующий пример:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Vehicle <b>is</b> (Bicycle, Car, Truck, Scooter);

<b>type</b> Transport (Vehicle_Type : Vehicle) <b>is
    record</b>
        Owner       : String(1..10);      -- владелец
        Description : String(1..10);      -- описание
        <b>case</b> Vehicle_Type <b>is</b>
            <b>when</b> Car    =&gt;
                           Petrol_Consumption : Float; -- расход бензина
            <b>when</b> Truck  =&gt;
                           Diesel_Consumption : Float; -- расход солярки
                           Tare               : Real;  -- вес тары
                           Net                : Real;  -- вес нетто
            <b>when others</b> =&gt;
                           <b>null</b>;
        <b>end case</b>;
  <b>end record</b>;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В представленном описании типа записи <tt>Transport</tt>,
поле <tt>Vehicle_Type</tt> (vehicle - транспортное средство) является дискриминантом.


<p align="JUSTIFY">
В данном случае, значение дискриминанта должно быть указано при описании экземпляра записи.
Таким образом, можно создавать различные объекты у которых значения дискриминантов будут отличаться.
Заметим также, что при описании таких объектов допускается указывать только значение
дискриминанта, а присваивание значений остальным полям записи можно выполнять позже.
Агрегаты для записей с дискриминантами должны включать значение дискриминанта как первое значение.
Рассмотрим следующие описания:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

My_Car      : Transport (Car);
My_Bicycle  : Transport (Vehicle_Type =&gt; Bicycle);
His_Car     : Transport := (Car, "dale      ", "escort  ", 30.0);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Здесь, переменные <tt>My_Car</tt> и <tt>His_Car</tt>, у которых
дискриминант имеет значение <tt>Car</tt>, содержат поля:
<tt>Owner</tt>, <tt>Description</tt> и <tt>Petrol_Consumption</tt>.
При этом, попытка обращения к таким полям этих переменных
как <tt>Tare</tt> и/или <tt>Net</tt> будет не допустима.
В результате, это приведет к генерации ошибки ограничения (<i>constraint error</i>),
что может быть обнаружено и обработано при использовании механизма исключений
(<i>exceptions</i>) язака Ада.

<p align="JUSTIFY">
Следует особо отметить, что несмотря на то, что дискриминант является полем
записи, непосредственное присваивание значения дискриминанту запрещено.

<p align="JUSTIFY">
Также отметим, что в приведенных примерах тип записи, для простоты, имеет только один дискриминант.
Реально, запись может содержать столько дискриминантов,
сколько необходимо для решения конкретной задачи.

<p align="JUSTIFY">
И в заключение укажем несколько общих особенностей описания записей с вариантами:
<ul>
  <li>вариантная часть всегда записывается последней
  <li>запись может иметь только одну вариантную часть, однако внутри вариантной части
  разрешается указывать другой раздел вариантов
  <li>для каждого значения дискриминанта должен быть указан свой список компонентов
  <li>альтернатива <tt><b>others</b></tt> допустима только для последнего варианта,
  она задает все оставшиеся значения дискриминанта (возможно, и ни одного),
  которые не были упомянуты в предыдущих вариантах
  <li>если список компонентов варианта задан как <tt><b>null</b></tt>,
  то такой вариант не содержит никаких компонентов
</ul>


<p><h4><a name="s5.3.2">5.3.2 Ограниченные записи (<i>constrained records</i>)</a></h4>

<p align="JUSTIFY">
Записи <tt>My_Car</tt>, <tt>My_Bicycle</tt> и <tt>His_Car</tt>,
которые мы рассматривали выше, называют ограниченными.
Для таких записей значение дискриминанта определяется при описании экземпляра (переменной) записи.
Таким образом, однажды определенный дискриминант в последствии никогда не может быть изменен.
Так, запись <tt>My_Bicycle</tt> не имеет полей
<tt>Tare</tt>, <tt>Net</tt>, <tt>Petrol_Consumption</tt>, и т.д.
При этом, компилятор Ады даже не будет распределять пространство для этих полей.

<p align="JUSTIFY">
Из всего этого следует общее правило: любой экземпляр записи, который описан с указанием значения
дискриминанта, будет называться <b>ограниченным</b> (<i>constrained</i>).
Его дискриминант никогда не может принимать значение, отличное от заданного при его описании.




<p><h4><a name="s5.3.3">5.3.3 Неограниченные записи (<i>unconstrained records</i>)</a></h4>

<p align="JUSTIFY">
Ада позволяет описывать экземпляры записей без указания начального значения для дискриминанта,
тогда запись будет называться <b>неограниченной</b> (<i>unconstrained</i>).
В этом случае дискриминант может принимать любое значение
на протяжении всего времени существования записи, иначе говоря, дискриминант можно изменять.
Очевидно, что в этом случае, компилятор должен будет распределить достаточное пространство
для того, чтобы иметь возможность разместить наибольшую по размеру запись.

<p align="JUSTIFY">
Однако, для выполнения вышесказанного, дискриминант записи обязан иметь значение по-умолчанию,
которое указывается при описании типа записи.

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Accounts <b>is</b> (Cheque, Savings);
<b>type</b> Account (Account_Type: Accounts := Savings) <b>is</b>
    <b>record</b>
        Account_No  : Positive;
        Title       : String(1..10);
        <b>case</b> Account_Type <b>is</b>
            <b>when</b> Savings  =&gt; Interest : Rate;
            <b>when</b> Cheque   =&gt; <b>null</b>;
        <b>end case</b>;
    <b>end record</b>;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Здесь, дискриминант записи <tt>Account</tt> имеет значение по-умолчанию <tt>Savings</tt>.
Теперь, мы можем описать запись:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Household_Account : Account;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Такая запись будет создана с определенным по-умолчанию значением дискриминанта.
Но теперь, мы позже, при необходимости, можем изменить тип этой записи.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Household_Account:= (Cheque, 123_456, "household ");
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
В общем следует заметить, что Ада требует чтобы при описании типа записи
значения дискриминантов по-умолчанию либо указывались для всех дискриминантов,
либо не указывались вовсе. При этом, необходимо учесть, что если тип записи
описан с указанием значений дискриминантов по-умолчанию и, затем, при описании
экземпляра записи было указано значение дискриминанта, то такой экземпляр
записи, в результате, будет ограниченным.

<p align="JUSTIFY">
Также необходимо особо отметить, что значение дискриминанта неограниченного объекта
запрещается изменять независимо от изменения значений других полей, а непосредственное
присваивание значений дискриминанта, как уже говорилось, вовсе запрещено.
Поэтому, единственным способом изменения значения дискриминанта является
присваивание значения всему объекту. Кроме того, присваивание значений всему
объекту сразу является единственным способом изменения значений тех компонентов,
у которых определение подтипа зависит от значения дискриминанта.
Для пояснения последнего, рассмотрим пример:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b>  Property  <b>is array</b> (Positive <b>range</b> &lt;&gt;) <b>of</b> Float;
<b>type</b>  Man (Number: Positive := 2; Size: Positive := 10) <b>is
    record</b>
        Name        : String (1..Size);
        Prop_Array  : Property (1..Number);
    <b>end record</b>;

The_Man : Man;

The_Man.Name       := "Ivanov I I";
The_Man.Prop_Array := (25.0, 50.0);

  . . .
  
The_Man := (
            Number     =&gt; 3,
            Size       =&gt; 8,
            Name       =&gt; "Pyle I C",
            Prop_Array =&gt; (25.0, 50.0, 160.5)
           );
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Здесь, первоначально объект <tt>The_Man</tt> описан как запись, значения дискриминантов которой
устанавливаются по умолчанию. Затем, значения дискриминантов изменяются, но это изменение
выполняется согласно требований Ады: осуществляется присваивание значения всей переменной.


<p>
<h4><a name="s5.3.4">5.3.4 Другие использования дискриминантов</a></h4>

<p align="JUSTIFY">
Также как и при использовании в качестве селектора выбора варианта в записи,
дискриминант может быть использован для спецификации длины массива,
который является компонентом записи.

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Text (Length  : Positive := 20) <b>is</b>
    <b>record</b>
        Value : String(1..Length);
    <b>end record</b>;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В этом случае длина массива зависит от значения дискриминанта. Как указано выше,
запись может быть описана как ограниченная (<i>constrained</i>) или
как неограниченная (<i>unconstrained</i>).

<p align="JUSTIFY">
Обычно, такие текстовые записи используются как строки переменной
длины для текстовой обработки.

<p align="JUSTIFY">
Еще одним возможным способом использования дискриминантов могут быть описания различных подтипов
какого-либо базового типа.
В данном случае смысл идеи состоит в том, что подтипы можно использовать для создания объектов
с конкретными значениями дискриминантов.
Такой подход удобен при работе с типами, которые содержат большое количество дискриминантов.




<!--- footer --->




<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>




</blockquote>
</body>
</html>

