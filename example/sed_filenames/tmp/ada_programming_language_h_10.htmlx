<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<title>Адское программирование.</title>
</head>


<body BGCOLOR="FFFFFF">
<basefont size=3>
<blockquote>

<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>



<!--- header --->



<h2><a name="s10">10. Исключения</a></h2>

<p align="JUSTIFY">
Как это не печально, но процесс разработки и эксплуатации любого программного обеспечения
всегда сочетается с процессом поиска и исправления ошибок.

Все ошибки, возникающие в программах на языке Ада, можно разделить на два класса:

<dir>
- ошибки, которые обнаруживаются на этапе компиляции программы<br>
- ошибки, которые обнаруживаются во время выполнения программы<br>
</dir>

<p align="JUSTIFY">
Таким образом, не смотря на то, что одной из целей при разработке Ады была
задача максимально обеспечить возможность ранней диагностики и обнаружения ошибок,
то есть обнаружение ошибок на стадии компиляции программы,
бывают случаи когда ошибки возникают и во время выполнения программы.

<p align="JUSTIFY">
В Аде, ошибочные или другие исключительные ситуации,
возникающие в процессе выполнения программы, называются исключениями.

Это значит, что при возникновении ошибочной ситуации, во время выполнения
программы, вырабатывается сигнал о наличии исключения.

Такое действие называют возбуждением (генерацией или порождением) исключения
и понимают как приостановку нормального выполнения программы
для обработки соответствующей ошибочной ситуации.

В свою очередь, обработка исключения - это выполнение соответствующего кода
для определения причины возникновения ошибочной ситуации
которая привела к возбуждению исключения, а также, при возможности,
устранение причины возникновения ошибки и/или выполнение других корректирующих действий.

<p align="JUSTIFY">
Примечательно, что идея использования механизма исключений - это
тема многих споров о том, что исключения являются
или путем "ленивого" программирования, без достаточного анализа проблем
и сопутствующих условий приводящих к возникновениям ошибок,
или обычным видом управляющих структур, которые могут
быть использованы для достижения некоторых эффектов.

Тем не менее, хотя эти споры не прекращаются и в настоящее время,
следует обратить внимание на то, что механизм исключений
благополучно заимствован некоторыми современными реализациями
других языков программирования
(например, широко известная реализация языка <i>Object Pascal</i>
фирмы <i>Borland</i>).


<p align="JUSTIFY">
Все исключения языка программирования Ада можно разделить на стандартно предопределенные исключения
и исключения определяемые пользователем.



<p>
<h3><a name="s10.1">10.1 Предопределенные исключения</a></h3>

<p align="JUSTIFY">
Существует пять исключений которые стандартно предопределены в языке программирования Ада:

<p>
<center><table border=0 width="40%">
<tr>
<td valign="TOP"><font size=1><i>Constraint_Error</i></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="TOP"><font size=1>Ошибка ограничения</td>
</tr>
<tr>
<td valign="TOP"><font size=1><i>Numeric_Error</i></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="TOP"><font size=1>Ошибка числа</td>
</tr>
<tr>
<td valign="TOP"><font size=1><i>Program_Error</i></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="TOP"><font size=1>Ошибка программы</td>
</tr>
<tr>
<td valign="TOP"><font size=1><i>Storage_Error</i></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="TOP"><font size=1>Ошибка памяти</td>
</tr>
<tr>
<td valign="TOP"><font size=1><i>Tasking_Error</i></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="TOP"><font size=1>Ошибка задачи</td>
</tr>
</table>
</center>




<p><h4><a name="s10.1.1">10.1.1 Исключение <i>Constraint_Error</i></a></h4>

<p align="JUSTIFY">
Исключение <i>Constraint_Error</i> возбуждается в следующих случаях:

<ul>
<li>при попытке нарушения ограничения диапазона, ограничения индекса или ограничения дискриминанта
<li>при попытке использования компонента записи, не существующего при текущем значении дискриминанта
<li>при попытке использования именуемого или индексируемого компонента,
    отрезка или атрибута объекта, обозначенных ссылочным значением,
    если этот объект не существует, поскольку ссылочное значение равно <tt><b>null</b></tt>
</ul>


<p align="JUSTIFY">
Рассмотрим пример:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Constraint_Demo <b>is</b>

    X : Integer <b>range</b> 1..20;
    Y : Integer;

<b>begin</b>
    Put("enter a number ");
    Get(Y);
    X := Y;
    Put("thank you");
<b>end</b> Constraint_Demo;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Если пользователь вводит значение выходящее за диапазон значаний <tt>1..20</tt>,
то нарушается ограничение диапазона значений для <tt>X</tt>, и происходит
исключение <i>Constraint_Error</i>.

Поскольку в этом примере не предусмотрен код, который будет обрабатывать
это исключение, то выполнение программы будет завершено, и окружение времени выполнения Ады
(Ада-система) проинформирует пользователя о возникшей ошибке.

При этом, строка 


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

    Put("thank you");
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
выполнена не будет.

Таким образом, при возникновении исключения, остаток, выполняющегося в текущий
момент блока, будет отброшен.


<p align="JUSTIFY">
Рассмотрим пример в котором выполняется нарушение ограничения диапазона индексных
значений для массива:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Constraint_Demo2 <b>is</b>

    X : <b>array</b> (1..5) <b>of</b> Integer := (1, 2, 3, 4, 5);
    Y : Integer := 6;

<b>begin</b>
    X(Y) := 37;
<b>end</b> Constraint_Demo2;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Здесь, исключение <i>Constraint_Error</i> будет генерироваться когда мы будем
пытаться обратиться к несуществующему индексу массива.




<p><h4><a name="s10.1.2">10.1.2 Исключение <i>Numeric_Error</i></a></h4>

<p align="JUSTIFY">
Исключение <i>Numeric_Error</i> возбуждается в случае когда предопределенная численная операция
не может предоставить математически корректный результат

Это может произойти при арифметическом переполнении, делении на нуль,
а также не возможности обеспечить требуемую точность при выполнении операций
с плавающей точкой.

Следует заметить, что в Ada95 <i>Numeric_Error</i> переопределена таким образом,
что является тем же самым, что и <i>Constraint_Error</i>.



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Numeric_Demo <b>is</b>

    X : Integer;
    Y : Integer;

<b>begin</b>
    X := Integer<b>'<i>Last</i></b>;
    Y := X + X;             -- вызывает <i>Numeric_Error</i>
<b>end</b> Numeric_Demo;
</pre></dir>
</td></tr></table>




<p><h4><a name="s10.1.3">10.1.3 Исключение <i>Program_Error</i></a></h4>

<p align="JUSTIFY">
Исключение <i>Program_Error</i> возбуждается в следующих случаях:

<ul>
<li>при попытке вызова подпрограммы, активизации задачи или конкретизации настройки,
    если тело соответствующего модуля еще не обработано.
<li>если выполнение функции достигло завершающего <tt><b>end</b></tt>
    так и не встретив инструкцию возврата (<tt><b>return</b> ...</tt>)
<li>при межзадачном взаимодействии во время выполнения инструкции отбора с ожиданием (<tt><b>select</b> ...</tt>),
    когда все альтернативы закрыты и отсутствует раздел <tt><b>else</b></tt>
</ul>


<p align="JUSTIFY">
Кроме того, это исключение может возбуждаться в случае возникновения ошибки элаборации.

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Program_Demo <b>is</b>

    Z : Integer;

    <b>function</b> Y(X : Integer) <b>return</b> Integer <b>is</b>
    <b>begin</b>
        <b>if</b> X &lt; 10 <b>then</b>
            <b>return</b> X;
        <b>elsif</b>  X &lt; 20 <b>then</b>
            <b>return</b> X
        <b>end if</b>;
    <b>end</b> Y;                -- если мы попали в эту точку, то это значит,
                          -- что <i>return</i> не был выполнен

<b>begin</b>
    Z := Y(30);
<b>end</b> Program_Demo;
</pre></dir>
</td></tr></table>





<p><h4><a name="s10.1.4">10.1.4 Исключение <i>Storage_Error</i></a></h4>

<p align="JUSTIFY">
Исключение <i>Storage_Error</i> возбуждается в следующих случаях:

<ul>
<li>при попытке размещения динамического объекта обнаруживается, что
    нет достаточного пространства в динамической памяти (куче)
    которая выделена для задачи
<li>при исчерпании памяти выделенной для набора (коллекции) динамически размещаемых объектов
<li>при обращении к подпрограмме, когда израсходовано пространство стека
</ul>




<p><h4><a name="s10.1.5">10.1.5 Исключение <i>Tasking_Error</i></a></h4>

<p align="JUSTIFY">
Исключение <i>Tasking_Error</i> возбуждается в случаях межзадачного взаимодействия.

Оно может быть возбуждено при возникновении какого-либо исключения внутри задачи
которая в текущий момент времени принимает участие в межзадачном взаимодействии
или когда задача пытается организовать рандеву с абортированной задачей.




<p>
<h3><a name="s10.2">10.2 Исключения определяемые пользователем</a></h3>

<p align="JUSTIFY">
Механизм исключений Ады был бы не столь полным если бы он позволял использовать
только стандартно предопределенные исключения.

Поэтому, в дополнение к стандартно предопределенным исключениям,
Ада дает программисту возможность описывать свои собственные исключения
и, в случае необходимости, выполнять их возбуждение.




<p><h4><a name="s10.2.1">10.2.1 Описание исключения пользователя</a></h4>

<p align="JUSTIFY">
Описания пользовательских исключений должны размещаться в декларативной части кода,
то есть там где обычно размещаются описания (например, в спецификации пакета).

Форма описания исключений достаточно тривиальна и имеет следующий вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

My_Very_Own_Exception : <b>exception</b>;
Another_Exception     : <b>exception</b>;
</pre></dir>
</td></tr></table>



<p><h4><a name="s10.2.2">10.2.2 Возбуждение исключений</a></h4>

<p align="JUSTIFY">
Указание возбуждения исключения достаточно простое.

Для этого используется инструкция <tt><b>raise</b></tt>. Например:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>raise</b> Numeric_Error;
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Сгенерированное таким образом исключение не будет ничем отличаться от "истинного"
исключения <i>Numeric_Error</i>.




<p>
<h3><a name="s10.3">10.3 Обработка исключений</a></h3>


<p align="JUSTIFY">
В настоящий момент мы уже знаем стандартно предопределенные исключения Ады,
знаем как описывать исключения и знаем как их возбуждать (и свои, и предопределенные).

Однако, весь код примеров, которые мы рассматривали, не выполнял никакой обработки исключений.

Во всех рассмотренных случаях, после возникновения исключения,
происходило простое завершение выполнения программы кодом библиотеки времени
выполнения Ады.

Таким образом, для того, чтобы извлечь некоторую пользу из механизма исключений,
необходимо знать как анализировать ситуацию в случае возникновения исключения.

Проще говоря - необходимо рассмотреть как и где писать обработчики исключений.




<p><h4><a name="s10.3.1">10.3.1 Обработчики исключений</a></h4>

<p align="JUSTIFY">
Обработчик исключения может размещаться
в конце тела подпрограммы, пакета или настраиваемого модуля,
в конце тела задачи или входа,
а также
в конце инструкции блока или
инструкции принятия (<tt><b>accept</b></tt>).

Заметим, что обработчик исключения не является обязательной частью этих конструкций.


<p align="JUSTIFY">
Рассмотрим следующий пример:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>declare</b>

    X : Integer <b>range</b> 1..20;

<b>begin</b>
    Put("please enter a number ");
    Get(X);
    Put("thank you");

<b>exception</b>
    <b>when</b> Constraint_Error =&gt;
        Put("that number should be between 1 and 20");
    <b>when others</b> =&gt;
        Put("some other error occurred");
<b>end</b>;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Здесь описаны два обработчика. В одном выполняется обработка только исключений ограничения
(<i>Constraint_Error</i>). Второй обработчик выполняет обработку всех
остальных исключений (<tt><b>others</b></tt>).

Таким образом, если пользователь вводит число в диапазоне от 1 до 20, то ошибки не происходит
и появляется сообщение "<tt>thank you</tt>".

В противном случае, перед завершением выполнения
появляется сообщение обработчика исключения <i>Constraint_Error</i>:
"<tt>that number should be between 1 and 20</tt>".

В случае возникновения какого-либо другого исключения
появится сообщение от второго обработчика:
"<tt>some other error occurred</tt>".

<p align="JUSTIFY">
Можно описать обработчик исключений так, чтобы он обрабатывал несколько указанных исключений.
Для выполнения этого, исключения должны разделяться символом '<tt>|</tt>':

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

    . . .
<b>exception</b>
    . . .
    <b>when</b> Constraint_Error | Storage_Error =&gt;
        . . .
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Также следует заметить, что обработчик <tt><b>when others</b></tt> всегда должен быть последним
в списке обработчиков исключений.



<p align="JUSTIFY">
Если мы хотим чтобы пользователь продолжал ввод чисел до тех пор
пока не пропадет ошибка ограничения, мы можем переписать предыдущий пример
подобным образом:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>loop</b>
    <b>declare</b>
        . . .

    <b>begin</b>
        . . .

        Get(X);
        <b>exit</b>;

    <b>exception</b>
        <b>when</b> Constraint_Error =&gt;
          Put("that number ...
    <b>end</b>;

    . . .         -- здесь будет продолжено выполнение
                  -- после возникновения исключения
                  -- и обработки его обработчиком
<b>end loop</b>;    
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Кроме того, этот пример показывает точку
в которой будет продолжено выполнение инструкций после возникновения
исключения и его обработки обработчиком.



<p><h4><a name="s10.3.2">10.3.2 Распространение исключений</a></h4>

<p align="JUSTIFY">
Для того, чтобы точно знать в каком месте должен быть расположен
соответствующий обработчик исключения,
необходимо понимать
как при возникновении исключения, во время работы программы,
происходит поиск обработчика.

Этот процесс поиска называется распространением исключений.


<p align="JUSTIFY">
Если исключение не обрабатывается в подпрограмме в которой это исключение возникло, то
оно распространяется в подпрограмму которая вызвала текущую подпрорамму (на уровень выше).
После чего, обработчик исключения ищется в вызвавшей подпрограмме.

Если обработчик исключения не найден, то исключение распространяется дальше (еще на уровень выше).
Это продолжается до тех пор пока не будет найден обработчик возникшего исключения
или не будет достигнут уровень выполнения текущей задачи (наивысший уровень).

Если в случае достижения уровня выполнения текущей задачи (то есть наивысшего уровня)
обработчик исключения не будет найден, то текущая задача будет аварийно завершена
(другими словами, абортирована).

Если выполняется только одна задача, то библиотека времени выполнения Ады
выполняет обработку возникшего исключения и аварийно завершает выполнение всей программы
(другими словами, абортирует выполнение программы).


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Exception_Demo <b>is</b>

    ---------------------------------
    <b>procedure</b> Level_2 <b>is</b>
        -- здесь нет обработчика исключений
    <b>begin
        raise</b> Constraint_Error;
    <b>end</b> Level_2;

    ---------------------------------
    <b>procedure</b> Level_1 <b>is</b>
    <b>begin</b>
        Level_2;
    <b>exception</b>
        <b>when </b>Constraint_Error =&gt;
            Put("exception caught in Level_1");
    <b>end</b> Level_1;

<b>begin</b>
    Level_1;

<b>exception </b>
    <b>when</b> Constraint_Error =&gt;
        Put("exception caught in Exception_Demo");
<b>end</b> Exception_Demo;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
После запуска этой программы будет выдано только сообщение "<tt>exception caught in Level_1</tt>".

Следовательно, обработанное исключение не распространяется дальше.

<p align="JUSTIFY">
Модифицируем процедуру <tt>Level_1</tt> поместив инструкцию <tt><b>raise</b></tt> в ее
обработчик исключения.

Наш предыдущий пример будет иметь следующий вид:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>procedure</b> Exception_Demo <b>is</b>

    ---------------------------------
    <b>procedure</b> Level_2 <b>is</b>
        -- здесь нет обработчика исключений
    <b>begin
        raise</b> Constraint_Error;
    <b>end</b> Level_2;

    ---------------------------------
    <b>procedure</b> Level_1 <b>is</b>
    <b>begin</b>
        Level_2;
    <b>exception</b>
        <b>when</b> Constraint_Error =&gt;
            Put("exception caught in Level_1");
            <b>raise</b>;        -- регенерация текущего исключения;
                          -- дает возможность другим подпрограммам
                          -- произвести обработку возникшего
                          -- исключения
    <b>end</b> Level_1;

<b>begin</b>
    Level_1;

<b>exception </b>
    <b>when</b> Constraint_Error =&gt;
        Put("exception caught in Exception_Demo");
<b>end</b> Exception_Demo;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Теперь, инструкция <tt><b>raise</b></tt>, помещенная в обработчик исключения,
вызывает распространение исключения <i>Constraint_Error</i> на один уровень выше, то есть, к вызвавшей подпрограмме.

Таким образом, исключение может быть получено и соответствующим образом обработано
в каждой подпрограмме иерархии вызовов.


<p align="JUSTIFY">
Инструкцию <tt><b>raise</b></tt> очень удобно использовать в секции <tt><b>others</b></tt>
обработчика исключений:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

    . . .

<b>exception</b>

    . . .

    <b>when others</b> =&gt;
        <b>raise</b>;        -- регенерация текущего исключения;
                      -- дает возможность другим подпрограммам
                      -- произвести обработку возникшего
                      -- исключения
<b>end</b>;
</pre></dir>
</td></tr></table>




<p align="JUSTIFY">
В этом случае, соответствующее исключение
будет продолжать генерироваться и распространяться до тех пор, пока
не будет обработано надлежащим образом.

<p><h4><a name="s10.3.3">10.3.3 Проблемы с областью видимости при обработке исключений<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                                &nbsp;&nbsp;&nbsp;
                                определяемых пользователем</a></h4>

<p align="JUSTIFY">
Во всех предыдущих примерах, посвященных обработке исключений,
были использованы стандартно определенные исключения Ады.

Обработка исключений определяемых пользователем идентична обработке предопределенных
исключений, однако, при этом могут возникать некоторые проблемы с областью
видимости.

Рассмотрим следующий пример:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Ada.Text_IO; <b>use</b> Ada.Text_IO;

<b>procedure</b> Demo <b>is</b>
                
    <b>procedure</b> Problem_In_Scope <b>is</b>
        Cant_Be_Seen : <b>exception</b>;
    <b>begin
        raise</b> Cant_Be_Seen;
    <b>end</b> Problem_In_Scope;

<b>begin</b>
    Problem_In_Scope;

<b>exception </b>
    <b>when</b> Cant_Be_Seen =&gt;
        Put("just handled an_exception");
<b>end</b> Demo;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Этот пример не корректен.

Проблема в том, что область видимости исключения <tt>Cant_Be_Seen</tt>
ограничивается процедурой <tt>Problem_In_Scope</tt>,
которая, собственно и является источником этого исключения.

То есть, исключение <tt>Cant_Be_Seen</tt> не видимо и о нем ничего не известно
за пределами процедуры <tt>Problem_In_Scope</tt>.

Поэтому, это исключение не может быть точно обработано процедурой <tt>Demo</tt>.


<p align="JUSTIFY">
Решить эту проблему можно использованием опции <tt><b>others</b></tt> в обработчике
исключений внешней процедуры <tt>Demo</tt>:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Ada.Text_IO; <b>use</b> Ada.Text_IO;

<b>procedure</b> Demo <b>is</b>
                
    <b>procedure</b> Problem_In_Scope <b>is</b>
            Cant_Be_Seen : <b>exception</b>;
    <b>begin
            raise</b> Cant_Be_Seen;
    <b>end</b> Problem_In_Scope;

<b>begin</b>
    Problem_In_Scope;

<b>exception</b>
    <b>when others</b> =&gt;
        Put("just handled some exception");
<b>end</b> Demo;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Другая проблема возникает тогда, когда в соответствии с правилами области видимости,
исключение, описываемое в одной процедуре, перекрывает (или прячет) исключение,
описываемое в другой процедуре:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Ada.Text_IO; <b>use</b> Ada.Text_IO;

<b>procedure</b> Demo <b>is</b>

    Fred : <b>exception</b>;            -- глобальное исключение

    ------------------------------------
    <b>procedure</b> P1 <b>is</b>
    <b>begin</b>
        <b>raise</b> Fred;
    <b>end</b> P1;

    ------------------------------------
    <b>procedure</b> P2 <b>is</b>

        Fred : <b>exception</b>;        -- локальное исключение

    <b>begin</b>
        P1;

    <b>exception</b>
        <b>when</b> Fred =&gt;
            Put("wow, a Fred exception");
    <b>end</b> P2;
    ------------------------------------

<b>begin</b>
    P2;

<b>exception</b>
    <b>when</b> Fred =&gt;
        Put("just handled a Fred exception");
<b>end</b> Demo;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Выводом такой процедуры будет "<tt>just handled a Fred exception</tt>".
Исключение, обрабатываемое в процедуре <tt>P2</tt>, будет локально описанным исключением.
Такое поведение подобно ситуации с областью видимости обычных переменных.

<p align="JUSTIFY">
Для решения этой проблемы, процедуру <tt>P2</tt> можно переписать следующим образом:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

------------------------------------
<b>procedure</b> P2 <b>is</b>

    Fred : <b>exception</b>;

<b>begin</b>
    P1;

<b>exception</b>
    <b>when</b> Fred =&gt;
        -- локальное исключение
        Put("wow, an_exception");

    <b>when</b> Demo.Fred =&gt;
        -- "более глобальное" исключение
        Put("handeled Demo.Fred exception");
        <b>raise</b>;
<b>end</b> P2;
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Теперь,
обработчик исключения процедуры <tt>P2</tt>
выдаст сообщение "<tt>handeled Demo.Fred exception</tt>"
и, с помощью инструкции <tt><b>raise</b></tt>,
осуществит передачу исключения <tt>Demo.Fred</tt> в обработчик исключения процедуры <tt>Demo</tt>,
который, в свою очередь, выдаст сообщение "<tt>just handled a Fred exception</tt>".



<p><h4><a name="s10.3.4">10.3.4 Пакет <i>Ada.Exceptions</i></a></h4>

<p align="JUSTIFY">
Стандартный пакет <i>Ada.Exceptions</i> предоставляет некоторые дополнительные средства,
которые могут быть использованы при обработке исключений.

<p align="JUSTIFY">
Описанный в нем объект:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Event : Exception_Occurence;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
и подпрограммы:

<p>
<center><table border=0 width="85%">
<tr>
<td valign="TOP"><font size=1>функция <tt>Exception_Name(Event)</tt></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="TOP"><font size=1>возвращает строку имени исключения, начиная от корневого библиотечного модуля</td>
</tr>

<tr><td valign="TOP"><font size=1>&nbsp;</td><td valign="TOP"><font size=1>&nbsp;</td><td valign="TOP"><font size=1>&nbsp;</td></tr>

<tr>
<td valign="TOP"><font size=1>функция <tt>Exception_Information(Event)</tt></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="TOP"><font size=1>возвращает строку детальной информации о возникшем исключении</td>
</tr>

<tr><td valign="TOP"><font size=1>&nbsp;</td><td valign="TOP"><font size=1>&nbsp;</td></tr>

<tr>
<td valign="TOP"><font size=1>функция <tt>Exception_Message(Event)</tt></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="TOP"><font size=1>возвращает строку краткого объяснения исключения</td>
</tr>

<tr><td valign="TOP"><font size=1>&nbsp;</td><td valign="TOP"><font size=1>&nbsp;</td></tr>

<tr>
<td valign="TOP"><font size=1>процедура <tt>Reraise_Occurence(Event)</tt></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="TOP"><font size=1>выполняет повторное возбуждение исключения <tt>Event</tt></td>
</tr>

<tr><td valign="TOP"><font size=1>&nbsp;</td><td valign="TOP"><font size=1>&nbsp;</td></tr>

<tr>
<td valign="TOP"><font size=1>процедура <tt>Reraise_Exception(e, "Msg")</tt></td>
<td valign="TOP"><font size=1>&nbsp;-&nbsp;</td>
<td valign="TOP"><font size=1>выполняет возбуждение исключения <tt>e</tt> с сообщением "<tt>Msg</tt>"</td>
</tr>
</table></center>


<p align="JUSTIFY">
Могут быть весьма полезны при необходимости обработки неожиданных исключений.
В таких случаях можно использовать код который подобен следующему:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

    . . .

<b>exception</b>

    . . .

    <b>when</b> The_Event: <b>others</b> =&gt;
        Put("Unexpected exeption is ";
        Put(Exeption_Name(The_Event));
        New_Line;
</pre></dir>
</td></tr></table>



<p>
<h3><a name="s10.4">10.4 Подавление исключений</a></h3>


<p><h4><a name="s10.4.1">10.4.1 Принципы подавления исключений</a></h4>

<p align="JUSTIFY">
Как правило, существует два источника которые выполняют возбуждение исключений
при обнаружении некоторых ошибочных условий.

Один из них - это механизмы аппаратной проверки,
которые зависят от конкретно используемого оборудования.

Второй источник для нас более интересен, поскольку этим источником
является дополнительный машинный код, который генерирует компилятор.


<p align="JUSTIFY">
Поскольку генерация дополнительного кода выполняется компилятором, а все
компиляторы языка Ада должны соответствовать стандартным требованиям,
то должно быть обеспечено стандартное средство управления вставкой
подобных проверок в результирующий машинный код.

Таким средством Ады является директива компилятора <tt>Supress</tt> (подавление проверок).

<p align="JUSTIFY">
Эта директива может быть размещена в том месте, где не требуется производить проверки.
Подавление проверок будет распространяться до конца текущего блока (при этом используются
обычные правила области видимости).

<p align="JUSTIFY">
Директива <tt>Supress</tt> имеет большое количество опций, позволяющих
подавлять проверки различного вида на уровне типа, объекта или на функциональном уровне.

Следует заметить, что многогранность директивы <tt>Supress</tt>
сильно зависит от реализации конкретного компилятора,
и различные реализации компиляторов свободны в предоставлении (или игнорировании)
любых свойств этой директивы.

<p align="JUSTIFY">
Исключение <i>Constraint_Error</i> имеет несколько подавляемых проверок:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>pragma</b> Suppress (Access_Check);
<b>pragma</b> Suppress (Discriminant_Check);
<b>pragma</b> Suppress (Idex_Check);
<b>pragma</b> Suppress (Length_Check);
<b>pragma</b> Suppress (Range_Check);
<b>pragma</b> Suppress (Division_Check);
<b>pragma</b> Suppress (Owerflow_Check);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Исключение <i>Program_Error</i> имеет только одну подавляемую проверку:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>pragma</b> Suppress (Elaboration_Check);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Исключение <i>Storage_Error</i> также имеет только одну подавляемую проверку:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>pragma</b> Suppress (Storage_Check);
</pre></dir>
</td></tr></table>



<p><h4><a name="s10.4.2">10.4.2 Выполнение подавления исключений</a></h4>

<p align="JUSTIFY">
Мы можем подавить проверку исключений для индивидуального объекта:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>pragma</b> Suppress (Idex_Check, on =&gt; table);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Подавление проверки исключений также может относиться к какому-то определенному типу:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Employee_Id <b>is new</b> Integer;
<b>pragma</b> Suppress (Range_Check, Employee_Id);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Более полным примером использования директивы <tt>Supress</tt> может служить код
показанный ниже. В этом случае область действия директивы распространяется до конца
блока.

<p align="JUSTIFY"><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>declare</b>

    <b>pragma</b> Suppress(Range_Check);
    <b>subtype</b> Small_Integer <b>is</b> Integer <b>range</b> 1..10;

    A : Small_Integer;
    X : Integer := 50;

<b>begin</b>
    A := X;
<b>end</b>;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Этот код не будет генерировать ошибок ограничения (<i>Constraint_Error</i>).




<!--- footer --->




<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>




</blockquote>
</body>
</html>

