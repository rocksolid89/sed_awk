<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<title>Адское программирование.</title>
</head>


<body BGCOLOR="FFFFFF">
<basefont size=3>
<blockquote>

<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>



<!--- header --->



<h2><a name="s4">4. Массивы (<i>array</i>)</a></h2>

<p align="JUSTIFY">
Понятие массива подразумевает один из механизмов структурирования данных и является
одним из способов построения составных типов данных.
В сущности, массив - это набор данных идентичного типа.
Как правило, массиву дается какое-то имя, которое будет обозначать весь набор данных, и 
механизм индексации, позволяющий обращаться к индивидуальным элементам набора.
На сегодняшний день,
большинство языков программирования предусматривают возможность работы с различного
типа массивами.


<p align="JUSTIFY">
Ада предоставляет массивы подобно языку Паскаль, и, при этом, добавляет
некоторые новые полезные особенности.
Неограниченные и динамические массивы, атрибуты массивов - вот некоторые из
предлагаемых расширений.

<p>
<h3><a name="s4.1">4.1 Простые массивы</a></h3>


<p><h4><a name="s4.1.1">4.1.1 Описание простого массива</a></h4>

<p align="JUSTIFY">
В общем случае, при объявлении массива, сначала производится описание соответствующего типа.
Затем, экземпляр массива может быть создан используя описание этого типа.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Stack <b>is array</b> (1..50) <b>of</b> Integer;
Calculator_Workspace : Stack;

<b>type</b> Stock_Level <b>is</b> Integer <b>range</b> 0..20_000;
<b>type</b> Pet <b>is</b> (Dog, Budgie, Rabbit);
<b>type</b> Pet_Stock <b>is array</b>(Pet) <b>of</b> Stock_Level;

Store_1_Stock : Pet_Stock;
Store_2_Stock : Pet_Stock;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В приведенном выше примере, тип <tt>Stack</tt> - это массив из 50-ти целочисленных
элементов типа <tt>Integer</tt>, а <tt>Calculator_Workspace</tt> - это переменная
типа <tt>Stack</tt>. Еще одним описанием массива является тип <tt>Pet_Stock</tt>.
При этом, тип <tt>Pet_Stock</tt> - это массив элементов типа <tt>Stock_Level</tt>,
а для индексирования элементов массива <tt>Stock_Level</tt> используется
перечислимый тип <tt>Pet</tt>. Переменные <tt>Store_1_Stock</tt> и <tt>Store_2_Stock</tt> -
это переменные типа <tt>Pet_Stock</tt>.

<p align="JUSTIFY">
Общая форма описания массива имеет следующий вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> <i>&lt;имя_массива&gt;</i> <b>is array</b> (<i>&lt;спецификация_индекса&gt;</i>) <b>of</b> <i>&lt;тип_элементов_массива&gt;</i>;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Необходимо заметить:
<ul>
<li>спецификация индекса может быть типом (например, <tt>Pet</tt>)
<li>спецификация индекса может быть диапазоном (например, <tt>1..50</tt>)
<li>значения индекса должны быть дискретного типа
</ul>



<p><h4><a name="s4.1.2">4.1.2 Анонимные массивы</a></h4>

<p align="JUSTIFY">
Массив может быть объявлен непосредственно, без использования предопределенного
типа:
        

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

No_Of_Desks : <b>array</b>(1..No_Of_Divisions) <b>of</b> Integer;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В этом случае массив будет называться анонимным (поскольку он не имеет явного типа) и он будет
несовместим с другими массивами - даже такими, которые описаны таким же самым образом.
Кроме того, такие массивы не могут быть использованы как параметры подпрограмм.
В общем случае рекомендуется избегать использования анонимных массивов.



<p><h4><a name="s4.1.3">4.1.3 Организация доступа к отдельным элементам массива</a></h4>

<p align="JUSTIFY">
Организацию доступа к отдельным элементам массива проще всего продемонстрировать на
простых примерах. Так для обращения к значению элемента массива <tt>Store_1_Stock</tt>,
описанного ранее, можно использовать:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>if</b> Store_1_Stock(Dog) &gt; 10 <b>then</b> ...
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
В приведенном примере производится чтение значения элемента массива <tt>Store_1_Stock</tt>
(доступ по чтению).

<p align="JUSTIFY">
Для сохранения значения в элементе массива <tt>Store_2_Stock</tt> (доступ по записи)
можно использовать:        

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Store_2_Stock(Rabbit) := 200;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Необходимо отметить, что в обоих случаях доступ к элементу массива в Аде внешне
никак не отличается от вызова функции.



<p><h4><a name="s4.1.4">4.1.4 Агрегаты для массивов</a></h4>

<p align="JUSTIFY">
В общем случае, агрегат массива - это совокупность значений для каждого элемента массива.
Использование агрегатов позволяет
выполнять одновременное присваивание значений всем элементам массива
в эффективной и элегантной форме.

<p align="JUSTIFY">
Рассмотрим следующий пример:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Store_1_Stock := (5, 4, 300);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В данном случае, присваивание значений элементам массива <tt>Store_1_Stock</tt>
выполняется с помощью агрегата. Следует учесть, что в этом примере
значения в агрегате присваиваются в порядке соответствующем следованию элементов в массиве.
Такая нотация называется <b>позиционной</b> или <b>неименованой</b>, а такой агрегат -
<b>позиционный</b> или <b>неименованый агрегат</b>.

<p align="JUSTIFY">
Кроме позиционной нотации, возможно использование <b>именованой</b> нотации.
В этом случае именуется каждый индивидуальный элемент массива.
Используя именованую нотацию, предыдущий пример можно переписать следующим образом:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Store_1_Stock := (Dog =&gt; 5, Budgie =&gt; 4, Rabbit =&gt; 300);
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Такой вид агрегата называют <b>именованым агрегатом</b>.

<p align="JUSTIFY">
Приведем еще один пример именованого агрегата:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Store_1_Stock := (Dog | Budgie =&gt; 0, Rabbit =&gt; 100);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В пределах одного агрегата, Ада допускает использовать только один вид нотации.
Это означает, что комбинирование позиционной и именованой нотации в одном агрегате - не допустимо
и будет вызывать ошибку компиляции.
Например:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Store_1_Stock := (5, 4, Rabbit =&gt; 300);    -- это недопустимо!
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В агрегате может указываться диапазон дискретных значений:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Store_1_Stock := (Dog..Rabbit =&gt; 0);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Агрегаты обоих видов удобно использовать в описаниях:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Store_1_Stock:  Pet_Stock := (5, 4, 300);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
С агрегатами массивов разрешается использование опции <tt><b>others</b></tt>,
которая практически полезна при установке всех элементов массива
в какое-либо предопределенное значение.
Стоит учесть, что в таких случаях часто требуется квалификация типа.

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

New_Shop_Stock  : Pet_Stock := (<b>others</b> := 0);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Рассмотрим следующие описания:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>declare</b>
    <b>type</b> Numbers1 <b>is array</b>(1..10) <b>of</b> Integer;
    <b>type</b> Numbers2 <b>is array</b>(1..20) <b>of</b> Integer;
    A : Numbers1;
    B : Numbers2;
<b>begin</b>
    A := (1, 2, 3, 4, <b>others</b> =&gt; 5);
<b>end</b>;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Заметьте, что в данном случае опция <tt><b>others</b></tt> используется вместе с
позиционной нотацией. Поэтому Ада потребует указать квалификацию типа:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

A : = Numbers1'(1, 2, 3, 4, <b>others</b> =&gt; 5);
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
В общем случае, при использовании опции <tt><b>others</b></tt> совместно с любой из двух
нотаций, позиционной или именованой, требуется указывать квалификацию типа.


<p><h4><a name="s4.1.5">4.1.5 Отрезки (<i>array slices</i>)</a></h4>

<p align="JUSTIFY">
Для одномерных массивов Ада предусматривает удобную возможность указания
нескольких последовательных компонент массива. Такая последовательность
компонент массива называется отрезком массива (<i>array slice</i>).
В общем случае, отрезок массива может быть задан следующим образом:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<i>&lt;имя_массива&gt;</i> (<i>&lt;диапазон_значений_индекса&gt;</i>)
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Таким образом, для переменной <tt>Calculator_Workspace</tt> типа <tt>Stack</tt>,
рассмотренных ранее, можно указать отрезок, содержащий элементы с 5-го по 10-й,
следующим образом:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Calculator_Workspace (5 .. 10) := (5, 6, 7, 8, 9, 10);
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
В данном примере выполняется присваивание значений элементам
массива <tt>Calculator_Workspace</tt>, которые попадают в указанный отрезок,
с использованием позиционного агрегата массива.

<p align="JUSTIFY">
Приведем еще один простой пример:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Calculator_Workspace (25 .. 30) := Calculator_Workspace (5 .. 10);
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Напомним что использование отрезков допускается только для одномерных массивов.




<p><h4><a name="s4.1.6">4.1.6 Массивы-константы</a></h4>

<p align="JUSTIFY">
Ада допускает использование массивов-констант.
В таких случаях, при описании массива-константы,
необходимо инициализировать значения всех его элементов.
Такая инициализация, как правило, осуществляется с помощью агрегатов массивов.
Например:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> Months <b>is</b> (Jan, Feb, Mar, .... , Dec);
<b>subtype</b> Month_Days <b>is</b> Integer <b>range</b> 1..31;
<b>type</b> Month_Length <b>is array</b> (Jan..Dec) <b>of</b> Month_Days;

Days_In_Month : <b>constant</b> Month_Length := (31, 28, 31, 30, ... , 31);
</pre></dir>
</td></tr></table>




<p><h4><a name="s4.1.7">4.1.7 Атрибуты массивов</a></h4>

<p align="JUSTIFY">
С массивами ассоциируются следующие атрибуты:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<i>&lt;имя_массива&gt;</i><b>'<i>First</i></b>     -- нижняя граница массива
<i>&lt;имя_массива&gt;</i><b>'<i>Last</i></b>      -- верхняя граница массива

<i>&lt;имя_массива&gt;</i><b>'<i>Length</i></b>    -- количество элементов в массиве
                        -- <i>&lt;имя_массива&gt;</i><b>'<i>Last</i></b> - <i>&lt;имя_массива&gt;</i><b>'<i>First</i></b> + 1

<i>&lt;имя_массива&gt;</i><b>'<i>Range</i></b>     -- подтип объявленный как
                        -- <i>&lt;имя_массива&gt;</i><b>'<i>First</i></b>..<i>&lt;имя_массива&gt;</i><b>'<i>Last</i></b>
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Эти средства очень полезны для организации перебора элементов массивов.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>for</b> Count <b>in</b> <i>&lt;имя_массива&gt;</i><b>'<i>Range</i></b> <b>loop</b>

    . . .

<b>end loop</b>
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В приведенном выше примере, каждый элемент массива будет гарантированно обработан.


<p>
<h3><a name="s4.2">4.2 Многомерные массивы</a></h3>

<p align="JUSTIFY">
Ада позволяет использовать многомерные массивы. В качестве простого примера многомерного
массива рассмотрим двухмерный массив целых чисел <tt>Square</tt>:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Square_Size : <b>constant</b> := 5;
<b>subtype</b> Square_Index  <b>is</b> Integer <b>range</b> 1..Square_Size;
<b>type</b>  Square  <b>is array</b> (Square_Index, Square_Index) <b>of</b> Integer;

Square_Var  : Square := ( <b>others</b> =&gt; (<b>others</b> =&gt; 0) );
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Здесь, агрегат, который инициализирует переменную <tt>Square_Var</tt> типа <tt>Square</tt> в нуль,
построен как агрегат массива массивов, поэтому требуется двойное использование скобок
(опции <tt><b>others</b></tt> использованы для упрощения примера).

<p align="JUSTIFY">
Более сложный пример инициализации этой переменной,
использующий агрегат с позиционной нотацией,
может иметь следующий вид:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

----------------- столбцы   1   2   3   4   5

Square_Var  : Square := ( ( 1,  2,  3,  4,  5),     -- строка 1
                          ( 6,  7,  8,  9, 10),     -- строка 2
                          (11, 12, 13, 14, 15),     -- строка 3
                          (16, 17, 18, 19, 20),     -- строка 4
                          (21, 22, 23, 24, 25) );   -- строка 5
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Доступ к элементам такого массива можно организовать следующим образом:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Square_Var(1, 5) := 5;
Square_Var(5, 5) := 25;
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Возможно использование альтернативного способа для описания подобного двумерного массива.
Его можно описать как массив рядов (иначе - строк),
где каждый ряд является одномерным массивом целых чисел <tt>Square_Row</tt>.

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Square_Size : <b>constant</b> := 5;
<b>subtype</b> Square_Index  <b>is</b> Integer <b>range</b> 1..Square_Size;

<b>type</b>  Square_Row <b>is array</b> (Square_Index) <b>of</b> Integer;
<b>type</b>  Square     <b>is array</b> (Square_Index) <b>of</b> Square_Row;

Square_Var  : Square := ( <b>others</b> =&gt; (<b>others</b> =&gt; 0) );
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Примечательно, что инициализация переменных в обоих вариантах реализации двумерного
массива выполняется одинаково.

<p align="JUSTIFY">
В этом случае, доступ к элементам массива можно организовать следующим образом:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Square_Var (1)(5) := 5;
Square_Var (5)(5) := 25;
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
С многомерными массивами можно использовать те же атрибуты, которые допустимы
для простых одномерных массивов. При этом несколько изменяется форма указания атрибутов:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

&lt;имя_массива&gt;<b>'<i>First</i></b>(N)
&lt;имя_массива&gt;<b>'<i>Last</i></b>(N)
&lt;имя_массива&gt;<b>'<i>Length</i></b>(N)
&lt;имя_массива&gt;<b>'<i>Range</i></b>(N)
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
В данном случае, значение определяемое, например, как
<tt>&lt;имя_массива&gt;<b>'<i>Range</i></b>(N)</tt> будет возвращать диапазон
<tt>N</tt>-мерного индекса.




<p>
<h3><a name="s4.3">4.3 Типы неограниченных массивов (<i>unconstrained array</i>),<br>
                      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                      предопределенный тип <tt>String</tt></a></h3>

<p align="JUSTIFY">
До настоящего момента мы рассматривали только такие массивы у которых
диапазон значений индекса был заведомо известен.
Такие массивы называют ограниченными массивами, и они могут быть использованы
для создания экземпляров объектов с четко определенными во время описания типа границами.

<p align="JUSTIFY">
В дополнение к таким типам, Ада позволяет описывать типы массивов,
которые не имеют четко определенного диапазона для индексных значений,
когда описание типа не определяет границ массива.
Поэтому такие массивы называют неограниченными массивами (<i>unconstrained array</i>).

<p align="JUSTIFY">
Типы неограниченных массивов позволяют описывать массивы, которые
во всех отношениях идентичны обычным массивам, за исключением того, что
их размер не указан. Ограничение массива (указание диапазона для индексных значений)
производится при создании экземпляра объекта такого типа.

<p align="JUSTIFY">
Таким образом, описание неограниченого массива предоставляет целый класс массивов,
которые содержат элементы одинакового типа,
имеют одинаковый тип индекса и одинаковое количество индексов,
но при этом разные экземпляры объеков такого типа будут иметь разные размеры.

<p align="JUSTIFY">
Этот механизм удобно использовать в случаях когда массив произвольного
размера необходимо передать в подпрограмму как параметр.

<p align="JUSTIFY">
Примером описания неограниченного массива целых чисел может служить следующее:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b>  Numbers_Array   <b>is array</b> (Positive <b>range</b> &lt;&gt;) <b>of</b> Integer;
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Символы "<tt><b>&lt;&gt;</b></tt>" указывают, что диапазон значений индекса должен быть указан
при описании объектов типа <tt>Numbers_Array</tt>.
Переменная такого типа может быть описана следующим образом:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Numbers : Numbers_Array (1..5) := (1, 2, 3, 4, 5);
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Здесь, при описании переменной <tt>Numbers</tt> предусматривается ограничение (<i>constraint</i>)
размеров массива -  указывается диапазон значений индекса - <tt>(1..5)</tt>.


<p align="JUSTIFY">
Пакет <i>Standard</i> предоставляет предопределенный тип <tt>String</tt>,
который описывается как неограниченный массив символов: 

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>type</b> String <b>is array</b> (Positive <b>range</b> &lt;&gt;) <b>of</b> Character;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Таким образом, тип <tt>String</tt> может быть использован для описания обширного класса
символьных массивов, которые идентичны во всем, кроме количества элементов
в массиве.

<p align="JUSTIFY">
Также как и в предыдущем примере описания переменной <tt>Numbers</tt>,
для создания фактического массива типа <tt>String</tt>,
мы должны предусмотреть ограничение диапазона возможных значений индекса:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

My_Name : String (1..20);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Здесь, ограничение диапазона индексных значений находится в диапазоне <tt>1..20</tt>.
Преимущество такого подхода в том, что все описанные строки имеют один и тот же тип,
и могут, таким образом, использоваться как параметры подпрограмм.
Такой дополнительный уровень абстракции позволяет более общее использование подпрограмм
обработки строк.

<p align="JUSTIFY">
Необходимо заметить, что для инициализации объектов типа <tt>String</tt>,
можно использовать агрегаты, поскольку тип <tt>String</tt>, по сути,
является массивом символов. Однако, более цивилизованным способом
будет использование строковых литералов. Так, вышеописанную переменную <tt>My_Name</tt>,
можно инициализировать следующим образом:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

My_Name := "Alex                ";
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Следует учесть, что в приведенном примере, строковый литерал, указывающий имя,
необходимо дополнить пробелами, чтобы его размер совпадал с размером
описанной переменной.
В противном случае, компилятор может выдать предупреждение о возбуждении исключения
<i>Constraint_Error</i> во время выполнения программы.

<p align="JUSTIFY">
При описании строк, которым присваиваются начальные значения, границы диапазона
можно не указывать:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

Some_Name   : String := "Vasya Pupkin";
Some_Saying : <b>constant</b> String := "Beer without vodka is money to wind!";
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Для обработки каждого элемента переменной, которая порождается при использовании
типа неограниченного массива, требуется использование таких атрибутов типа массив,
как <tt>A<b>'<i>Range</i></b></tt>, <tt>A<b>'<i>First</i></b></tt> и т.д.,
поскольку не известно какие индексные значения будет иметь обрабатываемый массив.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

My_Name    : String (1..20);
My_Surname : String (21..50);
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Обычно, неограниченные массивы реализуются с объектом
который хранит значения границ диапазона индекса и указатель на массив.



<p>
<h3><a name="s4.4">4.4 Стандартные операции для массивов</a></h3>

<p align="JUSTIFY">
Существует несколько операций, которые могут выполняться не только над
отдельными элементами массива, но и над целым массивом.



<p><h4><a name="s4.4.1">4.4.1 Присваивание</a></h4>

<p align="JUSTIFY">
Целому массиву может присваиваться значение другого массива. Оба массива
должны быть одного и того же типа. Если оба массива одного и того же неограниченного типа,
то они должны содержать одинаковое количество элементов.

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>declare</b>
    My_Name   : String(1..10)  := "Dale      ";
    Your_Name : String(1..10)  := "Russell   ";
    Her_Name  : String(21..30) := "Liz       ";
    His_Name  : String(1..5)   := "Tim  ";
<b>begin</b>
    Your_Name := My_Name;     -- это корректно, поскольку в обоих случаях
    Your_Name := Her_Name;    -- оба массива имеют одинаковое количество
                              -- элементов
    His_Name  := Your_Name;   -- это приведет к возбуждению исключения:
                              -- хотя обе переменные одного и того же типа,
                              -- но они имеют различную длину (число элементов)
<b>end</b>;
</pre></dir>
</td></tr></table>



<p><h4><a name="s4.4.2">4.4.2 Проверки на равенство и на неравенство</a></h4>

<p align="JUSTIFY">
Проверки на равенство и на неравенство доступны почти для всех типов Ады.
Два массива считаются равными если каждый элемент первого массива равен
соответствующему элементу второго массива.

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>if</b> Array1 = Array2 <b>then</b>....
</pre></dir>
</td></tr></table>




<p><h4><a name="s4.4.3">4.4.3 Конкатенация</a></h4>

<p align="JUSTIFY">
Символ <tt><b>&amp;</b></tt> может быть использован как знак операции
конкатенации двух массивов.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>declare</b>
    <b>type</b> Vector <b>is array</b>(Positive <b>range</b> &lt;&gt;) <b>of</b> Integer;

    A : Vector (1..10);
    B : Vector (1..5) := (1, 2, 3, 4, 5);
    C : Vector (1..5) := (6, 7, 8, 9, 10);
<b>begin</b>
    A := B &amp; C;
    Put_Line("hello" &amp; " " &amp; "world");
<b>end</b>;
</pre></dir>
</td></tr></table>



<p><h4><a name="s4.4.4">4.4.4 Сравнение массивов</a></h4>

<p align="JUSTIFY">
Для сравнения одномерных массивов могут быть использованы следующие знаки операций
"<tt><b>&lt;</b></tt>", "<tt><b>&lt;=</b></tt>", "<tt><b>&gt;</b></tt>" и "<tt><b>&gt;=</b></tt>".
Они наиболее полезны при сравнении массивов символов (строк).


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

"hello" &lt; "world"        -- возвращает результат "истина" (<i>True</i>)
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
В общем случае, можно сравнивать только те массивы у которых можно сравнивать
между собой индивидуальные компоненты.
Таким образом, например,
нельзя сравнивать массивы записей для которых не определена операция сравнения.
(то есть, чтобы обеспечить возможность сравнения массивов записей,
необходимо, чтобы была определена операция сравнения для записи компонента массива).



<p><h4><a name="s4.4.5">4.4.5 Логические операции</a></h4>

<p align="JUSTIFY">
Если знаки логических операций
"<tt><b>and</b></tt>",
"<tt><b>or</b></tt>",
"<tt><b>xor</b></tt>",
"<tt><b>not</b></tt>"
допускается использовать для индивидуальных компонентов массива,
то использование знаков логических операций для такого массива также будет допустимым
(например, в случае массива логических значений типа <tt>Boolean</tt>).



<p>
<h3><a name="s4.5">4.5 Динамические массивы</a></h3>

<p align="JUSTIFY">
Ада позволяет не указывать размеры массива при написании программы.
В этом случае размеры массива не фиксируются во время компиляции программы,
а определяются во время ее выполнения, что во многих случаях более предпочтительно.
Массивы подобного вида известны как динамические массивы.
Кроме того, в отличие от многих других языков программирования,
Ада позволяет использование динамических массивов в качестве значения результата,
возвращаемого функцией.


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>declare</b>
    X        : Integer := Y    -- значение <i>Y</i> описано где-то в другом месте
    A        : <b>array</b> (1..X) <b>of</b> Integer;
<b>begin</b>
    <b>for</b> I <b>in</b> A<b>'<i>Range</i></b> <b>loop</b>

        . . .

    <b>end loop</b>;
<b>end</b>;


<b>procedure</b> Demo(Item  : String) <b>is</b>
    Copy    : String(Item<b>'<i>First</i></b>..Item<b>'<i>Last</i></b>) := Item;
    Double  : String(1..2 * Item<b>'<i>Length</i></b>) := Item &amp; Item;
<b>begin</b>
    . . .
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Следует заметить, что не стоит позволять вводу пользователя устанавливать размер массива,
и приведенный пример (с декларативным блоком)
не должен использоваться как способ решения этой задачи.
Использование второго примера наиболее типично.








<!--- footer --->




<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>




</blockquote>
</body>
</html>

