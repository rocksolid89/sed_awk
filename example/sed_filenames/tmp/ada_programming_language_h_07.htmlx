<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<title>Адское программирование.</title>
</head>


<body BGCOLOR="FFFFFF">
<basefont size=3>
<blockquote>

<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>



<!--- header --->



<h2><a name="s7">7. Пакеты</a></h2>

<p align="JUSTIFY">
Хотя корни Ады лежат в языке Паскаль, концепция пакетов была заимствована из других
языков программирования и подверглась значительному влиянию последних наработок в области
разработки программного обеспечения обсуждавшихся в 1970-х годах.

Несомненно, что одной из главных инноваций в этот период была концепция программного модуля
(или пакета).

<p align="JUSTIFY">
Следует заметить, что концепция пакетов не рассматривает то, как программа будет выполняться.

Идея данного подхода посвящена проблеме построения программного комплекса,
облегчению понимания того как он устроен и, следовательно, упрощению его сопровождения.


<p>
<h3><a name="s7.1">7.1 Общие сведения о пакетах Ады</a></h3>

<p><h4><a name="s7.1.1">7.1.1 Идеология концепции пакетов</a></h4>

<p align="JUSTIFY">
Прежде чем непосредственно рассматривать примеры языковых конструкций
необходимо разобраться в чем заключается и что предлагает
концепция пакетов.


<p align="JUSTIFY">
Пакет - это средство, которое позволяет сгруппировать логически связанные вычислительные ресурсы
и выделить их в единый самостоятельный программный модуль.

Под вычислительными ресурсами в этом случае подразумеваются
данные (типы данных, переменные, константы...) и подпрограммы
которые манипулируют этими данными.

Характерной особенностью данного подхода является разделение самого пакета
на две части: спецификацию пакета и тело пакета.
Причем, спецификацию имеет каждый пакет, а тело могут иметь не все пакеты.

<p align="JUSTIFY">
Спецификация определяет интерфейс к вычислительным ресурсам (сервисам) пакета
доступным для использования во внешней, по отношению к пакету, среде.

Другими словами - спецификация показывает "что" доступно при использовании этого пакета.

<p align="JUSTIFY">
Тело является приватной частью пакета и скрывает в себе все детали реализации
предоставляемых для внешней среды ресурсов,
то есть, тело хранит информацию о том "как" эти ресурсы устроены.

<p align="JUSTIFY">
Необходимо заметить, что разбиение пакета на спецификацию и тело не случайно,
и имеет очень важное значение.
Это дает возможность по-разному взглянуть на пакет.

Действительно, для использования ресурсов пакета достаточно знать только его спецификацию,
в ней содержится вся необходимая информация о том как использовать ресурсы пакета.

Необходимость в теле пакета возникает только тогда, когда нужно узнать или изменить
реализацию чего-либо внутри самого пакета.

<p align="JUSTIFY">
Средства построения такой конструкции как пакет
дают программисту мощный и удобный инструмент абстракции данных,
который позволяет объединить и выделить в логически законченное единое целое
данные и код который манипулирует этими данными.

При этом, пакет позволяет программисту скрыть все детали реализации сервисов
за развитым функциональным интерфейсом.

В результате, структурное представление программного комплекса
в виде набора взаимодействующих между собой компонентов
облегчает понимание работы комплекса в целом и, следовательно,
позволяет облегчить его разработку и сопровождение.

<p align="JUSTIFY">
Необходимо также заметить, что на этапе начального проектирования системы
можно предоставлять компилятору только спецификации, 
обеспечивая детали реализации только самых необходимых элементов.

Таким образом проверка корректности общей структуры проекта осуществляется
на ранней стадии, когда не потрачено много усилий на разработку реализации
отдельных элементов, которые позже придется переделывать
(что, к великому сожалению, в реальной жизни происходит достаточно часто).


<dir>
<p align="JUSTIFY">
<b>Примечание:</b><br>
В системе компилятора <i>GNAT</i> существует соглашение согласно которому
файлы спецификаций имеют расширение <tt>ads</tt> (<i>ADa Specification</i>),
а файлы тел имеют расширение <tt>adb</tt> (<i>ADa Body</i>).

</dir>



<p><h4><a name="s7.1.2">7.1.2 Спецификация пакета</a></h4>

<p align="JUSTIFY">
Как уже говорилось, спецификация пакета Ады определяет интерфейс доступа
к вычислительным ресурсам (сервисам) пакета.

Она может содержать описания типов, переменных, констант, спецификации подпрограмм, других
пакетов, - все то, что должно быть доступно тому, кто будет использовать данный пакет.

Простой пример спецификации пакета может иметь следующий вид:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Odd_Demo <b>is</b>
        
    <b>type</b> A_String <b>is array</b> (Positive <b>range</b> &lt;&gt;) <b>of</b> Character;

    Pi  : <b>constant</b> Float := 3.14;

    X   : Integer;

    <b>type</b> A_Record <b>is</b> 
        <b>record</b>
          Left  : Boolean;
          Right : Boolean;
        <b>end record</b>;

    -- примечательно, что дальше, для двух подпрограмм представлены только
    -- их спецификации, тела этих подпрограмм будут находиться в теле пакета

    <b>procedure</b> Insert(Item : <b>in</b> Integer; Success : <b>out</b> Boolean);
    <b>function</b> Is_Present(Item : <b>in</b> Integer) <b>return</b> Boolean;

<b>end</b> Odd_Demo;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Мы можем получить доступ к этим сервисам в нашем коде путем указания данного пакета
в спецификаторе совместности контекста <tt><b>with</b></tt>, а затем
использовать полную точечную нотацию.

Полная точечная нотация, в общем случае, имеет следующий вид:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<i>имя_пакета</i><b>.</b><i>имя_используемого_ресурса</i>
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
где <tt><i>имя_используемого_ресурса</i></tt> - это имя типа, подпрограммы, переменной и т.д.

<p align="JUSTIFY">
Для демонстрации сказанного приведем схематический пример процедуры которая использует
показанную выше спецификацию:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Odd_Demo;

<b>procedure</b> Odder_Demo <b>is</b>

    My_Name : Odd_Demo.A_String;
    Radius  : Float;
    Success : Boolean;

<b>begin</b>
    Radius := 3.0 * Odd_Demo.Pi;
    Odd_Demo.Insert(4, Success);
    <b>if</b> Odd_Demo.Is_Present(34) <b>then</b> ...
        . . .
<b>end</b> Odder_Demo;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Не трудно заметить, что доступ к ресурсам пакета, текстуально подобен
доступу к полям записи.

<p align="JUSTIFY">
В случаях, когда использование полной точечной нотации для доступа к ресурсам пакета
обременительно, можно использовать инструкцию спецификатора использования контекста
<tt><b>use</b></tt>.

Это позволяет обращаться к ресурсам которые предоставляет данный пакет
без использования полной точечной нотации, так, как будто они описаны непосредственно в этом же коде.




<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Odd_Demo;        <b>use</b> Odd_Demo;

<b>procedure</b> Odder_Demo <b>is</b>

    My_Name : A_String;
    Radius  : Float;
    Success : Boolean;

<b>begin</b>
    Radius := 3.0 * Pi;
    Insert(4, Success);
    <b>if</b> Is_Present(34) <b>then</b> ...
        . . .
<b>end</b> Odder_Demo;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Если два пакета, указаны в инструкциях <tt><b>with</b></tt> и <tt><b>use</b></tt> в одном
компилируемом модуле (например, в подпрограмме или другом пакете), то возможно
возникновение коллизии имен используемых ресурсов, которые предоставляются
двумя разными пакетами.

В этом случае можно избавиться от двусмысленности
путем возвращения к использованию полной точечной нотации для соответствующих
ресурсов.

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

-------------------------------
<b>package</b> No1 <b>is</b>
    A, B, C : Integer;
<b>end</b> No1;

-------------------------------
<b>package</b> No2 <b>is</b>
    C, D, E : Integer;
<b>end</b> No2;

-------------------------------
<b>with</b> No1;        <b>use</b> No1;
<b>with</b> No2;        <b>use</b> No2;

<b>procedure</b> Clash_Demo <b>is</b>
<b>begin</b>
    A := 1;
    B := 2;

    C := 3;        -- двусмысленность, мы ссылаемся
                   -- на <i>No1.c</i> или на <i>No2.c</i>?

    No1.C := 3;    -- избавление от двусмысленности путем возврата
    No2.C := 3;    -- к полной точечной нотации
<b>end</b> Clash_Demo;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Может возникнуть другая проблема - когда локально определенный ресурс "затеняет"
ресурс пакета указанного в инструкции <tt><b>use</b></tt>.

В этом случае также можно избавиться от двусмысленности путем использования полной точечной нотации.




<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> No1 <b>is</b>
    A : Integer;
<b>end</b> No1;

<b>with</b> No1;        <b>use</b> No1;
<b>procedure</b> P <b>is</b>
    A : Integer;
<b>begin</b>
    A := 4;       -- это - двусмысленно
    P.A := 4;     -- удаление двусмысленности путем указания
                  -- имени процедуры в точечной нотации
    No1.A := 5;   -- точечная нотация для пакета
<b>end</b> P;
</pre></dir>
</td></tr></table>



<p><h4><a name="s7.1.3">7.1.3 Тело пакета</a></h4>

<p align="JUSTIFY">
Тело пакета содержит все детали реализации сервисов, указаных в спецификации пакета.

Схематическим примером тела пакета, для показанной выше спецификации, может служить:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package body</b> Odd_Demo <b>is</b>

    <b>type</b> List <b>is array</b> (1..10) <b>of</b> Integer;
    Storage_List : List;
    Upto         : Integer;

    <b>procedure</b> Insert(Item     : <b>in </b>  Integer;
                     Success  : <b>out</b>  Boolean) <b>is</b>
    <b>begin</b>
        . . .
    <b>end</b> Insert;

    <b>function</b> Is_Present(Item : <b>in</b> Integer) <b>return</b> Boolean <b>is</b>

    <b>begin</b>
        . . .
    <b>end</b> Is_Present;


<b>begin </b>               -- действия по инициализации пакета
                     -- это выполняется до запуска основной программы!
    <b>for</b> I <b>in</b> Storage_List<b>'<i>Range</i></b> <b>loop</b>
        Storage_List(I) := 0;
    <b>end loop</b>;
    Upto := 0;
<b>end</b> Odd_Demo;
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Все ресурсы, указанные в спецификации пакета, будут непосредственно доступны в теле пакета
без использования дополнительных инструкций спецификации контекста
<tt><b>with</b></tt> и/или <tt><b>use</b></tt>.

<p align="JUSTIFY">
Необходимо заметить, что тело пакета, также как и спецификация пакета,
может содержать описания типов, переменных, подпрограмм и т.д.

При этом, ресурсы, описанные в теле пакета, не доступны для использования в другом самостоятельном
модуле (пакете или подпрограмме).

Любая попытка обращения к ним из другого модуля будет приводить к ошибке компиляции.

<p align="JUSTIFY">
Переменные, описанные в теле пакета, сохраняют свои значения между
успешными вызовами публично доступных подпрограмм пакета.

Таким образом, мы можем создавать пакеты, которые сохраняют информацию для
более позднего использования (другими словами: сохранять информацию о состоянии).

<p align="JUSTIFY">
Раздел "<tt><b>begin</b></tt> ... <tt><b>end</b></tt>", в конце тела пакета,
содержит перечень инструкций инициализации для этого пакета.

Инициализация пакета выполняется до запуска на выполнение главной подпрограммы.

Это справедливо для всех пакетов.

Следует заметить, что стандарт не определяет порядок выполнения инициализации различных пакетов.


<p>
<h3><a name="s7.2">7.2 Средства сокрытия деталей реализации внутреннего представления данных</a></h3>

<p align="JUSTIFY">
Как уже указывалось, спецификация пакета определяет интерфейс, а его тело скрывает реализацию
сервисов предоставляемых пакетом.

Однако, в примерах, показанных ранее, от пользователей пакетов были скрыты только детали
реализации подпрограмм, а все типы данных были открыто описаны в спецификации пакета.

Следовательно, все детали реализации представления внутренних структур данных
"видимы" пользователям.

В результате, пользователи таких пакетов,
полагаясь на открытость представления внутренних структур данных и используя эти сведения,
попадают в зависимость от деталей реализации структур данных.

Это значит, что в случае какого-либо изменения во внутреннем представлении данных,
как минимум, возникает необходимость в полной перекомпиляции всех программных модулей
которые используют такую информацию.

В худшем случае, зависимые модули придется не только перекомпилировать, но и переделать.

<p align="JUSTIFY">
На первый взгляд, сама проблема выглядит достаточно безобидно,
а идея скрыть реализацию внутреннего представления данных
кажется попыткой ущемления здорового любопытства пользователя.

Справедливо заметить, что такие мысли, как правило, возникают при виде простых структур данных
представленных в учебных примерах.

К сожалению, в реальной жизни все сложнее.

Представьте себе последствия изменения внутреннего представления данных
в реальном проекте когда зависимых модулей много и разрабатываются эти модули
разными программистами.


<p align="JUSTIFY">
Ада позволяет "закрыть" детали внутреннего представления данных
и, таким образом, избавиться от проблемы массовых переделок.
Такие возможности обеспечивает использование приватных типов
(<i>private types</i>) и лимитированных приватных типов
(<i>limited private types</i>).



<p>
<h3><a name="s7.2.1">7.2.1 Приватные типы (<i>private types</i>)</a></h3>

<p align="JUSTIFY">
Рассмотрим пример пакета который управляет счетами в бухгалтерской книге.

При этом, нам необходимо осуществлять полный контроль над всеми манипуляциями
которые выполняются с объектами,
и мы обеспечиваем пользователям пакета только следующие возможности:

<p>
<dir>
- изъятие средств (<tt>Withdraw</tt>)<br>
- размещение средств (<tt>Deposit</tt>)<br>
- создание счета (<tt>Create</tt>)<br>
</dir>

<p align="JUSTIFY">
Никакие другие пакеты не должны иметь представления о деталях реализации внутренней структуры
объекта бухгалтерского счета (<tt>Account</tt>) и, следовательно, иметь к ним доступ.

<p align="JUSTIFY">
Для того чтобы выполнить поставленную задачу, мы описываем объект бухгалтерского счета
<tt>Account</tt> как приватный тип:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Accounts <b>is</b>
    <b>type</b> Account <b>is private</b>;        -- описание будет представлено позже

    <b>procedure</b> Withdraw(An_Account : <b>in out</b> Account;
                       Amount     : <b>in</b>     Money);

    <b>procedure</b> Deposit( An_Account : <b>in out</b> Account;
                       Amount     : <b>in</b>     Money);
    <b>function</b> Create( Initial_Balance : Money) <b>return</b> Account;
    <b>function</b> Balance( An_Account : <b>in</b>    Account) <b>return</b> Integer;

<b>private</b>                -- эта часть спецификации пакета
                       -- содержит полные описания
    <b>type</b> Account <b>is</b>
        <b>record</b>
            Account_No : Positive;
            Balance    : Integer;
        <b>end record</b>;
<b>end</b> Accounts;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В результате такого описания, тип <tt>Account</tt> будет приватным.
Следут заметить, что Ада разрешает использовать следующие предопределенные
операции над объектами приватного типа вне этого пакета:

<p>
<dir>
- присваивание<br>
- проверка на равенство (не равенство)<br>
- проверки принадлежности ("<tt><b>in</b></tt>", "<tt><b>not in</b></tt>")<br>
</dir>

<p align="JUSTIFY">
Кроме предопределенных операций, над объектами приватного типа, вне этого пакета,
разрешается использовать операции, которые объявлены как подпрограммы в спецификации пакета
(обычные процедуры и функции, а также функции реализующие действия знаков операций).

<p align="JUSTIFY">
Все детали реализации внутреннего представления приватного типа доступны в теле пакета,
и любая подпрограмма в теле пакета имеет к ним доступ
и может модифицировать приватный тип как обычный тип.

Таким образом, приватность типа сохраняется только вне пакета.

<p align="JUSTIFY">
В данном примере необходимо обратить внимание на то, что спецификация пакета разделена на
две части.
Все что находится до зарезервированного слова <tt><b>private</b></tt> - это общедоступная
часть описаний, которая будет "видна" всем пользователям пакета.
Все что находится после зарезервированного слова <tt><b>private</b></tt> - это приватная
часть описаний, которая будет "видна" только внутри пакета
(и в его дочерних модулях; см. "Дочерние модули").

<p align="JUSTIFY">
Может показаться противоречивым размещение приватных описаний в спецификации пакета.

Действительно, мы пытаемся скрыть детали реализации приватного объекта, и размещаем
их в спецификации пакета, которая доступна.

Однако, это необходимо для программ, которые размещают экземпляры объектов приватного типа
поскольку компилятор, благодаря такой информации, знает сколько необходимо зарезервировать места
для размещения экземпляра объекта приватного типа.


<p align="JUSTIFY">
Хотя читатель спецификации пакета видит как устроено реальное внутреннее представление реализации
приватного типа, это не обеспечивает его возможностью явным и допустимым способом использовать
эту информацию.

При этом, примечательным является то, что
экземпляры объектов приватного типа могут быть созданы вне пакета.

Например:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Accounts;        <b>use</b> Accounts;

<b>procedure</b> Demo_Accounts <b>is</b>

    Home_Account : Account;
    Mortgage     : Account;
    This_Account : Account;

<b>begin</b>
    Mortgage := Accounts.Create(Initial_Balance =&gt; 500.00);
    Withdraw(Home_Account, 50);

        . . . 

    This_Account := Mortgage;        -- присваивание приватного типа - разрешено

    -- сравнение приватных типов
    <b>if</b> This_Account = Home_Account <b>then</b>

        . . .

<b>end</b> Demo_Accounts;
</pre></dir>
</td></tr></table>



<p>
<h3><a name="s7.2.2">7.2.2 Лимитированные приватные типы (<i>limited private types</i>)</a></h3>

<p align="JUSTIFY">
Хотя приватные типы позволяют разработчику получить значительный контроль
над действиями пользователя, ограничив способности пользователя
в манипулировании объектами,
бывают случаи когда необходимо запретить пользователю приватного типа использовать
даже такие предопределенные операции как сравнение и присваивание.

<p align="JUSTIFY">
В качестве демонстрации сказанного, рассмотрим следующий пример:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Compare_Demo <b>is</b>

    <b>type</b> Our_Text <b>is private</b>;

    . . .

<b>private</b>
    <b>type</b> Our_Text (Maximum_Length : Positive := 20) <b>is</b>
        <b>record</b>
            Length : Index := 0;
            Value  : String(1..Maximum_Length);
        <b>end record</b>;

    . . .

<b>end</b> Compare_Demo;
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Здесь, тип <tt>Our_Text</tt> описан как приватный и представляет из себя запись.

В данной записи, поле длины <tt>Length</tt> определяет число символов
которое содержит поле <tt>Value</tt> (другими словами - число символов которые имеют смысл).

Любые символы, находящиеся в позиции от <tt>Length + 1</tt> до <tt>Maximum_Length</tt> будут
нами игнорироваться при использовании этой записи.

Однако, если мы попросим компьютер сравнить две записи этого типа,
то он, в отличие от нас, не знает предназначения поля <tt>Length</tt>.

В результате, он будет последовательно сравнивать значения поля <tt>Length</tt>
и значения всех остальных полей записи.

Очевидно, что алгоритм предопределенной операции сравнения в данной ситуации
не приемлем, и нам необходимо написать собственную функцию сравнения.



<p align="JUSTIFY">
Для подобных случаев Ада предусматривает лимитированные приватные типы.

Изменим рассмотренный выше пример следующим образом:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Compare_Demo <b>is</b>

    <b>type</b> Our_Text <b>is limited private</b>;

    . . .

    <b>function</b> "=" (Left, Right : <b>in</b> Our_Text) <b>return</b> Boolean;

    . . .

<b>private</b>
    <b>type</b> Our_Text (Maximum_Length : Positive := 20) <b>is</b>
        <b>record</b>
            Length : Index := 0;
            Value  : String(1..Maximum_Length);
        <b>end record</b>;

    . . .

<b>end</b> Compare_Demo;
</pre></dir>
</td></tr></table>

<p align="JUSTIFY">
Теперь, тип <tt>Our_Text</tt> описан как лимитированный приватный тип.

Также, в спецификации пакета, описана функция знака операции сравнения на равенство <tt>"="</tt>.

Реализация алгоритма этой функции должна быть помещена в тело пакета.

Примечательно, что при совмещении знака операции равенства <tt>"="</tt> автоматически
производится неявное совмещение знака операции неравенства <tt>"/="</tt>.

При этом следует учесть, что если функция реализующая действие знака операции равенства <tt>"="</tt>
возвращает значение тип которого отличается от предопределенного логического типа <tt>Boolean</tt>
(полное имя - <tt>Standard.Boolean</tt>), то совмещение знака операции неравенства <tt>"/="</tt>
необходимо описать явно.


Следует заметить, что Ада разрешает переопределять знак операции равенства для всех типов.


<p align="JUSTIFY">
Для лимитированного приватного типа можно также создать процедуру для выполнения присваивания
(или инициализации).

Например, для показанного выше типа <tt>Our_Text</tt>,
спецификация такой процедуры может иметь следующий вид:


<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

    . . .
    <b>procedure</b> Init (T : <b>in out</b> Our_Text;
                           S : <b>in</b>     String);
    . . .
</pre></dir>
</td></tr></table>


<p align="JUSTIFY">
Напомним, что спецификация такой процедуры должна быть размещена в спецификации
пакета <i>Compare_Demo</i>, а ее тело (реализация) - в теле этого пакета.




<p>
<h3><a name="s7.2.3">7.2.3 Отложенные константы (<i>deferred constants</i>)</a></h3>

<p align="JUSTIFY">
В некоторых спецификациях пакетов возникает необходимость описать
константу приватного типа. Это можно выполнить таким же образом как и
описание приватного типа (а также большинство опережающих ссылок).
В общедоступной части спецификации пакета мы создаем неполное описание константы,
после чего, компилятор ожидает получить полное описание константы
в приватной части спецификации пакета. Например:

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Coords <b>is</b>

    <b>type</b> Coord <b>is private</b>;
    Home: <b>constant</b> Coord;  -- отложенная константа!

<b>private</b>
    <b>type</b> Coord <b>is record</b>
        X : Integer;
        Y : Integer;
    <b>end record</b>;

    Home : <b>constant</b> Coord := (0, 0);
<b>end</b> Coords;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
В результате такого описания, пользователи пакета <i>Coords</i>
"видят" константу <tt>Home</tt>, которая имеет приватный тип <tt>Coord</tt>,
и могут использовать эту константу в своем коде.

При этом, детали внутреннего представления этой константы им не доступны
и они могут о них не заботиться.



<p>
<h3><a name="s7.3">7.3 Дочерние модули (<i>child units</i>) (Ada95)</a></h3>


<p align="JUSTIFY">
Не редко, во время интенсивной разработки большой системы,
возникают случаи когда один из пакетов разрастается необычайно быстро,
а его спецификация подвергается постоянным изменениям.

Таким образом, ввиду частого обновления спецификации пакета, резко возрастают затраты
на перекомпиляцию зависимых модулей, а увеличение размеров самого пакета
усложняет его дальнейшую разработку и последующее сопровождение.

<p align="JUSTIFY">
Для преодоления подобных трудностей Ада предлагает концепцию дочерних модулей,
которая является основой в построении иерархических библиотек.

Такой подход позволяет разделить пакет большого размера на
самостоятельные пакеты и подпрограммы меньшего размера,
объединенные в общую иерархию.

Кроме того, эта концепция позволяет расширять уже существующие пакеты.
Она предлагает удобный инструмент для обеспечения
множества реализаций одного абстрактного типа и
дает возможность разработки самодостаточных
подсистем при использовании приватных дочерних модулей.

<p align="JUSTIFY">
Дочерние модули непосредственно используются в стандартной библиотеке Ады.

В частности, дочерними модулями являются такие пакеты как 
<i>Ada.Text_IO</i>, <i>Ada.Integer_Text_IO</i>.

<!---
<p align="JUSTIFY">
--->
Следует также заметить, что концепция дочерних модулей была введена стандартом Ada95.
В стандарте Ada83 эта идея отсутствует.




<p>
<h4><a name="s7.3.1">7.3.1 Расширение существующего пакета</a></h4>

<p align="JUSTIFY">
Рассмотрим случай когда возникает необходимость расширения пакета
который уже содержит некоторое множество описаний.

Например, в пакете <i>Stacks</i> может понадобиться дополнительный сервис просмотра <tt>Peek</tt>.

Если в текущий момент времени пакет <i>Stacks</i> используется многими модулями,
то такая модификация, путем добавления нового сервиса,
потребует значительных затрат на перекомпиляцию всех зависимых модулей,
причем, включая и те модули которые не будут использовать новый сервис.


<p align="JUSTIFY">
Следовательно, для логического расширения уже существующего пакета
предпочтительнее использовать дочерний пакет
который будет существовать абсолютно отдельно. Например:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Stacks <b>is</b>

    <b>type</b> Stack <b>is private</b>;
    <b>procedure</b> Push(Onto : <b>in out</b> Stack; Item : Integer);
    <b>procedure</b> Pop(From : <b>in out</b> Stack; Item : <b>out</b> Integer);
    <b>function</b> Full(Item : Stack) <b>return</b> Boolean;
    <b>function</b> Empty(Item : Stack) <b>return</b> Boolean;

<b>private</b>
    -- скрытая реализация стека
    ...
    -- точка <i><u> A </u></i>

<b>end</b> Stacks;

<b>package</b> Stacks.More_Stuff <b>is</b>

    <b>function</b> Peek(Item : Stack) <b>return</b> Integer;

<b>end</b> Stacks.More_Stuff;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
По правилам Ады, спецификация родительского пакета обеспечивает для дочернего пакета
такую же самую область видимости, что и для своего тела.

Следовательно, дочерний пакет видит всю приватную часть спецификации родительского пакета.

<p align="JUSTIFY">
В показанном выше примере, пакет <i>Stacks.More_Stuff</i> является дочерним пакетом
для пакета <i>Stacks</i>.

Значит, дочерний пакет <i>Stacks.More_Stuff</i> "видит" все описания
пакета <i>Stacks</i>, вплоть до точки <i>A</i>.

<p align="JUSTIFY">
Необходимо заметить, что для сохранения приватности описаний родительского пакета,
Ада не позволяет включать в спецификацию дочернего пакета приватную часть спецификации
родительского пакета.

<dir>
<p align="JUSTIFY">
<b>Примечание:</b><br>

Согласно правил именования файлов, принятым в системе компилятора <i>GNAT</i>,
спецификация и тело пакета <i>Stacks</i> должны быть помещены в файлы:<br>
<dir>
<tt>stacks.ads</tt> и <tt>stacks.adb</tt><br>
</dir>
соответственно, а спецификация и тело дочернего пакета <i>Stacks.More_Stuff</i>
- в файлы:<br>
<dir>
<tt>stacks-more_stuff.ads</tt> и <tt>stacks-more_stuff.adb</tt>
</dir>

</dir>


<p align="JUSTIFY">
Клиенту, которому необходимо использовать функцию <tt>Peek</tt>, просто необходимо
включить дочерний пакет в инструкцию спецификатора совместности контекста <tt><b>with</b></tt>:



<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Stacks.More_Stuff;

<b>procedure</b> Demo <b>is</b>

    X : Stacks.Stack;

<b>begin</b>
    Stacks.Push(X, 5);
    <b>if</b> Stacks.More_Stuff.Peek = 5 <b>then</b>
        . . .

<b>end</b> Demo;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Следует заметить, что включение дочернего пакета в инструкцию спецификатора совместности контекста
<tt><b>with</b></tt> автоматически подразумевает включение в инструкцию <tt><b>with</b></tt>
всех пакетов-родителей.

Однако, инструкция спецификатора использования контекста <tt><b>use</b></tt>
таким образом не работает.

То есть, область видимости может быть получена пакетом только в базисе пакета.




<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>with</b> Stacks.More_Stuff; <b>use</b> Stacks; <b>use</b> More_Stuff;

<b>procedure</b> Demo <b>is</b>

    X : Stack;

<b>begin</b>
    Push(X, 5);
    <b>if</b> Peek(x) = 5 <b>then</b>
        . . .

<b>end</b> Demo;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Необходимо также заметить, что подпрограммы (процедуры и функции) могут быть дочерними модулями
пакета (правила их использования достаточно очевидны).

При этом, однако, сами подпрограммы не могут иметь дочерние модули.






<p>
<h4><a name="s7.3.2">7.3.2 Иерархия модулей как подсистема</a></h4>

<p align="JUSTIFY">
Каждый программный модуль (процедура, функция пакет) должен иметь уникальное имя.

Бывают случаи, когда происходит быстрое заполнение пространства имен.

Например, при проектировании большой системы достаточно сложно обеспечить
уникальность имен и при этом сохранить их смысловое значение,
а в случаях когда разные части проекта разрабатываются разными программистами
(или даже коллективами программистов) риск получения коллизии имен увеличивается
еще больше.

<p align="JUSTIFY">
В подобных ситуациях, используя концепцию дочерних модулей Ады,
можно выделить каждую отдельно разрабатываемую подсистему в
самостоятельную иерархию модулей.

При этом, каждая подсистема будет иметь свой собственный корневой пакет
с уникальным именем.




<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>package</b> Root <b>is</b>

    -- корневой пакет может быть пустым

<b>end</b> Root;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Поскольку имя корневого пакета уникально, то имена дочерних модулей иерархии
также будут уникальны, что, в результате, минимизирует вероятность коллизии имен.

Кроме того, такой прием является удобным средством разделения большого проекта
на логически самостоятельные составные части.

<p align="JUSTIFY">
Примером использования подобного подхода может служить стандартная библиотека Ады,
которая предстявляется как набор дочерних модулей трех корневых пакетов:
<i>Ada</i>, <i>Interfaces</i> и <i>System</i>.





<p>
<h4><a name="s7.3.3">7.3.3 Приватные дочерние модули (<i>private child units</i>)</a></h4>

<p align="JUSTIFY">
Дочерние модули могут быть приватными.

Такая концепция позволяет создавать дочерние модули,
которые будут видимы только внутри иерархии родительского пакета.

В этом случае сервисы для подсистемы могут быть инкапсулированы внутри приватных
пакетов, используя наследуемые ими преимущества для компиляции и видимости.

<p align="JUSTIFY">
В спецификацию приватных дочерних пакетов разрешается включать приватную часть
спецификации их пакетов-родителей, поскольку такие дочерние модули - приватны.

В обычном случае - это не разрешается, так как нарушает сокрытие деталей
реализации родительской приватной части.

<p><table BGCOLOR="E0E0E0" border=0 width="95%">
<tr><td><font size=1>
<dir><pre>

<b>private package</b> Stacks.Statistics <b>is</b>

    <b>procedure</b> Increment_Push_Count;

<b>end</b> Stacks.Statistics;
</pre></dir>
</td></tr></table>



<p align="JUSTIFY">
Процедура <i>Stacks.Statistics.Increment_Push_Count</i> могла бы быть вызвана
внутри реализации пакета <i>Stacks</i>. Такая процедура не будет доступна ни одному
внешнему, по отношению к этой иерархии модулей, клиенту.






<!--- footer --->




<p><hr><table border=0 width="95%"><tr>
<td align="left"><font size=2>Copyright (C) А.Гавва</td>
<td align="right"><font size=2>V-0.4w май 2004</td>
</tr></table><hr><p>




</blockquote>
</body>
</html>

